
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>morfx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/termfx/morfx/cmd/morfx/main.go (30.8%)</option>
				
				<option value="file1">github.com/termfx/morfx/core/atomicwriter.go (88.9%)</option>
				
				<option value="file2">github.com/termfx/morfx/core/fileprocessor.go (84.7%)</option>
				
				<option value="file3">github.com/termfx/morfx/core/filewalker.go (91.4%)</option>
				
				<option value="file4">github.com/termfx/morfx/core/process_unix.go (85.7%)</option>
				
				<option value="file5">github.com/termfx/morfx/core/transaction.go (91.1%)</option>
				
				<option value="file6">github.com/termfx/morfx/db/sqlite.go (90.3%)</option>
				
				<option value="file7">github.com/termfx/morfx/demo/cmd/main.go (0.0%)</option>
				
				<option value="file8">github.com/termfx/morfx/demo/fixtures/example.go (0.0%)</option>
				
				<option value="file9">github.com/termfx/morfx/mcp/async_staging.go (58.8%)</option>
				
				<option value="file10">github.com/termfx/morfx/mcp/config.go (76.9%)</option>
				
				<option value="file11">github.com/termfx/morfx/mcp/errors.go (92.9%)</option>
				
				<option value="file12">github.com/termfx/morfx/mcp/handlers.go (69.4%)</option>
				
				<option value="file13">github.com/termfx/morfx/mcp/logging.go (93.8%)</option>
				
				<option value="file14">github.com/termfx/morfx/mcp/pagination.go (56.7%)</option>
				
				<option value="file15">github.com/termfx/morfx/mcp/progress.go (80.0%)</option>
				
				<option value="file16">github.com/termfx/morfx/mcp/prompts.go (99.1%)</option>
				
				<option value="file17">github.com/termfx/morfx/mcp/prompts/prompts.go (100.0%)</option>
				
				<option value="file18">github.com/termfx/morfx/mcp/prompts/registry.go (100.0%)</option>
				
				<option value="file19">github.com/termfx/morfx/mcp/protocol.go (65.0%)</option>
				
				<option value="file20">github.com/termfx/morfx/mcp/query_wrapper.go (75.0%)</option>
				
				<option value="file21">github.com/termfx/morfx/mcp/registry.go (100.0%)</option>
				
				<option value="file22">github.com/termfx/morfx/mcp/resource_templates.go (75.0%)</option>
				
				<option value="file23">github.com/termfx/morfx/mcp/resources.go (76.1%)</option>
				
				<option value="file24">github.com/termfx/morfx/mcp/resources/resources.go (90.0%)</option>
				
				<option value="file25">github.com/termfx/morfx/mcp/router.go (92.3%)</option>
				
				<option value="file26">github.com/termfx/morfx/mcp/safety.go (81.9%)</option>
				
				<option value="file27">github.com/termfx/morfx/mcp/safety_process_unix.go (66.7%)</option>
				
				<option value="file28">github.com/termfx/morfx/mcp/server.go (76.5%)</option>
				
				<option value="file29">github.com/termfx/morfx/mcp/server_interface.go (61.1%)</option>
				
				<option value="file30">github.com/termfx/morfx/mcp/session_state.go (78.8%)</option>
				
				<option value="file31">github.com/termfx/morfx/mcp/staging.go (20.6%)</option>
				
				<option value="file32">github.com/termfx/morfx/mcp/test_db_helpers.go (75.0%)</option>
				
				<option value="file33">github.com/termfx/morfx/mcp/tools/append.go (77.6%)</option>
				
				<option value="file34">github.com/termfx/morfx/mcp/tools/apply.go (77.8%)</option>
				
				<option value="file35">github.com/termfx/morfx/mcp/tools/base.go (37.5%)</option>
				
				<option value="file36">github.com/termfx/morfx/mcp/tools/delete.go (78.0%)</option>
				
				<option value="file37">github.com/termfx/morfx/mcp/tools/file_delete.go (6.5%)</option>
				
				<option value="file38">github.com/termfx/morfx/mcp/tools/file_query.go (86.2%)</option>
				
				<option value="file39">github.com/termfx/morfx/mcp/tools/file_replace.go (6.5%)</option>
				
				<option value="file40">github.com/termfx/morfx/mcp/tools/insert_after.go (78.4%)</option>
				
				<option value="file41">github.com/termfx/morfx/mcp/tools/insert_before.go (76.5%)</option>
				
				<option value="file42">github.com/termfx/morfx/mcp/tools/query.go (79.3%)</option>
				
				<option value="file43">github.com/termfx/morfx/mcp/tools/registry.go (82.1%)</option>
				
				<option value="file44">github.com/termfx/morfx/mcp/tools/replace.go (81.5%)</option>
				
				<option value="file45">github.com/termfx/morfx/mcp/tools/test_helpers.go (17.5%)</option>
				
				<option value="file46">github.com/termfx/morfx/mcp/transaction_log.go (37.3%)</option>
				
				<option value="file47">github.com/termfx/morfx/mcp/transform_finalize.go (66.1%)</option>
				
				<option value="file48">github.com/termfx/morfx/mcp/types/types.go (14.3%)</option>
				
				<option value="file49">github.com/termfx/morfx/mcp/utils.go (75.0%)</option>
				
				<option value="file50">github.com/termfx/morfx/models/models.go (100.0%)</option>
				
				<option value="file51">github.com/termfx/morfx/providers/base/cache.go (71.0%)</option>
				
				<option value="file52">github.com/termfx/morfx/providers/base/provider.go (89.3%)</option>
				
				<option value="file53">github.com/termfx/morfx/providers/catalog/catalog.go (88.2%)</option>
				
				<option value="file54">github.com/termfx/morfx/providers/contract.go (38.5%)</option>
				
				<option value="file55">github.com/termfx/morfx/providers/golang/config.go (54.8%)</option>
				
				<option value="file56">github.com/termfx/morfx/providers/golang/provider.go (100.0%)</option>
				
				<option value="file57">github.com/termfx/morfx/providers/javascript/config.go (22.9%)</option>
				
				<option value="file58">github.com/termfx/morfx/providers/javascript/provider.go (100.0%)</option>
				
				<option value="file59">github.com/termfx/morfx/providers/php/config.go (38.4%)</option>
				
				<option value="file60">github.com/termfx/morfx/providers/php/provider.go (100.0%)</option>
				
				<option value="file61">github.com/termfx/morfx/providers/python/config.go (42.4%)</option>
				
				<option value="file62">github.com/termfx/morfx/providers/python/provider.go (100.0%)</option>
				
				<option value="file63">github.com/termfx/morfx/providers/typescript/config.go (32.7%)</option>
				
				<option value="file64">github.com/termfx/morfx/providers/typescript/provider.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "testing"

        "github.com/joho/godotenv"
        "github.com/spf13/cobra"

        "github.com/termfx/morfx/mcp"
)

var (
        // Root command
        rootCmd = &amp;cobra.Command{
                Use:   "morfx",
                Short: "Code transformation engine with MCP protocol support",
                Long: `Morfx MCP Server provides deterministic AST-based code transformations
through the Model Context Protocol (MCP) for AI agents.

The server communicates via JSON-RPC 2.0 over stdio and supports language-agnostic
code querying, replacement, deletion, and insertion operations with confidence scoring.`,
                Version: "1.4.0",
        }

        // MCP server command
        mcpCmd = &amp;cobra.Command{
                Use:   "mcp",
                Short: "Start MCP protocol server for AI agents",
                Long: `Start the Model Context Protocol (MCP) server that communicates via JSON-RPC 2.0 over stdio.
                
This server is designed to integrate with AI agents that support the MCP protocol,
providing code transformation capabilities with confidence scoring and staged operations.`,
                Run: runMCPServer,
        }

        // Configuration flags
        dbURL              string
        debug              bool
        autoApply          bool
        autoApplyThreshold float64
)

func init() <span class="cov1" title="1">{
        // Global flags
        rootCmd.PersistentFlags().BoolVar(&amp;debug, "debug", false, "Enable debug logging to stderr")

        // MCP server flags
        mcpCmd.Flags().StringVar(&amp;dbURL, "db", "", "SQLite/Turso database path or URL (default: ./.morfx/db/morfx.db)")
        mcpCmd.Flags().BoolVar(&amp;autoApply, "auto-apply", true, "Enable auto-apply for high confidence operations")
        mcpCmd.Flags().
                Float64Var(&amp;autoApplyThreshold, "auto-threshold", 0.85, "Confidence threshold for auto-apply (0.0-1.0)")

        // Add commands to root
        rootCmd.AddCommand(mcpCmd)
}</span>

func main() <span class="cov0" title="0">{
        // Load .env file if it exists (fail silently if not found)
        _ = godotenv.Load()

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func runMCPServer(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Build configuration
        config := mcp.DefaultConfig()

        // Override with command line flags
        if dbURL != "" </span><span class="cov0" title="0">{
                config.DatabaseURL = dbURL
        }</span>
        <span class="cov0" title="0">config.Debug = debug
        config.AutoApplyEnabled = autoApply
        config.AutoApplyThreshold = autoApplyThreshold

        // Log startup info if debug enabled
        if debug </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[INFO] Starting Morfx MCP Server\n")
                fmt.Fprintf(os.Stderr, "[INFO] Database: %s\n", config.DatabaseURL)
                fmt.Fprintf(os.Stderr, "[INFO] Auto-apply: %v (threshold: %.2f)\n",
                        config.AutoApplyEnabled, config.AutoApplyThreshold)
        }</span>

        // Create server
        <span class="cov0" title="0">server, err := mcp.NewStdioServer(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to create server: %v\n", err)
                os.Exit(1)
        }</span>

        // Ensure cleanup
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := server.Close(); err != nil &amp;&amp; debug </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[WARN] Error during shutdown: %v\n", err)
                }</span>
        }()

        // Start server (blocks until shutdown)
        <span class="cov0" title="0">if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Server error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[INFO] Server shutdown complete\n")
        }</span>
}

// resetFlags resets all command-line flags to their default values
// Used primarily in tests to ensure clean state between test runs
func resetFlags() <span class="cov10" title="17">{
        debug = false
        dbURL = ""
        autoApply = true
        autoApplyThreshold = 0.85
}</span>

// setupTestEnvironment sets up a test environment for integration tests
func setupTestEnvironment(t *testing.T) string <span class="cov1" title="1">{
        // Create temporary directory for test database
        tmpDir := "/tmp/morfx-test-" + fmt.Sprintf("%d", os.Getpid())
        if err := os.MkdirAll(tmpDir, 0o755); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test directory: %v", err)
        }</span>
        <span class="cov1" title="1">return tmpDir</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "fmt"
        "os"
        "sync"
        "time"
)

// FileLock represents a file lock for concurrent access control
type FileLock struct {
        file   *os.File
        path   string
        locked bool
        mu     sync.Mutex
        cond   *sync.Cond
        refCnt int
}

// AtomicWriteConfig controls atomic writing behavior
type AtomicWriteConfig struct {
        UseFsync       bool          // Force fsync for durability
        LockTimeout    time.Duration // Max time to wait for file lock
        TempSuffix     string        // Suffix for temporary files
        BackupOriginal bool          // Create backup before writing
}

// DefaultAtomicConfig provides sensible defaults
func DefaultAtomicConfig() AtomicWriteConfig <span class="cov9" title="89">{
        return AtomicWriteConfig{
                UseFsync:       false, // Performance over safety by default
                LockTimeout:    5 * time.Second,
                TempSuffix:     ".morfx.tmp",
                BackupOriginal: true,
        }
}</span>

// AtomicWriter handles atomic file operations with locking
type AtomicWriter struct {
        config AtomicWriteConfig
        locks  map[string]*FileLock
        mu     sync.RWMutex
}

// NewAtomicWriter creates a new atomic writer
func NewAtomicWriter(config AtomicWriteConfig) *AtomicWriter <span class="cov10" title="97">{
        return &amp;AtomicWriter{
                config: config,
                locks:  make(map[string]*FileLock),
        }
}</span>

// WriteFile atomically writes content to file with optional locking
func (aw *AtomicWriter) WriteFile(path, content string) error <span class="cov8" title="42">{
        // Acquire exclusive lock
        if err := aw.acquireLock(path); err != nil </span><span class="cov5" title="8">{
                return fmt.Errorf("failed to acquire lock for %s: %w", path, err)
        }</span>
        <span class="cov7" title="34">defer aw.releaseLock(path)

        // Get original file info
        originalInfo, err := os.Stat(path)
        var fileMode os.FileMode = 0o644
        if err == nil </span><span class="cov6" title="15">{
                fileMode = originalInfo.Mode()
        }</span>

        // Create backup if requested and file exists
        <span class="cov7" title="34">var backupPath string
        if aw.config.BackupOriginal &amp;&amp; err == nil </span><span class="cov4" title="5">{
                backupPath = path + ".bak"
                if err := aw.createBackup(path, backupPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create backup: %w", err)
                }</span>
        }

        // Write to temporary file first
        <span class="cov7" title="34">tempPath := path + aw.config.TempSuffix
        tempFile, err := os.OpenFile(tempPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, fileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>

        // Write content
        <span class="cov7" title="34">_, err = tempFile.WriteString(content)
        if err != nil </span><span class="cov0" title="0">{
                tempFile.Close()
                os.Remove(tempPath)
                return fmt.Errorf("failed to write content: %w", err)
        }</span>

        // Force sync if requested
        <span class="cov7" title="34">if aw.config.UseFsync </span><span class="cov1" title="1">{
                if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                        tempFile.Close()
                        os.Remove(tempPath)
                        return fmt.Errorf("failed to sync: %w", err)
                }</span>
        }

        <span class="cov7" title="34">tempFile.Close()

        // Atomic rename (the critical atomic operation)
        if err := os.Rename(tempPath, path); err != nil </span><span class="cov1" title="1">{
                os.Remove(tempPath)
                return fmt.Errorf("failed to atomic rename: %w", err)
        }</span>

        <span class="cov7" title="33">return nil</span>
}

// acquireLock gets an exclusive file lock
func (aw *AtomicWriter) acquireLock(path string) error <span class="cov8" title="42">{
        lockPath := path + ".lock"

        aw.mu.Lock()
        lock, exists := aw.locks[path]
        if !exists </span><span class="cov8" title="42">{
                lock = &amp;FileLock{}
                aw.locks[path] = lock
        }</span>
        <span class="cov8" title="42">if lock.cond == nil </span><span class="cov8" title="42">{
                lock.cond = sync.NewCond(&amp;lock.mu)
        }</span>
        <span class="cov8" title="42">lock.path = lockPath
        lock.refCnt++
        aw.mu.Unlock()

        // Wait for in-process writers to finish
        lock.mu.Lock()
        for lock.locked </span><span class="cov0" title="0">{
                lock.cond.Wait()
        }</span>
        <span class="cov8" title="42">lock.mu.Unlock()

        deadline := time.Now().Add(aw.config.LockTimeout)
        for </span><span class="cov8" title="57">{
                lockFile, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0o644)
                if err == nil </span><span class="cov7" title="34">{
                        lock.mu.Lock()
                        lock.file = lockFile
                        lock.locked = true
                        lock.mu.Unlock()

                        // Write PID to lock file for debugging
                        fmt.Fprintf(lockFile, "%d\n", os.Getpid())
                        lockFile.Sync()

                        return nil
                }</span>

                <span class="cov7" title="23">if os.IsExist(err) </span><span class="cov6" title="18">{
                        if aw.isLockStale(lockPath) </span><span class="cov4" title="7">{
                                os.Remove(lockPath)
                                continue</span>
                        }
                        <span class="cov5" title="11">if time.Now().After(deadline) </span><span class="cov3" title="3">{
                                aw.decrementRefCount(path, lock)
                                return fmt.Errorf("timeout waiting for lock on %s", path)
                        }</span>
                        <span class="cov5" title="8">time.Sleep(100 * time.Millisecond)
                        continue</span>
                }

                <span class="cov4" title="5">aw.decrementRefCount(path, lock)
                return fmt.Errorf("failed to create lock file: %w", err)</span>
        }
}

// releaseLock releases the file lock
func (aw *AtomicWriter) releaseLock(path string) error <span class="cov8" title="36">{
        aw.mu.RLock()
        lock, exists := aw.locks[path]
        aw.mu.RUnlock()
        if !exists </span><span class="cov2" title="2">{
                return nil // Already released
        }</span>

        <span class="cov7" title="34">lock.mu.Lock()
        if lock.locked </span><span class="cov7" title="34">{
                lock.file.Close()
                os.Remove(lock.path)
                lock.locked = false
                lock.file = nil
                lock.cond.Broadcast()
        }</span>
        <span class="cov7" title="34">lock.refCnt--
        remove := lock.refCnt == 0
        lock.mu.Unlock()

        if remove </span><span class="cov7" title="34">{
                aw.mu.Lock()
                if l, ok := aw.locks[path]; ok </span><span class="cov7" title="34">{
                        l.mu.Lock()
                        if l.refCnt == 0 &amp;&amp; !l.locked </span><span class="cov7" title="34">{
                                delete(aw.locks, path)
                        }</span>
                        <span class="cov7" title="34">l.mu.Unlock()</span>
                }
                <span class="cov7" title="34">aw.mu.Unlock()</span>
        }
        <span class="cov7" title="34">return nil</span>
}

// isLockStale checks if a lock file is from a dead process (cross-platform)
func (aw *AtomicWriter) isLockStale(lockPath string) bool <span class="cov7" title="22">{
        content, err := os.ReadFile(lockPath)
        if err != nil </span><span class="cov1" title="1">{
                return true // Can't read, assume stale
        }</span>

        <span class="cov6" title="21">var pid int
        if _, err := fmt.Sscanf(string(content), "%d", &amp;pid); err != nil </span><span class="cov4" title="6">{
                return true // Invalid format, assume stale
        }</span>

        // Cross-platform process check
        <span class="cov6" title="15">return !isProcessAlive(pid)</span>
}

// createBackup creates a backup copy with timestamp
func (aw *AtomicWriter) createBackup(originalPath, backupPath string) error <span class="cov4" title="5">{
        info, err := os.Stat(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="5">content, err := os.ReadFile(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add timestamp to backup
        <span class="cov4" title="5">timestamp := time.Now().Format("20060102-150405")
        backupPath = fmt.Sprintf("%s.%s", backupPath, timestamp)

        perm := info.Mode().Perm()
        if perm == 0 </span><span class="cov0" title="0">{
                perm = 0o644
        }</span>

        <span class="cov4" title="5">if err := os.WriteFile(backupPath, content, perm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">return os.Chmod(backupPath, perm)</span>
}

// Cleanup removes all locks (call on shutdown)
func (aw *AtomicWriter) Cleanup() <span class="cov6" title="13">{
        aw.mu.RLock()
        paths := make([]string, 0, len(aw.locks))
        for path := range aw.locks </span><span class="cov0" title="0">{
                paths = append(paths, path)
        }</span>
        <span class="cov6" title="13">aw.mu.RUnlock()

        for _, path := range paths </span><span class="cov0" title="0">{
                aw.releaseLock(path)
        }</span>
}

// decrementRefCount adjusts the reference count when acquisition fails.
func (aw *AtomicWriter) decrementRefCount(path string, lock *FileLock) <span class="cov5" title="8">{
        lock.mu.Lock()
        if lock.refCnt &gt; 0 </span><span class="cov5" title="8">{
                lock.refCnt--
        }</span>
        <span class="cov5" title="8">remove := lock.refCnt == 0 &amp;&amp; !lock.locked
        lock.mu.Unlock()

        if remove </span><span class="cov5" title="8">{
                aw.mu.Lock()
                if l, ok := aw.locks[path]; ok </span><span class="cov5" title="8">{
                        l.mu.Lock()
                        if l.refCnt == 0 &amp;&amp; !l.locked </span><span class="cov5" title="8">{
                                delete(aw.locks, path)
                        }</span>
                        <span class="cov5" title="8">l.mu.Unlock()</span>
                }
                <span class="cov5" title="8">aw.mu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "strconv"
        "sync"
        "time"
)

// ProviderRegistry interface for provider lookup
type ProviderRegistry interface {
        Get(language string) (Provider, bool)
}

// Provider interface for language-specific operations
type Provider interface {
        Language() string
        Query(source string, query AgentQuery) QueryResult
        Transform(source string, op TransformOp) TransformResult
}

// FileProcessor handles file-based transformations using providers
type FileProcessor struct {
        walker        *FileWalker
        providers     ProviderRegistry
        workers       int
        atomicWriter  *AtomicWriter
        safetyEnabled bool
        txLogDir      string
}

// NewFileProcessor creates a new file processor
func NewFileProcessor(providerRegistry ProviderRegistry) *FileProcessor <span class="cov8" title="17">{
        atomicConfig := DefaultAtomicConfig()
        atomicConfig.UseFsync = false // Performance over safety by default
        atomicConfig.BackupOriginal = false

        atomicWriter := NewAtomicWriter(atomicConfig)
        workers := resolveWorkerCount(8)

        return &amp;FileProcessor{
                walker:        NewFileWalker(),
                providers:     providerRegistry,
                workers:       workers,
                atomicWriter:  atomicWriter,
                safetyEnabled: true,
                txLogDir:      ".morfx/transactions",
        }
}</span>

// NewFileProcessorWithSafety creates a processor with configurable safety settings
func NewFileProcessorWithSafety(
        providerRegistry ProviderRegistry,
        safetyEnabled bool,
        atomicConfig AtomicWriteConfig,
) *FileProcessor <span class="cov3" title="3">{
        if safetyEnabled </span><span class="cov1" title="1">{
                atomicConfig.BackupOriginal = false
        }</span>
        <span class="cov3" title="3">atomicWriter := NewAtomicWriter(atomicConfig)
        workers := resolveWorkerCount(8)

        return &amp;FileProcessor{
                walker:        NewFileWalker(),
                providers:     providerRegistry,
                workers:       workers,
                atomicWriter:  atomicWriter,
                safetyEnabled: safetyEnabled,
                txLogDir:      ".morfx/transactions",
        }</span>
}

// QueryFiles searches for code elements across multiple files
func (fp *FileProcessor) QueryFiles(ctx context.Context, scope FileScope, query AgentQuery) ([]FileMatch, error) <span class="cov2" title="2">{
        // Discover files
        results, err := fp.walker.Walk(ctx, scope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk files: %w", err)
        }</span>

        // Process files in parallel
        <span class="cov2" title="2">matches := make(chan []FileMatch, fp.workers)
        var wg sync.WaitGroup

        // Start workers
        for i := 0; i &lt; fp.workers; i++ </span><span class="cov7" title="16">{
                wg.Add(1)
                go fp.queryWorker(ctx, results, query, matches, &amp;wg)
        }</span>

        // Collect results
        <span class="cov2" title="2">var allMatches []FileMatch
        collectorDone := make(chan struct{})
        go func() </span><span class="cov2" title="2">{
                for fileMatches := range matches </span><span class="cov1" title="1">{
                        allMatches = append(allMatches, fileMatches...)
                }</span>
                <span class="cov2" title="2">close(collectorDone)</span>
        }()

        // Wait for completion
        <span class="cov2" title="2">wg.Wait()
        close(matches)
        &lt;-collectorDone // Wait for collector to finish

        return allMatches, nil</span>
}

// TransformFiles applies transformations across multiple files
func (fp *FileProcessor) TransformFiles(ctx context.Context, op FileTransformOp) (*FileTransformResult, error) <span class="cov5" title="7">{
        start := time.Now()

        // Start transaction if safety enabled
        var (
                txManager *TransactionManager
                tx        *TransactionLog
                txActive  bool
        )

        if fp.safetyEnabled &amp;&amp; !op.DryRun </span><span class="cov3" title="3">{
                txManager = NewTransactionManager(fp.txLogDir, fp.atomicWriter)
                var err error
                tx, err = txManager.BeginTransaction(fmt.Sprintf("Transform files: %s", op.TransformOp.Target.Type))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to begin transaction: %w", err)
                }</span>
                <span class="cov3" title="3">txActive = true

                // Ensure cleanup on any error
                defer func() </span><span class="cov3" title="3">{
                        if txActive &amp;&amp; txManager != nil </span><span class="cov2" title="2">{
                                txManager.RollbackTransaction()
                        }</span>
                }()
        }

        // Discover files
        <span class="cov5" title="7">walkResults, err := fp.walker.Walk(ctx, op.Scope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk files: %w", err)
        }</span>

        // Collect file paths
        <span class="cov5" title="7">var filePaths []WalkResult
        for result := range walkResults </span><span class="cov7" title="16">{
                if result.Error == nil </span><span class="cov7" title="16">{
                        filePaths = append(filePaths, result)
                }</span>
        }

        <span class="cov5" title="7">scanDuration := time.Since(start)
        transformStart := time.Now()

        // Process files in parallel
        resultChan := make(chan FileTransformDetail, len(filePaths))
        var wg sync.WaitGroup

        // Create semaphore for controlled parallelism
        semaphore := make(chan struct{}, fp.workers)

        for _, walkResult := range filePaths </span><span class="cov7" title="16">{
                wg.Add(1)
                go func(wr WalkResult) </span><span class="cov7" title="16">{
                        defer wg.Done()
                        semaphore &lt;- struct{}{}        // Acquire
                        defer func() </span><span class="cov7" title="16">{ &lt;-semaphore }</span>() // Release

                        <span class="cov7" title="16">detail := fp.transformFile(wr, op, tx, txManager)
                        resultChan &lt;- detail</span>
                }(walkResult)
        }

        // Collect results
        <span class="cov5" title="7">go func() </span><span class="cov5" title="7">{
                wg.Wait()
                close(resultChan)
        }</span>()

        <span class="cov5" title="7">var details []FileTransformDetail
        var totalMatches int
        var filesModified int
        var hasErrors bool

        for detail := range resultChan </span><span class="cov7" title="16">{
                details = append(details, detail)
                totalMatches += detail.MatchCount
                if detail.Modified </span><span class="cov7" title="13">{
                        filesModified++
                }</span>
                <span class="cov7" title="16">if detail.Error != "" </span><span class="cov2" title="2">{
                        hasErrors = true
                }</span>
        }

        <span class="cov5" title="7">transformDuration := time.Since(transformStart)

        // Handle transaction completion
        if fp.safetyEnabled &amp;&amp; !op.DryRun &amp;&amp; txManager != nil &amp;&amp; tx != nil </span><span class="cov3" title="3">{
                if hasErrors </span><span class="cov2" title="2">{
                        if err := txManager.RollbackTransaction(); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to rollback transaction: %w", err)
                        }</span>
                } else<span class="cov1" title="1"> {
                        if err := txManager.CommitTransaction(); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to commit transaction: %w", err)
                        }</span>
                        <span class="cov1" title="1">txActive = false
                        tx = nil</span> // Prevent rollback in defer
                }
        }

        // Calculate overall confidence
        <span class="cov5" title="7">overallConfidence := fp.calculateOverallConfidence(details)

        return &amp;FileTransformResult{
                FilesScanned:      len(filePaths),
                FilesModified:     filesModified,
                TotalMatches:      totalMatches,
                ScanDuration:      scanDuration.Milliseconds(),
                TransformDuration: transformDuration.Milliseconds(),
                Files:             details,
                Confidence:        overallConfidence,
                TransactionID: func() string </span><span class="cov5" title="7">{
                        if tx != nil </span><span class="cov2" title="2">{
                                return tx.ID
                        }</span>
                        <span class="cov4" title="5">return ""</span>
                }(),
        }, nil
}

// queryWorker processes files for queries in parallel
func (fp *FileProcessor) queryWorker(
        ctx context.Context,
        results &lt;-chan WalkResult,
        query AgentQuery,
        matches chan&lt;- []FileMatch,
        wg *sync.WaitGroup,
) <span class="cov7" title="16">{
        defer wg.Done()

        for </span><span class="cov8" title="18">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case result, ok := &lt;-results:<span class="cov8" title="18">
                        if !ok </span><span class="cov7" title="16">{
                                return
                        }</span>

                        <span class="cov2" title="2">if result.Error != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov2" title="2">fileMatches := fp.queryFile(result, query)
                        if len(fileMatches) &gt; 0 </span><span class="cov1" title="1">{
                                matches &lt;- fileMatches
                        }</span>
                }
        }
}

// queryFile searches for matches in a single file
func (fp *FileProcessor) queryFile(walkResult WalkResult, query AgentQuery) []FileMatch <span class="cov2" title="2">{
        // Read file content
        content, err := os.ReadFile(walkResult.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get provider for language
        <span class="cov2" title="2">provider, exists := fp.providers.Get(walkResult.Language)
        if !exists </span><span class="cov1" title="1">{
                return nil // Skip unsupported languages
        }</span>

        // Execute query
        <span class="cov1" title="1">result := provider.Query(string(content), query)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert to FileMatch
        <span class="cov1" title="1">var fileMatches []FileMatch
        for _, match := range result.Matches </span><span class="cov1" title="1">{
                fileMatch := FileMatch{
                        Match:    match,
                        FilePath: walkResult.Path,
                        FileSize: walkResult.Info.Size(),
                        ModTime:  walkResult.Info.ModTime().Unix(),
                        Language: walkResult.Language,
                }
                // Update location to include file
                fileMatch.Location.File = walkResult.Path
                fileMatches = append(fileMatches, fileMatch)
        }</span>

        <span class="cov1" title="1">return fileMatches</span>
}

// transformFile applies transformation to a single file

func (fp *FileProcessor) transformFile(
        walkResult WalkResult,
        op FileTransformOp,
        tx *TransactionLog,
        txManager *TransactionManager,
) FileTransformDetail <span class="cov7" title="16">{
        detail := FileTransformDetail{
                FilePath:     walkResult.Path,
                Language:     walkResult.Language,
                OriginalSize: walkResult.Info.Size(),
        }

        // Check if we can process this language
        provider, exists := fp.providers.Get(walkResult.Language)
        if !exists </span><span class="cov1" title="1">{
                detail.Error = fmt.Sprintf("no provider for language: %s", walkResult.Language)
                return detail
        }</span>

        // Read file content
        <span class="cov7" title="15">content, err := os.ReadFile(walkResult.Path)
        if err != nil </span><span class="cov0" title="0">{
                detail.Error = fmt.Sprintf("failed to read file: %v", err)
                return detail
        }</span>

        <span class="cov7" title="15">originalContent := string(content)

        // Apply transformation
        result := provider.Transform(originalContent, op.TransformOp)
        if result.Error != nil </span><span class="cov1" title="1">{
                detail.Error = fmt.Sprintf("transformation failed: %v", result.Error)
                return detail
        }</span>

        <span class="cov7" title="14">detail.MatchCount = result.MatchCount
        detail.Confidence = result.Confidence
        detail.Diff = result.Diff

        // Check if content actually changed
        if result.Modified == originalContent </span><span class="cov1" title="1">{
                return detail // No changes
        }</span>

        <span class="cov7" title="13">detail.Modified = true
        detail.ModifiedSize = int64(len(result.Modified))

        // Register operation in transaction if safety enabled
        if fp.safetyEnabled &amp;&amp; !op.DryRun &amp;&amp; tx != nil &amp;&amp; txManager != nil </span><span class="cov1" title="1">{
                txOp, err := txManager.AddOperation("modify", walkResult.Path)
                if err != nil </span><span class="cov0" title="0">{
                        detail.Error = fmt.Sprintf("failed to register transaction operation: %v", err)
                        return detail
                }</span>
                <span class="cov1" title="1">detail.BackupPath = txOp.BackupPath</span>
        } else<span class="cov7" title="12"> if op.Backup </span><span class="cov1" title="1">{
                // Create backup if requested (when not using transactions)
                backupPath := walkResult.Path + ".bak"
                if err := fp.createBackup(walkResult.Path, backupPath); err != nil </span><span class="cov0" title="0">{
                        detail.Error = fmt.Sprintf("failed to create backup: %v", err)
                        return detail
                }</span>
                <span class="cov1" title="1">detail.BackupPath = backupPath</span>
        }

        // Write modified content (unless dry run)
        <span class="cov7" title="13">if !op.DryRun </span><span class="cov2" title="2">{
                var writeErr error
                if fp.safetyEnabled </span><span class="cov1" title="1">{
                        // Use atomic writer with locking
                        writeErr = fp.atomicWriter.WriteFile(walkResult.Path, result.Modified)
                }</span> else<span class="cov1" title="1"> {
                        // Use simple write
                        writeErr = fp.writeFile(walkResult.Path, result.Modified)
                }</span>

                <span class="cov2" title="2">if writeErr != nil </span><span class="cov0" title="0">{
                        detail.Error = fmt.Sprintf("failed to write file: %v", writeErr)

                        // Mark operation as failed in transaction
                        if fp.safetyEnabled &amp;&amp; tx != nil &amp;&amp; txManager != nil </span><span class="cov0" title="0">{
                                txManager.CompleteOperation(walkResult.Path, writeErr)
                        }</span>
                        <span class="cov0" title="0">return detail</span>
                }

                // Mark operation as completed in transaction
                <span class="cov2" title="2">if fp.safetyEnabled &amp;&amp; tx != nil &amp;&amp; txManager != nil </span><span class="cov1" title="1">{
                        if err := txManager.CompleteOperation(walkResult.Path, nil); err != nil </span><span class="cov0" title="0">{
                                detail.Error = fmt.Sprintf("failed to complete transaction operation: %v", err)
                                return detail
                        }</span>
                }
        }

        <span class="cov7" title="13">return detail</span>
}

// createBackup creates a backup copy of the file
func (fp *FileProcessor) createBackup(originalPath, backupPath string) error <span class="cov1" title="1">{
        info, err := os.Stat(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">content, err := os.ReadFile(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">mode := info.Mode().Perm()
        if mode == 0 </span><span class="cov0" title="0">{
                mode = 0o644
        }</span>

        <span class="cov1" title="1">if err := os.WriteFile(backupPath, content, mode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return os.Chmod(backupPath, mode)</span>
}

// writeFile writes content to file with proper permissions
func (fp *FileProcessor) writeFile(path, content string) error <span class="cov1" title="1">{
        // Get original file info for permissions
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        if err := os.WriteFile(path, []byte(content), 0o644); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        // Write with original permissions
        <span class="cov1" title="1">perm := info.Mode().Perm()
        if perm == 0 </span><span class="cov0" title="0">{
                perm = 0o644
        }</span>
        <span class="cov1" title="1">if err := os.WriteFile(path, []byte(content), perm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return os.Chmod(path, perm)</span>
}

// calculateOverallConfidence computes aggregate confidence across all files
func (fp *FileProcessor) calculateOverallConfidence(details []FileTransformDetail) ConfidenceScore <span class="cov7" title="13">{
        if len(details) == 0 </span><span class="cov1" title="1">{
                return ConfidenceScore{Score: 0.0, Level: "low"}
        }</span>

        <span class="cov7" title="12">var totalScore float64
        var totalFiles int
        var hasErrors bool
        var hasLowConfidence bool

        for _, detail := range details </span><span class="cov10" title="38">{
                if detail.Error != "" </span><span class="cov3" title="3">{
                        hasErrors = true
                        continue</span>
                }

                <span class="cov9" title="35">if detail.Modified </span><span class="cov9" title="34">{
                        totalScore += detail.Confidence.Score
                        totalFiles++

                        if detail.Confidence.Score &lt; 0.7 </span><span class="cov2" title="2">{
                                hasLowConfidence = true
                        }</span>
                }
        }

        <span class="cov7" title="12">if totalFiles == 0 </span><span class="cov3" title="3">{
                return ConfidenceScore{Score: 0.0, Level: "low"}
        }</span>

        <span class="cov6" title="9">avgScore := totalScore / float64(totalFiles)

        // Adjust score based on aggregate factors
        factors := []ConfidenceFactor{}

        if hasErrors </span><span class="cov1" title="1">{
                avgScore -= 0.2
                factors = append(factors, ConfidenceFactor{
                        Name:   "file_errors",
                        Impact: -0.2,
                        Reason: "Some files had processing errors",
                })
        }</span>

        <span class="cov6" title="9">if hasLowConfidence </span><span class="cov2" title="2">{
                avgScore -= 0.1
                factors = append(factors, ConfidenceFactor{
                        Name:   "low_confidence_files",
                        Impact: -0.1,
                        Reason: "Some files had low confidence transformations",
                })
        }</span>

        <span class="cov6" title="9">if totalFiles &gt; 10 </span><span class="cov1" title="1">{
                avgScore -= 0.1
                factors = append(factors, ConfidenceFactor{
                        Name:   "batch_operation",
                        Impact: -0.1,
                        Reason: fmt.Sprintf("Large batch operation (%d files)", totalFiles),
                })
        }</span>

        // Clamp score
        <span class="cov6" title="9">if avgScore &lt; 0 </span><span class="cov0" title="0">{
                avgScore = 0
        }</span> else<span class="cov6" title="9"> if avgScore &gt; 1 </span><span class="cov0" title="0">{
                avgScore = 1
        }</span>

        // Determine level
        <span class="cov6" title="9">level := "high"
        if avgScore &lt; 0.8 </span><span class="cov3" title="3">{
                level = "medium"
        }</span>
        <span class="cov6" title="9">if avgScore &lt; 0.5 </span><span class="cov1" title="1">{
                level = "low"
        }</span>

        <span class="cov6" title="9">return ConfidenceScore{
                Score:   avgScore,
                Level:   level,
                Factors: factors,
        }</span>
}

// ValidateChanges verifies that all transformations are valid
func (fp *FileProcessor) ValidateChanges(details []FileTransformDetail) error <span class="cov4" title="4">{
        for _, detail := range details </span><span class="cov4" title="4">{
                if detail.Error != "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("file %s has error: %s", detail.FilePath, detail.Error)
                }</span>

                <span class="cov3" title="3">if detail.Modified &amp;&amp; detail.Confidence.Score &lt; 0.3 </span><span class="cov1" title="1">{
                        return fmt.Errorf("file %s has very low confidence: %.2f",
                                detail.FilePath, detail.Confidence.Score)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// GenerateChecksum creates SHA256 hash of file content for integrity checking
func (fp *FileProcessor) GenerateChecksum(filePath string) (string, error) <span class="cov3" title="3">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov2" title="2">hash := sha256.Sum256(content)
        return fmt.Sprintf("%x", hash), nil</span>
}

// EnableSafety enables/disables safety features at runtime
func (fp *FileProcessor) EnableSafety(enabled bool) <span class="cov3" title="3">{
        fp.safetyEnabled = enabled
}</span>

// IsSafetyEnabled returns current safety status
func (fp *FileProcessor) IsSafetyEnabled() bool <span class="cov4" title="4">{
        return fp.safetyEnabled
}</span>

// Cleanup releases all resources and locks
func (fp *FileProcessor) Cleanup() <span class="cov2" title="2">{
        if fp.atomicWriter != nil </span><span class="cov2" title="2">{
                fp.atomicWriter.Cleanup()
        }</span>
}

func resolveWorkerCount(defaultWorkers int) int <span class="cov8" title="20">{
        value := os.Getenv("MORFX_WORKERS")
        if value == "" </span><span class="cov8" title="20">{
                return defaultWorkers
        }</span>
        <span class="cov0" title="0">n, err := strconv.Atoi(value)
        if err != nil || n &lt;= 0 </span><span class="cov0" title="0">{
                return defaultWorkers
        }</span>
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "context"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync"

        "github.com/bmatcuk/doublestar/v4"
        "github.com/termfx/morfx/providers/catalog"
)

// FileWalker provides high-performance parallel file system traversal
type FileWalker struct {
        workers    int
        bufferSize int
}

// NewFileWalker creates a new file walker optimized for performance
func NewFileWalker() *FileWalker <span class="cov6" title="43">{
        return &amp;FileWalker{
                workers:    runtime.NumCPU() * 2, // 2x CPU cores for I/O bound work
                bufferSize: 1000,                 // Channel buffer size
        }
}</span>

// WalkResult represents a discovered file
type WalkResult struct {
        Path     string
        Info     fs.FileInfo
        Language string
        Error    error
}

// Walk performs parallel directory traversal with pattern matching
func (fw *FileWalker) Walk(ctx context.Context, scope FileScope) (&lt;-chan WalkResult, error) <span class="cov5" title="26">{
        // Validate scope
        if err := fw.validateScope(scope); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Create channels
        <span class="cov5" title="25">results := make(chan WalkResult, fw.bufferSize)
        paths := make(chan string, fw.bufferSize)

        // Start worker pool
        var wg sync.WaitGroup
        for i := 0; i &lt; fw.workers; i++ </span><span class="cov9" title="600">{
                wg.Add(1)
                go fw.worker(ctx, paths, results, scope, &amp;wg)
        }</span>

        // Start directory scanner in separate goroutine
        <span class="cov5" title="25">go func() </span><span class="cov5" title="25">{
                defer close(paths)
                processed := 0
                var visited map[string]struct{}
                if scope.FollowSymlinks </span><span class="cov1" title="1">{
                        visited = make(map[string]struct{})
                        if resolved, err := filepath.EvalSymlinks(scope.Path); err == nil </span><span class="cov1" title="1">{
                                visited[resolved] = struct{}{}
                        }</span> else<span class="cov0" title="0"> {
                                visited[scope.Path] = struct{}{}
                        }</span>
                }
                <span class="cov5" title="25">fw.scanDirectory(ctx, scope.Path, scope, paths, 0, &amp;processed, visited)</span>
        }()

        // Close results when all workers finish
        <span class="cov5" title="25">go func() </span><span class="cov5" title="25">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov5" title="25">return results, nil</span>
}

// worker processes file paths in parallel
func (fw *FileWalker) worker(
        ctx context.Context,
        paths &lt;-chan string,
        results chan&lt;- WalkResult,
        scope FileScope,
        wg *sync.WaitGroup,
) <span class="cov9" title="600">{
        defer wg.Done()

        for </span><span class="cov10" title="671">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov5" title="23">
                        return</span>
                case path, ok := &lt;-paths:<span class="cov9" title="648">
                        if !ok </span><span class="cov9" title="577">{
                                return
                        }</span>

                        // Process file
                        <span class="cov6" title="71">result := fw.processFile(path, scope)

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case results &lt;- result:<span class="cov6" title="71"></span>
                        }
                }
        }
}

// scanDirectory recursively discovers files matching patterns
func (fw *FileWalker) scanDirectory(
        ctx context.Context,
        dirPath string,
        scope FileScope,
        paths chan&lt;- string,
        depth int,
        processed *int,
        visited map[string]struct{},
) <span class="cov5" title="34">{
        if scope.MaxFiles &gt; 0 &amp;&amp; *processed &gt;= scope.MaxFiles </span><span class="cov0" title="0">{
                return
        }</span>
        // Check context cancellation
        <span class="cov5" title="34">select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return</span>
        default:<span class="cov5" title="33"></span>
        }

        // Check max depth
        <span class="cov5" title="33">if scope.MaxDepth &gt; 0 &amp;&amp; depth &gt; scope.MaxDepth </span><span class="cov1" title="1">{
                return
        }</span>

        // Read directory entries
        <span class="cov5" title="32">entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov1" title="2">{
                return // Skip directories we can't read
        }</span>

        <span class="cov5" title="30">for _, entry := range entries </span><span class="cov7" title="89">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov7" title="89"></span>
                }

                <span class="cov7" title="89">fullPath := filepath.Join(dirPath, entry.Name())

                // Skip excluded patterns
                if fw.isExcluded(fullPath, scope.Exclude) </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Handle symlinked directories when allowed
                <span class="cov7" title="88">if entry.Type()&amp;os.ModeSymlink != 0 &amp;&amp; scope.FollowSymlinks </span><span class="cov1" title="2">{
                        resolvedPath, err := filepath.EvalSymlinks(fullPath)
                        if err != nil || resolvedPath == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="2">info, err := os.Stat(resolvedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="2">if info.IsDir() </span><span class="cov1" title="2">{
                                if visited != nil </span><span class="cov1" title="2">{
                                        if _, seen := visited[resolvedPath]; seen </span><span class="cov1" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov1" title="1">visited[resolvedPath] = struct{}{}</span>
                                }
                                <span class="cov1" title="1">fw.scanDirectory(ctx, fullPath, scope, paths, depth+1, processed, visited)
                                continue</span>
                        }
                }

                <span class="cov7" title="86">if entry.IsDir() </span><span class="cov4" title="9">{
                        if visited != nil </span><span class="cov1" title="1">{
                                realPath := fullPath
                                if resolved, err := filepath.EvalSymlinks(fullPath); err == nil &amp;&amp; resolved != "" </span><span class="cov1" title="1">{
                                        realPath = resolved
                                }</span>
                                <span class="cov1" title="1">if _, seen := visited[realPath]; seen </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">visited[realPath] = struct{}{}</span>
                        }

                        // Recurse into subdirectory
                        <span class="cov3" title="8">fw.scanDirectory(ctx, fullPath, scope, paths, depth+1, processed, visited)
                        continue</span>
                }

                // Check if file matches include patterns
                <span class="cov7" title="77">if fw.isIncluded(fullPath, scope.Include) </span><span class="cov6" title="72">{
                        if scope.MaxFiles &gt; 0 &amp;&amp; *processed &gt;= scope.MaxFiles </span><span class="cov1" title="1">{
                                return
                        }</span>
                        <span class="cov6" title="71">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case paths &lt;- fullPath:<span class="cov6" title="71">
                                *processed++</span>
                        }
                }
        }
}

// processFile analyzes a single file and creates WalkResult
func (fw *FileWalker) processFile(path string, scope FileScope) WalkResult <span class="cov6" title="72">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov1" title="1">{
                return WalkResult{Path: path, Error: err}
        }</span>

        // Detect language
        <span class="cov6" title="71">language := scope.Language
        if language == "" </span><span class="cov6" title="53">{
                language = fw.detectLanguage(path)
        }</span>

        <span class="cov6" title="71">return WalkResult{
                Path:     path,
                Info:     info,
                Language: language,
        }</span>
}

// detectLanguage determines programming language from file extension
func (fw *FileWalker) detectLanguage(path string) string <span class="cov7" title="98">{
        ext := strings.ToLower(filepath.Ext(path))

        if info, ok := catalog.LookupByExtension(ext); ok </span><span class="cov0" title="0">{
                return info.ID
        }</span>

        <span class="cov7" title="98">languageMap := map[string]string{
                ".go":    "go",
                ".py":    "python",
                ".js":    "javascript",
                ".ts":    "typescript",
                ".jsx":   "javascript",
                ".tsx":   "typescript",
                ".mjs":   "javascript",
                ".cjs":   "javascript",
                ".java":  "java",
                ".cpp":   "cpp",
                ".c":     "c",
                ".h":     "c",
                ".hpp":   "cpp",
                ".cs":    "csharp",
                ".rb":    "ruby",
                ".php":   "php",
                ".phtml": "php",
                ".php4":  "php",
                ".php5":  "php",
                ".phps":  "php",
                ".rs":    "rust",
                ".kt":    "kotlin",
                ".swift": "swift",
                ".dart":  "dart",
                ".scala": "scala",
                ".clj":   "clojure",
                ".ml":    "ocaml",
                ".hs":    "haskell",
                ".elm":   "elm",
                ".ex":    "elixir",
                ".erl":   "erlang",
                ".pyw":   "python",
                ".pyi":   "python",
                ".d.ts":  "typescript",
        }

        if lang, exists := languageMap[ext]; exists </span><span class="cov7" title="88">{
                return lang
        }</span>

        <span class="cov4" title="10">return "unknown"</span>
}

// isIncluded checks if file matches include patterns
func (fw *FileWalker) isIncluded(path string, patterns []string) bool <span class="cov7" title="82">{
        if len(patterns) == 0 </span><span class="cov4" title="13">{
                return true // Include all if no patterns specified
        }</span>

        <span class="cov6" title="69">for _, pattern := range patterns </span><span class="cov6" title="76">{
                if fw.matchPattern(path, pattern) </span><span class="cov6" title="63">{
                        return true
                }</span>
        }
        <span class="cov3" title="6">return false</span>
}

// isExcluded checks if file matches exclude patterns
func (fw *FileWalker) isExcluded(path string, patterns []string) bool <span class="cov7" title="94">{
        for _, pattern := range patterns </span><span class="cov3" title="6">{
                if fw.matchPattern(path, pattern) </span><span class="cov2" title="3">{
                        return true
                }</span>
        }
        <span class="cov7" title="91">return false</span>
}

// matchPattern performs robust glob-style pattern matching with ** support
func (fw *FileWalker) matchPattern(path, pattern string) bool <span class="cov7" title="103">{
        // Direct match with doublestar
        if matched, err := doublestar.PathMatch(pattern, path); err == nil &amp;&amp; matched </span><span class="cov4" title="17">{
                return true
        }</span>

        // Try basename for simple patterns without path separators
        <span class="cov7" title="86">if !strings.Contains(pattern, "/") </span><span class="cov7" title="80">{
                basename := filepath.Base(path)
                if matched, err := doublestar.PathMatch(pattern, basename); err == nil &amp;&amp; matched </span><span class="cov6" title="63">{
                        return true
                }</span>
        }

        <span class="cov5" title="23">return false</span>
}

// validateScope validates FileScope parameters
func (fw *FileWalker) validateScope(scope FileScope) error <span class="cov5" title="29">{
        if scope.Path == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("path is required")
        }</span>

        // Check if path exists and is accessible
        <span class="cov5" title="28">info, err := os.Stat(scope.Path)
        if err != nil </span><span class="cov1" title="2">{
                return fmt.Errorf("cannot access path %s: %w", scope.Path, err)
        }</span>

        <span class="cov5" title="26">if !info.IsDir() </span><span class="cov1" title="1">{
                return fmt.Errorf("path %s is not a directory", scope.Path)
        }</span>

        <span class="cov5" title="25">return nil</span>
}

// FastScan performs ultra-fast file discovery without full stat() calls
func (fw *FileWalker) FastScan(ctx context.Context, scope FileScope) ([]string, error) <span class="cov2" title="3">{
        var files []string
        var mu sync.Mutex

        results, err := fw.Walk(ctx, scope)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="2">for result := range results </span><span class="cov3" title="6">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files with errors in fast scan
                }

                <span class="cov3" title="6">mu.Lock()
                files = append(files, result.Path)
                mu.Unlock()</span>
        }

        <span class="cov1" title="2">return files, nil</span>
}

// GetLanguageStats returns statistics about discovered files by language
func (fw *FileWalker) GetLanguageStats(ctx context.Context, scope FileScope) (map[string]int, error) <span class="cov2" title="4">{
        stats := make(map[string]int)
        var mu sync.Mutex

        results, err := fw.Walk(ctx, scope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="4">for result := range results </span><span class="cov4" title="14">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="14">mu.Lock()
                stats[result.Language]++
                mu.Unlock()</span>
        }

        <span class="cov2" title="4">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !windows

package core

import (
        "os"
        "syscall"
)

// isProcessAlive checks if a process with the given PID is alive on Unix-like systems
func isProcessAlive(pid int) bool <span class="cov10" title="19">{
        if pid &lt;= 0 </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov9" title="17">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send signal 0 to check if process exists without affecting it
        <span class="cov9" title="17">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// TransactionOperation represents a single operation in a transaction
type TransactionOperation struct {
        Type       string    `json:"type"` // "modify", "create", "delete"
        FilePath   string    `json:"file_path"`
        BackupPath string    `json:"backup_path"` // For rollback
        Checksum   string    `json:"checksum"`    // Original file checksum
        Timestamp  time.Time `json:"timestamp"`
        Completed  bool      `json:"completed"`
        Error      string    `json:"error,omitempty"`
}

// TransactionLog represents a complete transaction
type TransactionLog struct {
        ID          string                 `json:"id"`
        Started     time.Time              `json:"started"`
        Completed   time.Time              `json:"completed"`
        Operations  []TransactionOperation `json:"operations"`
        Status      string                 `json:"status"` // "pending", "committed", "rolled_back"
        Description string                 `json:"description"`
}

// TransactionManager handles transaction logging and rollback
type TransactionManager struct {
        logDir       string
        currentTx    *TransactionLog
        atomicWriter *AtomicWriter
        mu           sync.Mutex
}

// NewTransactionManager creates a new transaction manager
func NewTransactionManager(logDir string, atomicWriter *AtomicWriter) *TransactionManager <span class="cov8" title="42">{
        os.MkdirAll(logDir, 0o755)

        return &amp;TransactionManager{
                logDir:       logDir,
                atomicWriter: atomicWriter,
        }
}</span>

// BeginTransaction starts a new transaction
func (tm *TransactionManager) BeginTransaction(description string) (*TransactionLog, error) <span class="cov8" title="34">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        if tm.currentTx != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transaction already in progress: %s", tm.currentTx.ID)
        }</span>

        <span class="cov8" title="33">txID := fmt.Sprintf("tx_%d_%d", time.Now().Unix(), os.Getpid())

        tx := &amp;TransactionLog{
                ID:          txID,
                Started:     time.Now(),
                Operations:  make([]TransactionOperation, 0),
                Status:      "pending",
                Description: description,
        }

        tm.currentTx = tx

        // Write initial transaction log
        if err := tm.writeTransactionLog(tx); err != nil </span><span class="cov2" title="2">{
                tm.currentTx = nil
                return nil, fmt.Errorf("failed to write transaction log: %w", err)
        }</span>

        <span class="cov8" title="31">return tx, nil</span>
}

// AddOperation records a file operation in the current transaction
func (tm *TransactionManager) AddOperation(opType, filePath string) (*TransactionOperation, error) <span class="cov7" title="18">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        if tm.currentTx == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no active transaction")
        }</span>

        <span class="cov6" title="17">op := TransactionOperation{
                Type:      opType,
                FilePath:  filePath,
                Timestamp: time.Now(),
                Completed: false,
        }

        // Generate checksum for existing files
        if opType == "modify" || opType == "delete" </span><span class="cov6" title="15">{
                if _, err := os.Stat(filePath); err == nil </span><span class="cov6" title="13">{
                        checksum, err := generateFileChecksum(filePath)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to generate checksum: %w", err)
                        }</span>
                        <span class="cov6" title="12">op.Checksum = checksum

                        // Create backup for modify operations
                        if opType == "modify" </span><span class="cov5" title="10">{
                                backupPath := tm.generateBackupPath(filePath)
                                if err := tm.createBackup(filePath, backupPath); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to create backup: %w", err)
                                }</span>
                                <span class="cov5" title="10">op.BackupPath = backupPath</span>
                        }
                }
        }

        <span class="cov6" title="16">tm.currentTx.Operations = append(tm.currentTx.Operations, op)
        opPtr := &amp;tm.currentTx.Operations[len(tm.currentTx.Operations)-1]

        // Update transaction log
        if err := tm.writeTransactionLog(tm.currentTx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update transaction log: %w", err)
        }</span>

        <span class="cov6" title="16">return opPtr, nil</span>
}

// CompleteOperation marks an operation as completed
func (tm *TransactionManager) CompleteOperation(filePath string, err error) error <span class="cov6" title="14">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        if tm.currentTx == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("no active transaction")
        }</span>

        // Find the operation
        <span class="cov6" title="13">for i := range tm.currentTx.Operations </span><span class="cov6" title="11">{
                op := &amp;tm.currentTx.Operations[i]
                if op.FilePath == filePath &amp;&amp; !op.Completed </span><span class="cov5" title="10">{
                        op.Completed = true
                        if err != nil </span><span class="cov2" title="2">{
                                op.Error = err.Error()
                        }</span>

                        // Update transaction log
                        <span class="cov5" title="10">return tm.writeTransactionLog(tm.currentTx)</span>
                }
        }

        <span class="cov3" title="3">return fmt.Errorf("operation not found for file: %s", filePath)</span>
}

// CommitTransaction marks transaction as successfully completed
func (tm *TransactionManager) CommitTransaction() error <span class="cov5" title="8">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        if tm.currentTx == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("no active transaction")
        }</span>

        // Check if all operations completed successfully
        <span class="cov5" title="7">for _, op := range tm.currentTx.Operations </span><span class="cov3" title="4">{
                if !op.Completed || op.Error != "" </span><span class="cov2" title="2">{
                        return fmt.Errorf("cannot commit transaction with failed operations")
                }</span>
        }

        <span class="cov4" title="5">tm.currentTx.Status = "committed"
        tm.currentTx.Completed = time.Now()

        err := tm.writeTransactionLog(tm.currentTx)
        tm.currentTx = nil // Clear current transaction

        return err</span>
}

// RollbackTransaction reverts all operations in current transaction
func (tm *TransactionManager) RollbackTransaction() error <span class="cov5" title="10">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        if tm.currentTx == nil </span><span class="cov3" title="3">{
                return fmt.Errorf("no active transaction")
        }</span>

        <span class="cov5" title="7">var rollbackErrors []string

        // Process operations in reverse order
        for i := len(tm.currentTx.Operations) - 1; i &gt;= 0; i-- </span><span class="cov4" title="5">{
                op := tm.currentTx.Operations[i]

                if !op.Completed </span><span class="cov0" title="0">{
                        continue</span> // Skip incomplete operations
                }

                <span class="cov4" title="5">if err := tm.rollbackOperation(op); err != nil </span><span class="cov3" title="3">{
                        rollbackErrors = append(rollbackErrors,
                                fmt.Sprintf("failed to rollback %s: %v", op.FilePath, err))
                }</span>
        }

        <span class="cov5" title="7">tm.currentTx.Status = "rolled_back"
        tm.currentTx.Completed = time.Now()

        if err := tm.writeTransactionLog(tm.currentTx); err != nil </span><span class="cov0" title="0">{
                rollbackErrors = append(rollbackErrors,
                        fmt.Sprintf("failed to update transaction log: %v", err))
        }</span>

        <span class="cov5" title="7">tm.currentTx = nil // Clear current transaction

        if len(rollbackErrors) &gt; 0 </span><span class="cov3" title="3">{
                return fmt.Errorf("rollback completed with errors: %v", rollbackErrors)
        }</span>

        <span class="cov3" title="4">return nil</span>
}

// rollbackOperation reverts a single operation
func (tm *TransactionManager) rollbackOperation(op TransactionOperation) error <span class="cov4" title="6">{
        switch op.Type </span>{
        case "modify":<span class="cov3" title="3">
                // Restore from backup
                if op.BackupPath == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("no backup path for modify operation")
                }</span>

                <span class="cov2" title="2">if _, err := os.Stat(op.BackupPath); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("backup file not found: %s", op.BackupPath)
                }</span>

                <span class="cov1" title="1">content, err := os.ReadFile(op.BackupPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read backup: %w", err)
                }</span>

                <span class="cov1" title="1">return tm.atomicWriter.WriteFile(op.FilePath, string(content))</span>

        case "create":<span class="cov1" title="1">
                // Delete the created file
                if _, err := os.Stat(op.FilePath); err == nil </span><span class="cov1" title="1">{
                        return os.Remove(op.FilePath)
                }</span>
                <span class="cov0" title="0">return nil</span> // File doesn't exist, nothing to do

        case "delete":<span class="cov1" title="1">
                // Can't easily rollback delete without backup
                return fmt.Errorf("cannot rollback delete operation for %s", op.FilePath)</span>

        default:<span class="cov1" title="1">
                return fmt.Errorf("unknown operation type: %s", op.Type)</span>
        }
}

// LoadTransaction loads a transaction from log file
func (tm *TransactionManager) LoadTransaction(txID string) (*TransactionLog, error) <span class="cov5" title="10">{
        logPath := filepath.Join(tm.logDir, txID+".json")

        data, err := os.ReadFile(logPath)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to read transaction log: %w", err)
        }</span>

        <span class="cov5" title="8">var tx TransactionLog
        if err := json.Unmarshal(data, &amp;tx); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to parse transaction log: %w", err)
        }</span>

        <span class="cov4" title="5">return &amp;tx, nil</span>
}

// ListPendingTransactions returns all pending transactions
func (tm *TransactionManager) ListPendingTransactions() ([]TransactionLog, error) <span class="cov2" title="2">{
        files, err := os.ReadDir(tm.logDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">var pending []TransactionLog
        for _, file := range files </span><span class="cov3" title="3">{
                if !file.IsDir() &amp;&amp; filepath.Ext(file.Name()) == ".json" </span><span class="cov3" title="3">{
                        txID := file.Name()[:len(file.Name())-5] // Remove .json
                        tx, err := tm.LoadTransaction(txID)
                        if err != nil </span><span class="cov1" title="1">{
                                continue</span> // Skip corrupted logs
                        }

                        <span class="cov2" title="2">if tx.Status == "pending" </span><span class="cov2" title="2">{
                                pending = append(pending, *tx)
                        }</span>
                }
        }

        <span class="cov2" title="2">return pending, nil</span>
}

// CleanupOldTransactions removes old completed transaction logs
func (tm *TransactionManager) CleanupOldTransactions(olderThan time.Duration) error <span class="cov3" title="3">{
        cutoff := time.Now().Add(-olderThan)

        files, err := os.ReadDir(tm.logDir)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov2" title="2">for _, file := range files </span><span class="cov3" title="3">{
                if !file.IsDir() &amp;&amp; filepath.Ext(file.Name()) == ".json" </span><span class="cov3" title="3">{
                        txID := file.Name()[:len(file.Name())-5]
                        tx, err := tm.LoadTransaction(txID)
                        if err != nil </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        // Remove completed transactions older than cutoff
                        <span class="cov2" title="2">if tx.Status != "pending" &amp;&amp; tx.Completed.Before(cutoff) </span><span class="cov2" title="2">{
                                logPath := filepath.Join(tm.logDir, file.Name())
                                os.Remove(logPath)

                                // Also remove backup files for this transaction
                                for _, op := range tx.Operations </span><span class="cov0" title="0">{
                                        if op.BackupPath != "" </span><span class="cov0" title="0">{
                                                os.Remove(op.BackupPath)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov2" title="2">return nil</span>
}

// writeTransactionLog writes transaction to disk
func (tm *TransactionManager) writeTransactionLog(tx *TransactionLog) error <span class="cov10" title="71">{
        data, err := json.MarshalIndent(tx, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="71">logPath := filepath.Join(tm.logDir, tx.ID+".json")
        return os.WriteFile(logPath, data, 0o644)</span>
}

// generateBackupPath creates a unique backup path
func (tm *TransactionManager) generateBackupPath(filePath string) string <span class="cov6" title="12">{
        timestamp := time.Now().Format("20060102-150405")
        txID := "unknown"
        if tm.currentTx != nil </span><span class="cov6" title="11">{
                txID = tm.currentTx.ID
        }</span>

        <span class="cov6" title="12">dir := filepath.Dir(filePath)
        name := filepath.Base(filePath)

        return filepath.Join(dir, fmt.Sprintf(".morfx-backup-%s-%s-%s",
                name, txID, timestamp))</span>
}

// createBackup creates a backup file
func (tm *TransactionManager) createBackup(originalPath, backupPath string) error <span class="cov5" title="10">{
        info, err := os.Stat(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="10">content, err := os.ReadFile(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="10">mode := info.Mode().Perm()
        if mode == 0 </span><span class="cov0" title="0">{
                mode = 0o644
        }</span>

        <span class="cov5" title="10">if err := os.WriteFile(backupPath, content, mode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="10">return os.Chmod(backupPath, mode)</span>
}

// generateFileChecksum creates SHA256 hash of file content
func generateFileChecksum(filePath string) (string, error) <span class="cov6" title="17">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov2" title="2">{
                return "", err
        }</span>

        <span class="cov6" title="15">hash := sha256.Sum256(content)
        return fmt.Sprintf("%x", hash), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package db

import (
        "database/sql"
        "database/sql/driver"
        "fmt"
        "os"
        "path/filepath"

        libsql "github.com/tursodatabase/libsql-client-go/libsql"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "github.com/termfx/morfx/models"
)

// Connect establishes a database connection and runs migrations
func Connect(dsn string, debug bool) (*gorm.DB, error) <span class="cov7" title="19">{
        // Ensure directory exists for file-based SQLite
        if !isURL(dsn) </span><span class="cov7" title="16">{
                dir := filepath.Dir(dsn)
                if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("failed to create database directory: %w", err)
                }</span>
        }

        <span class="cov7" title="17">config := &amp;gorm.Config{}

        // Enable debug logging if requested
        if debug </span><span class="cov3" title="3">{
                config.Logger = logger.Default.LogMode(logger.Info)
        }</span>

        <span class="cov7" title="17">var (
                dialector gorm.Dialector
                conn      *sql.DB
        )
        if isURL(dsn) </span><span class="cov3" title="3">{
                var (
                        connector driver.Connector
                        err       error
                )

                token := os.Getenv("MORFX_LIBSQL_AUTH_TOKEN")
                if token != "" </span><span class="cov0" title="0">{
                        connector, err = libsql.NewConnector(dsn, libsql.WithAuthToken(token))
                }</span> else<span class="cov3" title="3"> {
                        connector, err = libsql.NewConnector(dsn)
                }</span>
                <span class="cov3" title="3">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create libsql connector: %w", err)
                }</span>

                <span class="cov3" title="3">conn = sql.OpenDB(connector)
                dialector = sqlite.New(sqlite.Config{
                        DriverName: "libsql",
                        Conn:       conn,
                        DSN:        dsn,
                })</span>
        } else<span class="cov6" title="14"> {
                dialector = sqlite.Open(dsn)
        }</span>

        <span class="cov7" title="17">db, err := gorm.Open(dialector, config)
        if err != nil </span><span class="cov3" title="3">{
                if conn != nil </span><span class="cov3" title="3">{
                        conn.Close()
                }</span>
                <span class="cov3" title="3">return nil, fmt.Errorf("failed to connect: %w", err)</span>
        }

        // Enable foreign keys for SQLite
        <span class="cov6" title="14">if sqlDB, err := db.DB(); err == nil </span><span class="cov6" title="14">{
                sqlDB.Exec("PRAGMA foreign_keys = ON")
        }</span>

        // Run migrations
        <span class="cov6" title="14">if err := Migrate(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migration failed: %w", err)
        }</span>

        <span class="cov6" title="14">return db, nil</span>
}

// isURL checks if the DSN is a URL (for Turso) or file path
func isURL(dsn string) bool <span class="cov10" title="55">{
        return len(dsn) &gt; 7 &amp;&amp; (dsn[:7] == "http://" || dsn[:8] == "https://" || dsn[:6] == "libsql")
}</span>

// Migrate runs database migrations
func Migrate(db *gorm.DB) error <span class="cov7" title="16">{
        return db.AutoMigrate(
                &amp;models.Stage{},
                &amp;models.Apply{},
                &amp;models.Session{},
        )
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/fatih/color"
        "github.com/spf13/cobra"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/providers/golang"
        "github.com/termfx/morfx/providers/javascript"
        "github.com/termfx/morfx/providers/php"
        "github.com/termfx/morfx/providers/typescript"
)

var (
        green  = color.New(color.FgGreen).SprintFunc()
        yellow = color.New(color.FgYellow).SprintFunc()
        blue   = color.New(color.FgBlue).SprintFunc()
        red    = color.New(color.FgRed).SprintFunc()
        bold   = color.New(color.Bold).SprintFunc()
        cyan   = color.New(color.FgCyan).SprintFunc()
)

type DemoRunner struct {
        workDir     string
        backupDir   string
        fixturesDir string
        providers   map[string]any // provider instances
}

func NewDemoRunner() *DemoRunner <span class="cov0" title="0">{
        wd, _ := os.Getwd()
        return &amp;DemoRunner{
                workDir:     filepath.Join(wd, "demo"),
                backupDir:   filepath.Join(wd, "demo", ".demo-backup"),
                fixturesDir: filepath.Join(wd, "demo", "fixtures"),
                providers: map[string]any{
                        "go":         golang.New(),
                        "php":        php.New(),
                        "javascript": javascript.New(),
                        "typescript": typescript.New(),
                },
        }
}</span>

func (d *DemoRunner) CreateBackup() error <span class="cov0" title="0">{
        fmt.Printf("%s Creating backup...\n", yellow("📦"))
        os.RemoveAll(d.backupDir)

        if err := os.MkdirAll(d.backupDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup dir: %w", err)
        }</span>

        <span class="cov0" title="0">return copyDir(d.fixturesDir, d.backupDir)</span>
}

func (d *DemoRunner) RestoreBackup() error <span class="cov0" title="0">{
        fmt.Printf("%s Restoring original files...\n", blue("🔄"))
        os.RemoveAll(d.fixturesDir)
        return copyDir(d.backupDir, d.fixturesDir)
}</span>

func (d *DemoRunner) RunDemo(scenario string) error <span class="cov0" title="0">{
        fmt.Printf("%s %s\n", bold("🚀"), bold("Morfx AST Transformation Demo"))
        fmt.Println(strings.Repeat("═", 60))

        if err := d.CreateBackup(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("backup failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                d.RestoreBackup()
                fmt.Printf("%s Demo completed - files restored\n", green("✅"))
        }</span>()

        <span class="cov0" title="0">scenarios := d.getScenarios()

        // Run specific scenario or all
        if scenario != "" &amp;&amp; scenario != "all" </span><span class="cov0" title="0">{
                if s, exists := scenarios[scenario]; exists </span><span class="cov0" title="0">{
                        return d.runScenario(scenario, s)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("scenario %q not found", scenario)</span>
        }

        // Run all scenarios in order
        <span class="cov0" title="0">order := []string{"go-query", "php-replace", "js-insert", "ts-delete"}
        for _, name := range order </span><span class="cov0" title="0">{
                if s, exists := scenarios[name]; exists </span><span class="cov0" title="0">{
                        if err := d.runScenario(name, s); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("%s Error: %v\n", red("❌"), err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        time.Sleep(1 * time.Second)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *DemoRunner) runScenario(_ string, scenario Scenario) error <span class="cov0" title="0">{
        fmt.Printf("\n%s %s\n", cyan("▶"), bold(scenario.Description))
        fmt.Println(strings.Repeat("─", 60))

        // Show before state
        fmt.Printf("\n%s Before:\n", blue("📄"))
        beforeContent, err := os.ReadFile(scenario.File)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading file: %w", err)
        }</span>
        <span class="cov0" title="0">d.showFileContent(scenario.File, 10)

        // Execute the transformation
        fmt.Printf("\n%s Executing transformation...\n", yellow("⚡"))

        result, err := d.executeTransformation(scenario, string(beforeContent))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transformation failed: %w", err)
        }</span>

        // Show results based on operation type
        <span class="cov0" title="0">switch scenario.Operation </span>{
        case "query":<span class="cov0" title="0">
                d.showQueryResults(result)</span>

        case "replace", "delete", "insert_after", "insert_before", "append":<span class="cov0" title="0">
                // Write the modified content back
                if modified, ok := result["modified"].(string); ok </span><span class="cov0" title="0">{
                        if err := os.WriteFile(scenario.File, []byte(modified), 0o644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("writing file: %w", err)
                        }</span>

                        // Show diff
                        <span class="cov0" title="0">d.showDiff(string(beforeContent), modified)

                        // Show after state
                        fmt.Printf("\n%s After:\n", green("📝"))
                        d.showFileContent(scenario.File, 10)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *DemoRunner) executeTransformation(scenario Scenario, source string) (map[string]any, error) <span class="cov0" title="0">{
        provider := d.providers[scenario.Language]
        if provider == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no provider for language %s", scenario.Language)
        }</span>

        <span class="cov0" title="0">switch scenario.Operation </span>{
        case "query":<span class="cov0" title="0">
                if p, ok := provider.(interface {
                        Query(string, core.AgentQuery) core.QueryResult
                }); ok </span><span class="cov0" title="0">{
                        result := p.Query(source, scenario.Query)
                        return map[string]any{
                                "matches": result.Matches,
                                "error":   result.Error,
                        }, nil
                }</span>

        case "replace", "delete", "insert_after", "insert_before", "append":<span class="cov0" title="0">
                if p, ok := provider.(interface {
                        Transform(string, core.TransformOp) core.TransformResult
                }); ok </span><span class="cov0" title="0">{
                        op := core.TransformOp{
                                Method:      scenario.Operation,
                                Target:      scenario.Query,
                                Replacement: scenario.Replacement,
                                Content:     scenario.Content,
                        }
                        result := p.Transform(source, op)
                        if result.Error != nil </span><span class="cov0" title="0">{
                                return nil, result.Error
                        }</span>
                        <span class="cov0" title="0">return map[string]any{
                                "modified":   result.Modified,
                                "confidence": result.Confidence,
                        }, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("operation %s not supported", scenario.Operation)</span>
}

func (d *DemoRunner) showQueryResults(result map[string]any) <span class="cov0" title="0">{
        fmt.Printf("\n%s Results:\n", green("🔍"))

        if matches, ok := result["matches"].([]core.Match); ok </span><span class="cov0" title="0">{
                if len(matches) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  %s No matches found\n", yellow("→"))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  %s Found %d matches:\n", green("✓"), len(matches))
                        for i, m := range matches </span><span class="cov0" title="0">{
                                fmt.Printf("  %d. %s '%s' at line %d\n",
                                        i+1, m.Type, m.Name, m.Location.Line+1)
                                // Show first few lines of content
                                lines := strings.Split(m.Content, "\n")
                                for j, line := range lines </span><span class="cov0" title="0">{
                                        if j &gt;= 3 </span><span class="cov0" title="0">{
                                                fmt.Printf("     %s\n", yellow("..."))
                                                break</span>
                                        }
                                        <span class="cov0" title="0">fmt.Printf("     %s\n", strings.TrimSpace(line))</span>
                                }
                        }
                }
        }
}

func (d *DemoRunner) showDiff(before, after string) <span class="cov0" title="0">{
        fmt.Printf("\n%s Changes:\n", green("📝"))

        beforeLines := strings.Split(before, "\n")
        afterLines := strings.Split(after, "\n")

        // Simple diff - just show a few changed lines
        changed := false
        for i := 0; i &lt; len(beforeLines) &amp;&amp; i &lt; len(afterLines); i++ </span><span class="cov0" title="0">{
                if beforeLines[i] != afterLines[i] </span><span class="cov0" title="0">{
                        if !changed </span><span class="cov0" title="0">{
                                changed = true
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s\n", beforeLines[i-1])
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  %s\n", red("- "+beforeLines[i]))
                        fmt.Printf("  %s\n", green("+ "+afterLines[i]))
                        if i+1 &lt; len(beforeLines) </span><span class="cov0" title="0">{
                                fmt.Printf("  %s\n", beforeLines[i+1])
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                fmt.Printf("  %s No visible changes\n", yellow("→"))
        }</span>
}

type Scenario struct {
        Description string
        File        string
        Language    string
        Operation   string // query, replace, delete, insert_after, etc.
        Query       core.AgentQuery
        Replacement string // for replace
        Content     string // for insert operations
        Command     string // display only
}

func (d *DemoRunner) getScenarios() map[string]Scenario <span class="cov0" title="0">{
        return map[string]Scenario{
                "go-query": {
                        Description: "Go: Query functions with 'User' in name",
                        File:        filepath.Join(d.fixturesDir, "example.go"),
                        Language:    "go",
                        Operation:   "query",
                        Query: core.AgentQuery{
                                Type: "function",
                                Name: "*User*",
                        },
                        Command: "morfx:query",
                },
                "php-replace": {
                        Description: "PHP: Replace updateEmail method with validation",
                        File:        filepath.Join(d.fixturesDir, "example.php"),
                        Language:    "php",
                        Operation:   "replace",
                        Query: core.AgentQuery{
                                Type: "method",
                                Name: "updateEmail",
                        },
                        Replacement: `    public function updateEmail($newEmail) {
        if (!filter_var($newEmail, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException("Invalid email format");
        }
        $this-&gt;email = $newEmail;
        $this-&gt;updatedAt = new DateTime();
        return $this;
    }`,
                        Command: "morfx:replace",
                },
                "js-insert": {
                        Description: "JavaScript: Insert phone validation after email validation",
                        File:        filepath.Join(d.fixturesDir, "example.js"),
                        Language:    "javascript",
                        Operation:   "insert_after",
                        Query: core.AgentQuery{
                                Type: "function",
                                Name: "validateEmail",
                        },
                        Content: `
function validatePhone(phone) {
    const phoneRegex = /^\+?[\d\s\-\(\)]+$/;
    return phoneRegex.test(phone) &amp;&amp; phone.length &gt;= 10;
}`,
                        Command: "morfx:insert_after",
                },
                "ts-delete": {
                        Description: "TypeScript: Delete createUser function",
                        File:        filepath.Join(d.fixturesDir, "example.ts"),
                        Language:    "typescript",
                        Operation:   "delete",
                        Query: core.AgentQuery{
                                Type: "function",
                                Name: "createUser",
                        },
                        Command: "morfx:delete",
                },
        }
}</span>

func (d *DemoRunner) showFileContent(file string, lines int) <span class="cov0" title="0">{
        content, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  %s Error reading %s: %v\n", red("✗"), file, err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("  %s %s (%d bytes)\n", yellow("→"), filepath.Base(file), len(content))

        fileLines := strings.Split(string(content), "\n")
        for i, line := range fileLines </span><span class="cov0" title="0">{
                if i &gt;= lines </span><span class="cov0" title="0">{
                        fmt.Printf("  %s ... (%d more lines)\n", yellow("→"), len(fileLines)-i)
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("  %2d | %s\n", i+1, line)</span>
        }
}

// Helper functions
func copyDir(src, dst string) error <span class="cov0" title="0">{
        return filepath.Walk(src, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(src, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dstPath := filepath.Join(dst, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        return os.MkdirAll(dstPath, info.Mode())
                }</span>

                <span class="cov0" title="0">return copyFile(path, dstPath)</span>
        })
}

func copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        _, err = io.Copy(destFile, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sourceInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.Chmod(dst, sourceInfo.Mode())</span>
}

func main() <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "demo",
                Short: "Morfx AST transformation demo",
                Long:  "Interactive demonstration of Morfx capabilities with real code transformations",
        }

        runCmd := &amp;cobra.Command{
                Use:   "run [scenario]",
                Short: "Run demo scenarios",
                Long:  "Run transformation demo scenarios. Leave empty for all scenarios.",
                Args:  cobra.MaximumNArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        scenario := ""
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                scenario = args[0]
                        }</span>

                        <span class="cov0" title="0">runner := NewDemoRunner()
                        if err := runner.RunDemo(scenario); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("%s %v\n", red("Error:"), err)
                                os.Exit(1)
                        }</span>
                },
        }

        <span class="cov0" title="0">listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List available scenarios",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        runner := NewDemoRunner()
                        scenarios := runner.getScenarios()

                        fmt.Printf("\n%s Available Demo Scenarios\n", bold("📚"))
                        fmt.Println(strings.Repeat("═", 60))

                        for name, scenario := range scenarios </span><span class="cov0" title="0">{
                                fmt.Printf("\n%s %s\n", cyan("•"), bold(name))
                                fmt.Printf("  %s\n", scenario.Description)
                                fmt.Printf("  Language: %s\n", scenario.Language)
                                fmt.Printf("  Operation: %s\n", scenario.Operation)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                },
        }

        <span class="cov0" title="0">rootCmd.AddCommand(runCmd, listCmd)

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "log"
)

// User represents a user in the system
type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

// Database interface for data operations
type Database interface {
        GetUser(id int) (*User, error)
        SaveUser(user *User) error
}

const (
        DefaultPort = 8080
        APIVersion  = "v1"
)

var (
        globalConfig map[string]string
        userCache    []*User
)

// NewUser creates a new user instance
func NewUser(name, email string) *User <span class="cov0" title="0">{
        return &amp;User{
                Name:  name,
                Email: email,
        }
}</span>

// GetUserByID retrieves a user by ID
func GetUserByID(id int) (*User, error) <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %d", id)
        }</span>

        // Simulate database lookup
        <span class="cov0" title="0">for _, user := range userCache </span><span class="cov0" title="0">{
                if user.ID == id </span><span class="cov0" title="0">{
                        return user, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("user not found: %d", id)</span>
}

// UpdateUserEmail updates a user's email address with validation
func UpdateUserEmail(userID int, newEmail string) error <span class="cov0" title="0">{
        // Validate email first
        if !ValidateEmail(newEmail) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid email format: %s", newEmail)
        }</span>

        <span class="cov0" title="0">user, err := GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">oldEmail := user.Email
        user.Email = newEmail
        log.Printf("Updated email for user %d from %s to %s", userID, oldEmail, newEmail)
        return nil</span>
}

// ValidateEmail checks if an email is valid
func ValidateEmail(email string) bool <span class="cov0" title="0">{
        return len(email) &gt; 0 &amp;&amp; contains(email, "@")
}</span>

// contains is a helper function
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr)
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("Testing Go provider transformations")

        user := NewUser("Test User", "test@example.com")
        fmt.Printf("Created user: %+v\n", user)

        if ValidateEmail(user.Email) </span><span class="cov0" title="0">{
                fmt.Println("Email is valid")
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package mcp

import (
        "context"
        "fmt"
        "os"
        "sync"
        "time"

        "gorm.io/gorm"

        "github.com/termfx/morfx/models"
)

// AsyncStagingManager handles staging with goroutine pool
type AsyncStagingManager struct {
        *StagingManager

        // Worker pool
        workers    int
        stageChan  chan stageRequest
        resultChan chan stageResult
        wg         sync.WaitGroup
        ctx        context.Context
        cancel     context.CancelFunc
        closeOnce  sync.Once
}

// NewAsyncStagingManager creates concurrent staging manager
func NewAsyncStagingManager(db *gorm.DB, config Config) *AsyncStagingManager <span class="cov3" title="3">{
        ctx, cancel := context.WithCancel(context.Background())

        asm := &amp;AsyncStagingManager{
                StagingManager: NewStagingManager(db, config),
                workers:        10, // DB connection pool size
                stageChan:      make(chan stageRequest, 100),
                resultChan:     make(chan stageResult, 100),
                ctx:            ctx,
                cancel:         cancel,
        }

        // Start worker pool
        for i := 0; i &lt; asm.workers; i++ </span><span class="cov9" title="30">{
                asm.wg.Add(1)
                go asm.stageWorker()
        }</span>

        // Result collector
        <span class="cov3" title="3">go asm.resultCollector()

        return asm</span>
}

type stageRequest struct {
        ctx      context.Context
        stage    *models.Stage
        callback chan&lt;- error
}

type stageResult struct {
        stageID string
        err     error
        latency time.Duration
}

// CreateStageAsync stages transformation without blocking

func (asm *AsyncStagingManager) CreateStageAsync(stage *models.Stage) &lt;-chan error <span class="cov1" title="1">{
        return asm.CreateStageAsyncWithContext(context.Background(), stage)
}</span>

// CreateStageAsyncWithContext stages transformation without blocking, honoring cancellation.
func (asm *AsyncStagingManager) CreateStageAsyncWithContext(ctx context.Context, stage *models.Stage) &lt;-chan error <span class="cov2" title="2">{
        callback := make(chan error, 1)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // Check if context is done (manager closed)
        <span class="cov2" title="2">select </span>{
        case &lt;-asm.ctx.Done():<span class="cov0" title="0">
                // Manager is closed, fallback to sync
                go func() </span><span class="cov0" title="0">{
                        callback &lt;- asm.CreateStage(ctx, stage)
                        close(callback)
                }</span>()
                <span class="cov0" title="0">return callback</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                go func() </span><span class="cov1" title="1">{
                        callback &lt;- ctx.Err()
                        close(callback)
                }</span>()
                <span class="cov1" title="1">return callback</span>
        default:<span class="cov1" title="1"></span>
                // Continue with normal operation
        }

        <span class="cov1" title="1">select </span>{
        case asm.stageChan &lt;- stageRequest{ctx: ctx, stage: stage, callback: callback}:<span class="cov1" title="1"></span>
                // Queued successfully
        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                // Queue full, fallback to sync
                go func() </span><span class="cov0" title="0">{
                        callback &lt;- asm.CreateStage(ctx, stage)
                        close(callback)
                }</span>()
        default:<span class="cov0" title="0">
                // Channel might be closed, fallback to sync
                go func() </span><span class="cov0" title="0">{
                        callback &lt;- asm.CreateStage(ctx, stage)
                        close(callback)
                }</span>()
        }

        <span class="cov1" title="1">return callback</span>
}

// stageWorker processes staging requests
func (asm *AsyncStagingManager) stageWorker() <span class="cov9" title="30">{
        defer asm.wg.Done()

        for </span><span class="cov10" title="31">{
                select </span>{
                case &lt;-asm.ctx.Done():<span class="cov9" title="30">
                        return</span>

                case req, ok := &lt;-asm.stageChan:<span class="cov1" title="1">
                        // Check if channel was closed
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Validate request
                        <span class="cov1" title="1">if req.stage == nil </span><span class="cov0" title="0">{
                                if req.callback != nil </span><span class="cov0" title="0">{
                                        req.callback &lt;- fmt.Errorf("stage cannot be nil")
                                        close(req.callback)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov1" title="1">reqCtx := req.ctx
                        if reqCtx == nil </span><span class="cov0" title="0">{
                                reqCtx = context.Background()
                        }</span>

                        <span class="cov1" title="1">if err := reqCtx.Err(); err != nil </span><span class="cov0" title="0">{
                                if req.callback != nil </span><span class="cov0" title="0">{
                                        req.callback &lt;- err
                                        close(req.callback)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov1" title="1">start := time.Now()
                        err := asm.CreateStage(reqCtx, req.stage)
                        if err == nil </span><span class="cov1" title="1">{
                                err = reqCtx.Err()
                        }</span>

                        // Send result
                        <span class="cov1" title="1">req.callback &lt;- err
                        close(req.callback)

                        // Track metrics
                        asm.resultChan &lt;- stageResult{
                                stageID: req.stage.ID,
                                err:     err,
                                latency: time.Since(start),
                        }</span>
                }
        }
}

// resultCollector aggregates metrics
func (asm *AsyncStagingManager) resultCollector() <span class="cov3" title="3">{
        var (
                totalStages  int64
                totalLatency time.Duration
                errorCount   int64
                maxLatency   time.Duration
        )

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov4" title="4">{
                select </span>{
                case &lt;-asm.ctx.Done():<span class="cov3" title="3">
                        return</span>

                case result, ok := &lt;-asm.resultChan:<span class="cov1" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov1" title="1">totalStages++
                        totalLatency += result.latency

                        if result.err != nil </span><span class="cov0" title="0">{
                                errorCount++
                        }</span>

                        <span class="cov1" title="1">if result.latency &gt; maxLatency </span><span class="cov1" title="1">{
                                maxLatency = result.latency
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if totalStages &gt; 0 </span><span class="cov0" title="0">{
                                avgLatency := totalLatency / time.Duration(totalStages)
                                asm.debugLog("Staging metrics: total=%d, errors=%d, avg=%v, max=%v",
                                        totalStages, errorCount, avgLatency, maxLatency)
                        }</span>
                }
        }
}

// BatchCreateStages creates multiple stages concurrently
func (asm *AsyncStagingManager) BatchCreateStages(stages []*models.Stage) []error <span class="cov0" title="0">{
        results := make([]error, len(stages))
        callbacks := make([]&lt;-chan error, len(stages))

        // Fire all requests
        for i, stage := range stages </span><span class="cov0" title="0">{
                callbacks[i] = asm.CreateStageAsync(stage)
        }</span>

        // Collect results
        <span class="cov0" title="0">for i, callback := range callbacks </span><span class="cov0" title="0">{
                results[i] = &lt;-callback
        }</span>

        <span class="cov0" title="0">return results</span>
}

// Close shuts down worker pool
func (asm *AsyncStagingManager) Close() <span class="cov3" title="3">{
        asm.closeOnce.Do(func() </span><span class="cov3" title="3">{
                asm.cancel()
                close(asm.stageChan)
                asm.wg.Wait()
                close(asm.resultChan)
        }</span>)
}

// debugLog is a helper for logging
func (asm *AsyncStagingManager) debugLog(format string, args ...any) <span class="cov0" title="0">{
        if asm.config.Debug </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[STAGING] "+format+"\n", args...)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mcp

import (
        "io"
        "os"
        "path/filepath"
        "time"
)

// Config holds the MCP server configuration
type Config struct {
        // Database
        DatabaseURL string

        // Auto-apply settings
        AutoApplyEnabled   bool
        AutoApplyThreshold float64

        // Staging
        StagingTTL time.Duration

        // Session limits
        MaxStagesPerSession  int
        MaxAppliesPerSession int

        // Safety Configuration
        Safety SafetyConfig

        // Debug
        Debug bool

        // LogWriter allows tests to redirect debug logging; defaults to stderr.
        LogWriter io.Writer
}

// SafetyConfig holds safety-related configuration
type SafetyConfig struct {
        // File operation limits
        MaxFiles     int   `json:"max_files"`      // Max files per operation
        MaxFileSize  int64 `json:"max_file_size"`  // Max size per file (bytes)
        MaxTotalSize int64 `json:"max_total_size"` // Max total operation size (bytes)

        // Confidence validation
        ConfidenceMode   string  `json:"confidence_mode"`    // "global", "per_file", "both"
        PerFileThreshold float64 `json:"per_file_threshold"` // Individual file threshold
        GlobalThreshold  float64 `json:"global_threshold"`   // Overall operation threshold

        // Hash validation
        ValidateFileHashes bool `json:"validate_file_hashes"` // Check files weren't modified externally

        // Atomic writes
        AtomicWrites bool `json:"atomic_writes"` // Use atomic write operations
        UseFsync     bool `json:"use_fsync"`     // Use fsync for durability

        // Backup &amp; rollback
        CreateBackups  bool   `json:"create_backups"`  // Create .bak files before writes
        BackupSuffix   string `json:"backup_suffix"`   // Backup file suffix
        TransactionLog bool   `json:"transaction_log"` // Enable transaction logging

        // Concurrency safety
        FileLocking bool          `json:"file_locking"` // Use file locking
        LockTimeout time.Duration `json:"lock_timeout"` // Lock acquisition timeout
}

// DefaultConfig returns a config with sensible defaults
func DefaultConfig() Config <span class="cov9" title="110">{
        // Use temp directory for database if current dir is not writable, otherwise skip database
        dbPath := "./.morfx/db/morfx.db"
        if !isDirectoryWritable(".") </span><span class="cov0" title="0">{
                // Try temp directory first
                if isDirectoryWritable("/tmp") </span><span class="cov0" title="0">{
                        dbPath = "/tmp/morfx.db"
                }</span> else<span class="cov0" title="0"> {
                        // If even temp is not writable, skip database entirely
                        dbPath = "skip"
                }</span>
        }

         <span class="cov9" title="110">return Config{
                DatabaseURL:          dbPath,
                AutoApplyEnabled:     true,
                AutoApplyThreshold:   0.85,
                StagingTTL:           15 * time.Minute,
                MaxStagesPerSession:  100,
                MaxAppliesPerSession: 10,

                Safety: SafetyConfig{
                        // File operation limits
                        MaxFiles:     1000,              // Reasonable batch size
                        MaxFileSize:  10 * 1024 * 1024,  // 10MB per file
                        MaxTotalSize: 100 * 1024 * 1024, // 100MB total

                        // Confidence validation
                        ConfidenceMode:   "per_file", // Validate each file individually
                        PerFileThreshold: 0.70,       // Slightly lower than global for individual files
                        GlobalThreshold:  0.85,       // Matches AutoApplyThreshold

                        // Hash validation
                        ValidateFileHashes: true, // Always validate file integrity

                        // Atomic writes
                        AtomicWrites: true,  // Use atomic operations
                        UseFsync:     false, // Performance over extreme durability by default

                        // Backup &amp; rollback
                        CreateBackups:  false,        // No backups by default (can be overwhelming)
                        BackupSuffix:   ".morfx.bak", // Distinctive suffix
                        TransactionLog: true,         // Enable transaction logging

                        // Concurrency safety
                        FileLocking: true,             // Prevent concurrent modifications
                        LockTimeout: 30 * time.Second, // Reasonable timeout
                },

                Debug:     false,
                LogWriter: os.Stderr,
        }</span>
}

// isDirectoryWritable checks if a directory is writable
func isDirectoryWritable(path string) bool <span class="cov10" title="113">{
        // Try to create a temporary file
        testFile := filepath.Join(path, ".write_test")
        file, err := os.Create(testFile)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="112">file.Close()
        os.Remove(testFile)
        return true</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package mcp

import "fmt"

// Error codes following JSON-RPC 2.0 standard and custom domain errors
const (
        // JSON-RPC 2.0 standard error codes
        ParseError     = -32700 // Invalid JSON was received
        InvalidRequest = -32600 // The JSON sent is not a valid Request object
        MethodNotFound = -32601 // The method does not exist
        InvalidParams  = -32602 // Invalid method parameters
        InternalError  = -32603 // Internal JSON-RPC error

        // Custom domain error codes (10xxx range)
        LanguageNotFound = 10001 // No provider for the specified language
        SyntaxError      = 10002 // Source code parsing failed
        NoMatches        = 10003 // Query returned no results
        TransformFailed  = 10004 // Transformation operation failed
        StageNotFound    = 10005 // Staging ID doesn't exist
        StageExpired     = 10006 // Staging has expired
        AlreadyApplied   = 10007 // Stage was already applied
        DatabaseError    = 10008 // Database operation failed
        ConfidenceTooLow = 10009 // Confidence below threshold
        ValidationFailed = 10010 // Code validation failed
        FileSystemError  = 10011 // File system operation failed

        // Safety error codes (11xxx range)
        SafetyViolation      = 11001 // General safety violation
        FileTooLarge         = 11002 // File exceeds size limit
        TooManyFiles         = 11003 // Too many files in operation
        TotalSizeTooLarge    = 11004 // Total operation size too large
        FileModified         = 11005 // File was modified externally
        FileLocked           = 11006 // File is locked by another process
        LockTimeout          = 11007 // Could not acquire file lock
        AtomicWriteFailed    = 11008 // Atomic write operation failed
        BackupFailed         = 11009 // Backup creation failed
        RollbackFailed       = 11010 // Rollback operation failed
        PerFileConfidenceLow = 11011 // Individual file confidence too low
)

// MCPError represents a structured error for the MCP protocol
type MCPError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Data    any    `json:"data,omitempty"`
}

// Error implements the error interface
func (e *MCPError) Error() string <span class="cov7" title="14">{
        if e.Data != nil </span><span class="cov5" title="7">{
                return fmt.Sprintf("%s (%d): %v", e.Message, e.Code, e.Data)
        }</span>
        <span class="cov5" title="7">return fmt.Sprintf("%s (%d)", e.Message, e.Code)</span>
}

// NewMCPError creates a new MCP error with optional data
func NewMCPError(code int, message string, data ...any) *MCPError <span class="cov10" title="36">{
        err := &amp;MCPError{
                Code:    code,
                Message: message,
        }
        if len(data) &gt; 0 </span><span class="cov9" title="32">{
                err.Data = data[0]
        }</span>
        <span class="cov10" title="36">return err</span>
}

// WrapError wraps a regular error into an MCP error
func WrapError(code int, message string, err error) *MCPError <span class="cov3" title="3">{
        if err == nil </span><span class="cov0" title="0">{
                return NewMCPError(code, message)
        }</span>
        <span class="cov3" title="3">return NewMCPError(code, message, err.Error())</span>
}

// ErrorResponseWithData creates a JSON-RPC error response with additional data
func ErrorResponseWithData(id any, code int, message string, data any) Response <span class="cov5" title="5">{
        resp := ErrorResponse(id, code, message)
        if resp.Error != nil </span><span class="cov5" title="5">{
                resp.Error.Data = data
        }</span>
        <span class="cov5" title="5">return resp</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"

        "github.com/termfx/morfx/mcp/types"
)

const supportedProtocolVersion = "2025-06-18"

type listToolsResult struct {
        Tools      []types.ToolDefinition `json:"tools"`
        NextCursor *string                `json:"nextCursor,omitempty"`
}

type listPromptsResult struct {
        Prompts    []types.PromptDefinition `json:"prompts"`
        NextCursor *string                  `json:"nextCursor,omitempty"`
}

type listResourcesResult struct {
        Resources  []types.ResourceDefinition `json:"resources"`
        NextCursor *string                    `json:"nextCursor,omitempty"`
}

type listResourceTemplatesResult struct {
        ResourceTemplates []types.ResourceTemplateDefinition `json:"resourceTemplates"`
        NextCursor        *string                            `json:"nextCursor,omitempty"`
}

type readResourceResult struct {
        Contents []ResourceContent `json:"contents"`
}

type getPromptResult struct {
        Description string          `json:"description,omitempty"`
        Messages    []PromptMessage `json:"messages"`
}

// handleListTools returns available tools to the client
func (s *StdioServer) handleListTools(ctx context.Context, req Request) Response <span class="cov4" title="3">{
        params, err := decodePaginationParams(req.Params)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid pagination parameters")
        }</span>

        <span class="cov4" title="3">definitions := s.toolRegistry.GetDefinitions()
        page, nextCursor, err := applyPagination(definitions, params.Cursor, params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, err.Error())
        }</span>

        <span class="cov4" title="3">result := listToolsResult{Tools: page}
        result.NextCursor = nextCursor
        return SuccessResponse(req.ID, result)</span>
}

// handleCallTool executes a specific tool
func (s *StdioServer) handleCallTool(ctx context.Context, req Request) Response <span class="cov10" title="13">{
        var params struct {
                Name      string          `json:"name"`
                Arguments json.RawMessage `json:"arguments"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov3" title="2">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid params structure")
        }</span>

        <span class="cov9" title="11">s.debugLog("Calling tool: %s", params.Name)

        progressStatus := "completed"
        if token, ok := req.Meta.ProgressToken(); ok </span><span class="cov5" title="4">{
                s.sendProgressNotification(token, 0, 100, "queued")
                defer func() </span><span class="cov5" title="4">{
                        s.sendProgressNotification(token, 100, 100, progressStatus)
                }</span>()
        }

        <span class="cov9" title="11">result, err := s.toolRegistry.Execute(ctx, params.Name, params.Arguments)
        if err != nil </span><span class="cov7" title="7">{
                if errors.Is(err, ErrToolNotFound) </span><span class="cov3" title="2">{
                        progressStatus = "failed"
                        return ErrorResponse(req.ID, MethodNotFound,
                                fmt.Sprintf("Tool not found: %s", params.Name))
                }</span>

                <span class="cov6" title="5">if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov3" title="2">{
                        progressStatus = "cancelled"
                        return SuccessResponse(req.ID, buildErrorToolResult(-32800, "Request cancelled", map[string]any{"detail": err.Error()}))
                }</span>

                <span class="cov4" title="3">if mcpErr, ok := err.(*types.MCPError); ok </span><span class="cov0" title="0">{
                        progressStatus = "failed"
                        return SuccessResponse(req.ID, buildErrorToolResult(mcpErr.Code, mcpErr.Message, mcpErr.Data))
                }</span>
                <span class="cov4" title="3">if legacyErr, ok := err.(*MCPError); ok </span><span class="cov3" title="2">{
                        progressStatus = "failed"
                        return SuccessResponse(req.ID, buildErrorToolResult(legacyErr.Code, legacyErr.Message, legacyErr.Data))
                }</span>

                <span class="cov1" title="1">progressStatus = "failed"
                return ErrorResponse(req.ID, InternalError, err.Error())</span>
        }

        <span class="cov5" title="4">return SuccessResponse(req.ID, normalizeToolResult(result))</span>
}

// handleInitialize handles the MCP initialization handshake
func (s *StdioServer) handleInitialize(ctx context.Context, req Request) Response <span class="cov8" title="8">{
        var params struct {
                ProtocolVersion string                 `json:"protocolVersion"`
                Capabilities    map[string]any         `json:"capabilities"`
                ClientInfo      map[string]interface{} `json:"clientInfo"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid initialize parameters")
        }</span>

        <span class="cov8" title="8">clientName := "unknown"
        clientVersion := ""
        if params.ClientInfo != nil </span><span class="cov5" title="4">{
                if name, ok := params.ClientInfo["name"].(string); ok </span><span class="cov4" title="3">{
                        clientName = name
                }</span>
                <span class="cov5" title="4">if version, ok := params.ClientInfo["version"].(string); ok </span><span class="cov3" title="2">{
                        clientVersion = version
                }</span>
        }

        <span class="cov8" title="8">s.debugLog("Client initialize: %s v%s requested protocol %s", clientName, clientVersion, params.ProtocolVersion)

        negotiated := supportedProtocolVersion
        if params.ProtocolVersion != "" &amp;&amp; params.ProtocolVersion != supportedProtocolVersion </span><span class="cov0" title="0">{
                s.debugLog("Client protocol %s not matched, negotiating %s", params.ProtocolVersion, negotiated)
        }</span>

        <span class="cov8" title="8">s.sessionState.MarkInitialized(negotiated, params.Capabilities)

        result := map[string]any{
                "protocolVersion": negotiated,
                "capabilities":    s.serverCapabilities(),
                "serverInfo": map[string]any{
                        "name":    "morfx",
                        "version": "1.4.0",
                },
        }

        if instructions := s.defaultInstructions(); instructions != "" </span><span class="cov8" title="8">{
                result["instructions"] = instructions
        }</span>

        <span class="cov8" title="8">return SuccessResponse(req.ID, result)</span>
}

// handleInitialized confirms initialization complete
func (s *StdioServer) handleInitialized(ctx context.Context, req Request) Response <span class="cov6" title="5">{
        s.debugLog("Initialization complete")
        go func() </span><span class="cov6" title="5">{
                resp, err := s.RequestRoots(context.Background(), map[string]any{}, Meta{})
                if err != nil </span><span class="cov0" title="0">{
                        s.debugLog("roots/list request failed: %v", err)
                        return
                }</span>
                <span class="cov1" title="1">if resp.Error != nil </span><span class="cov0" title="0">{
                        s.debugLog("roots/list responded with error: %s", resp.Error.Message)
                        return
                }</span>
                <span class="cov1" title="1">var roots []string
                if result, ok := resp.Result.(map[string]any); ok </span><span class="cov1" title="1">{
                        if items, ok := result["roots"].([]any); ok </span><span class="cov1" title="1">{
                                for _, item := range items </span><span class="cov1" title="1">{
                                        if rootObj, ok := item.(map[string]any); ok </span><span class="cov1" title="1">{
                                                if uri, ok := rootObj["uri"].(string); ok </span><span class="cov1" title="1">{
                                                        roots = append(roots, uri)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov1" title="1">if len(roots) &gt; 0 </span><span class="cov1" title="1">{
                        s.sessionState.SetClientRoots(roots)
                }</span>
        }()
        <span class="cov6" title="5">if req.ID == nil </span><span class="cov1" title="1">{
                return Response{}
        }</span>
        <span class="cov5" title="4">return SuccessResponse(req.ID, map[string]any{})</span>
}

// handlePing responds to keepalive pings
func (s *StdioServer) handlePing(ctx context.Context, req Request) Response <span class="cov4" title="3">{
        return SuccessResponse(req.ID, map[string]any{})
}</span>

// handleListPrompts returns available prompts to the client
func (s *StdioServer) handleListPrompts(ctx context.Context, req Request) Response <span class="cov5" title="4">{
        params, err := decodePaginationParams(req.Params)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid pagination parameters")
        }</span>

        <span class="cov5" title="4">prompts := GetPromptDefinitions()
        page, nextCursor, err := applyPagination(prompts, params.Cursor, params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, err.Error())
        }</span>

        <span class="cov5" title="4">result := listPromptsResult{Prompts: page}
        result.NextCursor = nextCursor
        return SuccessResponse(req.ID, result)</span>
}

// handleGetPrompt returns the content of a specific prompt
func (s *StdioServer) handleGetPrompt(ctx context.Context, req Request) Response <span class="cov5" title="4">{
        var params struct {
                Name      string            `json:"name"`
                Arguments map[string]string `json:"arguments,omitempty"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov3" title="2">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid prompt parameters")
        }</span>

        <span class="cov3" title="2">s.debugLog("Getting prompt: %s", params.Name)

        messages, err := s.generatePromptContent(params.Name, params.Arguments)
        if err != nil </span><span class="cov1" title="1">{
                if mcpErr, ok := err.(*MCPError); ok </span><span class="cov1" title="1">{
                        return ErrorResponseWithData(req.ID, mcpErr.Code, mcpErr.Message, mcpErr.Data)
                }</span>
                <span class="cov0" title="0">return ErrorResponse(req.ID, InternalError, err.Error())</span>
        }

        <span class="cov1" title="1">return SuccessResponse(req.ID, getPromptResult{Messages: messages})</span>
}

// handleListResources returns available resources to the client
func (s *StdioServer) handleListResources(ctx context.Context, req Request) Response <span class="cov4" title="3">{
        params, err := decodePaginationParams(req.Params)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid pagination parameters")
        }</span>

        <span class="cov4" title="3">resources := s.ResourceDefinitions()
        page, nextCursor, err := applyPagination(resources, params.Cursor, params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, err.Error())
        }</span>

        <span class="cov4" title="3">result := listResourcesResult{Resources: page}
        result.NextCursor = nextCursor
        return SuccessResponse(req.ID, result)</span>
}

// handleListResourceTemplates returns available resource templates to the client
func (s *StdioServer) handleListResourceTemplates(ctx context.Context, req Request) Response <span class="cov0" title="0">{
        params, err := decodePaginationParams(req.Params)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid pagination parameters")
        }</span>

        <span class="cov0" title="0">templates := s.resourceTemplateRegistry.List()
        page, nextCursor, err := applyPagination(templates, params.Cursor, params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, err.Error())
        }</span>

        <span class="cov0" title="0">result := listResourceTemplatesResult{ResourceTemplates: page}
        result.NextCursor = nextCursor
        return SuccessResponse(req.ID, result)</span>
}

// handleReadResource returns the content of a specific resource
func (s *StdioServer) handleReadResource(ctx context.Context, req Request) Response <span class="cov8" title="8">{
        var params struct {
                URI string `json:"uri"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov1" title="1">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid resource read parameters")
        }</span>

        <span class="cov7" title="7">s.debugLog("Reading resource: %s", params.URI)

        content, err := s.generateResourceContent(params.URI)
        if err != nil </span><span class="cov3" title="2">{
                if mcpErr, ok := err.(*MCPError); ok </span><span class="cov3" title="2">{
                        return ErrorResponseWithData(req.ID, mcpErr.Code, mcpErr.Message, mcpErr.Data)
                }</span>
                <span class="cov0" title="0">return ErrorResponse(req.ID, InternalError, err.Error())</span>
        }

        <span class="cov6" title="5">return SuccessResponse(req.ID, readResourceResult{Contents: []ResourceContent{*content}})</span>
}

// handleSubscribeResource subscribes to resource changes
func (s *StdioServer) handleSubscribeResource(ctx context.Context, req Request) Response <span class="cov3" title="2">{
        var params struct {
                URI string `json:"uri"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid resource subscribe parameters")
        }</span>

        <span class="cov3" title="2">s.debugLog("Subscribing to resource: %s", params.URI)
        if params.URI == "" </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Resource URI is required")
        }</span>

        <span class="cov3" title="2">if _, builtin := builtinResourceURIs[params.URI]; builtin </span><span class="cov1" title="1">{
                // Built-in resources are static; acknowledge the subscription without watcher wiring.
                return SuccessResponse(req.ID, map[string]any{})
        }</span>

        <span class="cov1" title="1">resource, ok := s.lookupResource(params.URI)
        if !ok </span><span class="cov0" title="0">{
                return ErrorResponseWithData(req.ID, InvalidParams, "Resource not found", map[string]any{"uri": params.URI})
        }</span>

        <span class="cov1" title="1">watchable, ok := resource.(types.WatchableResource)
        if !ok </span><span class="cov0" title="0">{
                return SuccessResponse(req.ID, map[string]any{})
        }</span>

        <span class="cov1" title="1">subCtx, cancel := context.WithCancel(context.Background())
        updates, err := watchable.Watch(subCtx)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                if errors.Is(err, types.ErrResourceWatchUnsupported) </span><span class="cov0" title="0">{
                        return SuccessResponse(req.ID, map[string]any{})
                }</span>
                <span class="cov0" title="0">return ErrorResponse(req.ID, InternalError, err.Error())</span>
        }
        <span class="cov1" title="1">if updates == nil </span><span class="cov0" title="0">{
                cancel()
                return SuccessResponse(req.ID, map[string]any{})
        }</span>

        <span class="cov1" title="1">subscriptionID := s.addResourceSubscription(params.URI, cancel)
        go s.forwardResourceUpdates(params.URI, subscriptionID, updates, cancel)

        return SuccessResponse(req.ID, map[string]any{"subscriptionId": subscriptionID})</span>
}

// handleUnsubscribeResource unsubscribes from resource changes
func (s *StdioServer) handleUnsubscribeResource(ctx context.Context, req Request) Response <span class="cov3" title="2">{
        var params struct {
                URI            string `json:"uri"`
                SubscriptionID string `json:"subscriptionId,omitempty"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid resource unsubscribe parameters")
        }</span>

        <span class="cov3" title="2">s.debugLog("Unsubscribing from resource: %s", params.URI)
        if params.SubscriptionID != "" </span><span class="cov1" title="1">{
                s.cancelResourceSubscription(params.URI, params.SubscriptionID)
        }</span> else<span class="cov1" title="1"> if params.URI != "" </span><span class="cov1" title="1">{
                s.cancelAllResourceSubscriptions(params.URI)
        }</span>
        <span class="cov3" title="2">return SuccessResponse(req.ID, map[string]any{})</span>
}

func (s *StdioServer) serverCapabilities() map[string]any <span class="cov8" title="8">{
        return map[string]any{
                "tools": map[string]any{
                        "listChanged": true,
                },
                "resources": map[string]any{
                        "subscribe":   true,
                        "listChanged": true,
                        "templates": map[string]any{
                                "listChanged": true,
                        },
                },
                "prompts": map[string]any{
                        "listChanged": true,
                },
                "logging": map[string]any{},
        }
}</span>

func (s *StdioServer) defaultInstructions() string <span class="cov8" title="8">{
        return "Use tools/list to discover available actions, then call tools/call with the requested name to query or transform code."
}</span>

func buildErrorToolResult(code int, message string, data any) types.CallToolResult <span class="cov5" title="4">{
        structured := map[string]any{
                "code":    code,
                "message": message,
        }
        if data != nil </span><span class="cov5" title="4">{
                structured["data"] = data
        }</span>
        <span class="cov5" title="4">return types.CallToolResult{
                Content: []types.ContentBlock{
                        {Type: "text", Text: message},
                },
                StructuredContent: structured,
                IsError:           true,
        }</span>
}

func normalizeToolResult(result any) types.CallToolResult <span class="cov5" title="4">{
        if result == nil </span><span class="cov0" title="0">{
                return types.CallToolResult{Content: []types.ContentBlock{{Type: "text", Text: ""}}}
        }</span>
        <span class="cov5" title="4">if callResult, ok := result.(types.CallToolResult); ok </span><span class="cov0" title="0">{
                return callResult
        }</span>
        <span class="cov5" title="4">if callPtr, ok := result.(*types.CallToolResult); ok &amp;&amp; callPtr != nil </span><span class="cov0" title="0">{
                return *callPtr
        }</span>

        <span class="cov5" title="4">var (
                blocks     []types.ContentBlock
                structured any = result
        )

        if asMap, ok := result.(map[string]any); ok </span><span class="cov4" title="3">{
                if rawContent, exists := asMap["content"]; exists </span><span class="cov4" title="3">{
                        blocks = toContentBlocks(rawContent)
                }</span>
                <span class="cov4" title="3">if sc, exists := asMap["structuredContent"]; exists </span><span class="cov3" title="2">{
                        structured = sc
                }</span> else<span class="cov1" title="1"> {
                        remainder := mapWithout(asMap, "content")
                        if len(remainder) == 0 </span><span class="cov1" title="1">{
                                structured = nil
                        }</span> else<span class="cov0" title="0"> {
                                structured = remainder
                        }</span>
                }
        }

        <span class="cov5" title="4">if len(blocks) == 0 </span><span class="cov1" title="1">{
                if text, ok := result.(string); ok </span><span class="cov1" title="1">{
                        blocks = []types.ContentBlock{{Type: "text", Text: text}}
                        structured = nil
                }</span> else<span class="cov0" title="0"> {
                        blocks = []types.ContentBlock{{Type: "text", Text: marshalAsText(result)}}
                        structured = result
                }</span>
        }

        <span class="cov5" title="4">return types.CallToolResult{
                Content:           blocks,
                StructuredContent: structured,
        }</span>
}

func toContentBlocks(value any) []types.ContentBlock <span class="cov4" title="3">{
        switch blocks := value.(type) </span>{
        case []types.ContentBlock:<span class="cov0" title="0">
                return blocks</span>
        case []map[string]any:<span class="cov4" title="3">
                return convertContentMaps(blocks)</span>
        case []any:<span class="cov0" title="0">
                converted := make([]types.ContentBlock, 0, len(blocks))
                for _, item := range blocks </span><span class="cov0" title="0">{
                        if m, ok := item.(map[string]any); ok </span><span class="cov0" title="0">{
                                if block, ok := convertContentMap(m); ok </span><span class="cov0" title="0">{
                                        converted = append(converted, block)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return converted</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func convertContentMaps(items []map[string]any) []types.ContentBlock <span class="cov4" title="3">{
        converted := make([]types.ContentBlock, 0, len(items))
        for _, item := range items </span><span class="cov4" title="3">{
                if block, ok := convertContentMap(item); ok </span><span class="cov4" title="3">{
                        converted = append(converted, block)
                }</span>
        }
        <span class="cov4" title="3">return converted</span>
}

func convertContentMap(item map[string]any) (types.ContentBlock, bool) <span class="cov4" title="3">{
        typeName, _ := item["type"].(string)
        if typeName == "" </span><span class="cov0" title="0">{
                typeName = "text"
        }</span>
        <span class="cov4" title="3">block := types.ContentBlock{Type: typeName}
        if text, ok := item["text"].(string); ok </span><span class="cov4" title="3">{
                block.Text = text
        }</span>
        <span class="cov4" title="3">if uri, ok := item["uri"].(string); ok </span><span class="cov0" title="0">{
                block.URI = uri
        }</span>
        <span class="cov4" title="3">if mime, ok := item["mimeType"].(string); ok </span><span class="cov0" title="0">{
                block.MimeType = mime
        }</span>
        <span class="cov4" title="3">if annotations, ok := item["annotations"].(map[string]any); ok </span><span class="cov0" title="0">{
                block.Annotations = copyMap(annotations)
        }</span>
        <span class="cov4" title="3">switch data := item["data"].(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                block.Data = copyMap(data)</span>
        case []any:<span class="cov0" title="0">
                block.Data = map[string]any{"items": data}</span>
        case nil:<span class="cov4" title="3"></span>
        default:<span class="cov0" title="0">
                if block.Data == nil </span><span class="cov0" title="0">{
                        block.Data = make(map[string]any, 1)
                }</span>
                <span class="cov0" title="0">block.Data["value"] = data</span>
        }

        <span class="cov4" title="3">if block.Text == "" &amp;&amp; len(block.Data) == 1 </span><span class="cov0" title="0">{
                if value, ok := block.Data["value"]; ok </span><span class="cov0" title="0">{
                        block.Text = marshalAsText(value)
                }</span>
        }

        <span class="cov4" title="3">return block, true</span>
}

func marshalAsText(value any) string <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if text, ok := value.(string); ok </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">encoded, err := json.MarshalIndent(value, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", value)
        }</span>
        <span class="cov0" title="0">return string(encoded)</span>
}

func copyMap(source map[string]any) map[string]any <span class="cov0" title="0">{
        if source == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make(map[string]any, len(source))
        for k, v := range source </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

func mapWithout(source map[string]any, keys ...string) map[string]any <span class="cov1" title="1">{
        if len(source) == 0 </span><span class="cov0" title="0">{
                return map[string]any{}
        }</span>
        <span class="cov1" title="1">result := make(map[string]any, len(source))
        for k, v := range source </span><span class="cov1" title="1">{
                result[k] = v
        }</span>
        <span class="cov1" title="1">for _, key := range keys </span><span class="cov1" title="1">{
                delete(result, key)
        }</span>
        <span class="cov1" title="1">delete(result, "structuredContent")
        return result</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "time"
)

// LogLevel represents the severity level of a log message
type LogLevel string

const (
        LogLevelDebug     LogLevel = "debug"
        LogLevelInfo      LogLevel = "info"
        LogLevelNotice    LogLevel = "notice"
        LogLevelWarning   LogLevel = "warning"
        LogLevelError     LogLevel = "error"
        LogLevelCritical  LogLevel = "critical"
        LogLevelAlert     LogLevel = "alert"
        LogLevelEmergency LogLevel = "emergency"
)

// LogData represents structured data for a log message
type LogData map[string]any

// LogMessage represents a log message according to MCP specification
type LogMessage struct {
        Level  LogLevel `json:"level"`
        Data   LogData  `json:"data,omitempty"`
        Logger string   `json:"logger,omitempty"`
}

// handleSetLoggingLevel handles logging level configuration
func (s *StdioServer) handleSetLoggingLevel(ctx context.Context, req Request) Response <span class="cov2" title="2">{
        var params struct {
                Level LogLevel `json:"level"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov1" title="1">{
                return ErrorResponse(req.ID, InvalidParams, "Invalid logging level parameters")
        }</span>

        <span class="cov1" title="1">s.sessionState.SetLoggingLevel(params.Level)

        if s.config.Debug </span><span class="cov1" title="1">{
                fmt.Fprintf(os.Stderr, "[DEBUG] Logging level set to: %s\n", params.Level)
        }</span>

        <span class="cov1" title="1">return SuccessResponse(req.ID, map[string]any{})</span>
}

// sendLogNotification sends a log message notification to the client
func (s *StdioServer) sendLogNotification(level LogLevel, message string, data LogData) <span class="cov7" title="14">{
        if !shouldEmitLog(s.sessionState.LoggingLevel(), level) </span><span class="cov2" title="2">{
                return
        }</span>

        // Create or use existing data map
        <span class="cov6" title="12">if data == nil </span><span class="cov5" title="7">{
                data = make(LogData)
        }</span>
        <span class="cov6" title="12">data["message"] = message
        data["timestamp"] = time.Now().Format(time.RFC3339)

        notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/message",
                "params": map[string]any{
                        "level":  level,
                        "data":   data,
                        "logger": "morfx",
                },
        }

        s.emitNotification(notification)</span>
}

// LogInfo sends an info level log notification
func (s *StdioServer) LogInfo(message string, data ...LogData) <span class="cov4" title="4">{
        var logData LogData
        if len(data) &gt; 0 </span><span class="cov1" title="1">{
                logData = data[0]
        }</span>
        <span class="cov4" title="4">s.sendLogNotification(LogLevelInfo, message, logData)</span>
}

// LogWarning sends a warning level log notification
func (s *StdioServer) LogWarning(message string, data ...LogData) <span class="cov2" title="2">{
        var logData LogData
        if len(data) &gt; 0 </span><span class="cov1" title="1">{
                logData = data[0]
        }</span>
        <span class="cov2" title="2">s.sendLogNotification(LogLevelWarning, message, logData)</span>
}

// LogError sends an error level log notification
func (s *StdioServer) LogError(message string, data ...LogData) <span class="cov2" title="2">{
        var logData LogData
        if len(data) &gt; 0 </span><span class="cov1" title="1">{
                logData = data[0]
        }</span>
        <span class="cov2" title="2">s.sendLogNotification(LogLevelError, message, logData)</span>
}

// LogDebug sends a debug level log notification
func (s *StdioServer) LogDebug(message string, data ...LogData) <span class="cov2" title="2">{
        var logData LogData
        if len(data) &gt; 0 </span><span class="cov1" title="1">{
                logData = data[0]
        }</span>
        <span class="cov2" title="2">s.sendLogNotification(LogLevelDebug, message, logData)</span>
}

// sendResourceUpdatedNotification sends a notification when a resource is updated
func (s *StdioServer) sendResourceUpdatedNotification(uri string) <span class="cov2" title="2">{
        notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/resources/updated",
                "params": map[string]any{
                        "uri": uri,
                },
        }

        s.emitNotification(notification)
}</span>

// sendResourceListChangedNotification sends a notification when the resource list changes
func (s *StdioServer) sendResourceListChangedNotification() <span class="cov2" title="2">{
        notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/resources/list_changed",
                "params":  map[string]any{},
        }

        s.emitNotification(notification)
}</span>

// sendToolListChangedNotification sends a notification when the tool list changes
func (s *StdioServer) sendToolListChangedNotification() <span class="cov1" title="1">{
        notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/tools/list_changed",
                "params":  map[string]any{},
        }

        s.emitNotification(notification)
}</span>

// sendPromptListChangedNotification sends a notification when the prompt list changes
func (s *StdioServer) sendPromptListChangedNotification() <span class="cov1" title="1">{
        notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/prompts/list_changed",
                "params":  map[string]any{},
        }

        s.emitNotification(notification)
}</span>

// sendCancelledNotification informs the client that a server-initiated request was aborted.
func (s *StdioServer) sendCancelledNotification(requestID string, progressToken string) <span class="cov2" title="2">{
        params := map[string]any{}
        if requestID != "" </span><span class="cov2" title="2">{
                params["requestId"] = requestID
        }</span>
        <span class="cov2" title="2">if progressToken != "" </span><span class="cov2" title="2">{
                params["progressToken"] = progressToken
        }</span>

        <span class="cov2" title="2">notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/cancelled",
                "params":  params,
        }

        s.emitNotification(notification)</span>
}

// sendProgressNotification sends a progress notification for long-running operations
func (s *StdioServer) sendProgressNotification(progressToken string, progress, total float64, message string) <span class="cov8" title="32">{
        params := map[string]any{
                "progressToken": progressToken,
                "progress":      progress,
                "total":         total,
        }
        if message != "" </span><span class="cov8" title="32">{
                params["message"] = message
        }</span>

        <span class="cov8" title="32">notification := map[string]any{
                "jsonrpc": "2.0",
                "method":  "notifications/progress",
                "params":  params,
        }

        s.emitNotification(notification)</span>
}

func shouldEmitLog(min LogLevel, level LogLevel) bool <span class="cov7" title="14">{
        order := map[LogLevel]int{
                LogLevelDebug:     0,
                LogLevelInfo:      1,
                LogLevelNotice:    2,
                LogLevelWarning:   3,
                LogLevelError:     4,
                LogLevelCritical:  5,
                LogLevelAlert:     6,
                LogLevelEmergency: 7,
        }
        // Default to info if unknown
        minRank, ok := order[min]
        if !ok </span><span class="cov0" title="0">{
                minRank = order[LogLevelInfo]
        }</span>
        <span class="cov7" title="14">levelRank, ok := order[level]
        if !ok </span><span class="cov0" title="0">{
                levelRank = order[LogLevelInfo]
        }</span>
        <span class="cov7" title="14">return levelRank &gt;= minRank</span>
}

func (s *StdioServer) emitNotification(payload map[string]any) <span class="cov10" title="52">{
        payload["jsonrpc"] = JSONRPCVersion
        notificationJSON, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                s.debugLog("Failed to marshal notification %v: %v", payload["method"], err)
                return
        }</span>
        <span class="cov10" title="52">s.writeFrame(notificationJSON)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
        "strconv"
)

const (
        defaultListLimit = 50
        maxListLimit     = 200
)

type paginationParams struct {
        Cursor string `json:"cursor,omitempty"`
        Limit  int    `json:"limit,omitempty"`
}

func applyPagination[T any](items []T, cursor string, limit int) ([]T, *string, error) <span class="cov10" title="10">{
        if limit &lt;= 0 </span><span class="cov10" title="10">{
                if len(items) &lt; defaultListLimit </span><span class="cov10" title="10">{
                        limit = len(items)
                }</span> else<span class="cov0" title="0"> {
                        limit = defaultListLimit
                }</span>
        }
        <span class="cov10" title="10">if limit &gt; maxListLimit </span><span class="cov0" title="0">{
                limit = maxListLimit
        }</span>

        <span class="cov10" title="10">start := 0
        if cursor != "" </span><span class="cov0" title="0">{
                idx, err := strconv.Atoi(cursor)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("invalid cursor value: %w", err)
                }</span>
                <span class="cov0" title="0">if idx &lt; 0 || idx &gt; len(items) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("cursor out of range")
                }</span>
                <span class="cov0" title="0">start = idx</span>
        }

        <span class="cov10" title="10">if start &gt;= len(items) </span><span class="cov0" title="0">{
                return []T{}, nil, nil
        }</span>

        <span class="cov10" title="10">end := start + limit
        if end &gt; len(items) </span><span class="cov0" title="0">{
                end = len(items)
        }</span>

        <span class="cov10" title="10">page := items[start:end]

        if end &gt;= len(items) </span><span class="cov10" title="10">{
                return page, nil, nil
        }</span>

        <span class="cov0" title="0">next := strconv.Itoa(end)
        return page, &amp;next, nil</span>
}

func decodePaginationParams(raw json.RawMessage) (paginationParams, error) <span class="cov10" title="10">{
        if len(raw) == 0 || string(raw) == "null" </span><span class="cov8" title="6">{
                return paginationParams{}, nil
        }</span>
        <span class="cov6" title="4">var params paginationParams
        if err := json.Unmarshal(raw, &amp;params); err != nil </span><span class="cov0" title="0">{
                return paginationParams{}, err
        }</span>
        <span class="cov6" title="4">return params, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mcp

import "context"

type progressContextKey struct{}

type progressState struct {
        token string
}

func withProgressToken(ctx context.Context, token string) context.Context <span class="cov5" title="7">{
        if token == "" </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov5" title="7">state := progressState{token: token}
        return context.WithValue(ctx, progressContextKey{}, state)</span>
}

func progressTokenFromContext(ctx context.Context) (string, bool) <span class="cov10" title="56">{
        if ctx == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov10" title="56">if state, ok := ctx.Value(progressContextKey{}).(progressState); ok </span><span class="cov8" title="33">{
                if state.token != "" </span><span class="cov8" title="33">{
                        return state.token, true
                }</span>
        }
        <span class="cov8" title="23">return "", false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mcp

import (
        "fmt"
        "strings"

        prompts "github.com/termfx/morfx/mcp/prompts"
        "github.com/termfx/morfx/mcp/types"
)

// PromptContent represents the content of a prompt response
type PromptContent struct {
        Type string `json:"type"`
        Text string `json:"text,omitempty"`
}

// PromptMessage represents a prompt message
type PromptMessage struct {
        Role    string          `json:"role"`
        Content []PromptContent `json:"content"`
}

// GetPromptDefinitions returns all available prompt definitions

func GetPromptDefinitions() []types.PromptDefinition <span class="cov5" title="6">{
        definitions := []types.PromptDefinition{
                {
                        Name:        "code-analysis",
                        Title:       "Code Analysis",
                        Description: "Analyze code structure and suggest transformations",
                        Arguments: []types.PromptArgument{
                                {Name: "language", Description: "Programming language of the code", Required: true},
                                {Name: "code", Description: "Source code to analyze", Required: true},
                                {Name: "focus", Description: "Optional focus area (functions, structs, methods, etc.)"},
                        },
                        Annotations: map[string]any{
                                "category": "analysis",
                                "audience": "developer",
                        },
                },
                {
                        Name:        "transformation-guide",
                        Title:       "Transformation Guide",
                        Description: "Generate step-by-step guide for code transformations",
                        Arguments: []types.PromptArgument{
                                {Name: "operation", Description: "Type of transformation (replace, delete, insert, etc.)", Required: true},
                                {Name: "target", Description: "What to transform (function name, struct name, etc.)", Required: true},
                                {Name: "language", Description: "Programming language"},
                        },
                        Annotations: map[string]any{
                                "category": "guidance",
                                "audience": "developer",
                        },
                },
                {
                        Name:        "confidence-explanation",
                        Title:       "Confidence Explanation",
                        Description: "Explain confidence scores and factors for transformations",
                        Arguments: []types.PromptArgument{
                                {Name: "score", Description: "Confidence score (0.0-1.0)", Required: true},
                                {Name: "factors", Description: "JSON string of confidence factors"},
                        },
                        Annotations: map[string]any{
                                "category": "insight",
                                "audience": "developer",
                        },
                },
                {
                        Name:        "query-builder",
                        Title:       "Query Builder",
                        Description: "Help build queries for finding code elements",
                        Arguments: []types.PromptArgument{
                                {Name: "description", Description: "Natural language description of what to find", Required: true},
                                {Name: "language", Description: "Programming language"},
                        },
                        Annotations: map[string]any{
                                "category": "analysis",
                                "audience": "developer",
                        },
                },
                {
                        Name:        "best-practices",
                        Title:       "Best Practices",
                        Description: "Provide best practices and recommendations for code transformations",
                        Arguments: []types.PromptArgument{
                                {Name: "language", Description: "Programming language", Required: true},
                                {Name: "operation", Description: "Type of operation being performed"},
                        },
                        Annotations: map[string]any{
                                "category": "guidance",
                                "audience": "developer",
                        },
                },
        }

        seen := make(map[string]struct{}, len(definitions))
        for _, def := range definitions </span><span class="cov10" title="30">{
                seen[def.Name] = struct{}{}
        }</span>

        <span class="cov5" title="6">for _, prompt := range prompts.Registry.List() </span><span class="cov9" title="24">{
                name := prompt.Name()
                if _, exists := seen[name]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="24">definitions = append(definitions, types.PromptDefinition{
                        Name:        name,
                        Title:       strings.Title(strings.ReplaceAll(name, "_", " ")),
                        Description: prompt.Description(),
                        Arguments:   prompt.Arguments(),
                        Annotations: map[string]any{
                                "category": "custom",
                                "audience": "developer",
                        },
                })

                seen[name] = struct{}{}</span>
        }

        <span class="cov5" title="6">return definitions</span>
}

// generatePromptContent creates the actual content for a prompt
func (s *StdioServer) generatePromptContent(name string, args map[string]string) ([]PromptMessage, error) <span class="cov6" title="8">{
        switch name </span>{
        case "code-analysis":<span class="cov2" title="2">
                return s.generateCodeAnalysisPrompt(args)</span>
        case "transformation-guide":<span class="cov1" title="1">
                return s.generateTransformationGuidePrompt(args)</span>
        case "confidence-explanation":<span class="cov1" title="1">
                return s.generateConfidenceExplanationPrompt(args)</span>
        case "query-builder":<span class="cov1" title="1">
                return s.generateQueryBuilderPrompt(args)</span>
        case "best-practices":<span class="cov1" title="1">
                return s.generateBestPracticesPrompt(args)</span>
        default:<span class="cov2" title="2">
                return nil, NewMCPError(MethodNotFound, "Prompt not found", map[string]any{
                        "name": name,
                })</span>
        }
}

// generateCodeAnalysisPrompt creates a code analysis prompt
func (s *StdioServer) generateCodeAnalysisPrompt(args map[string]string) ([]PromptMessage, error) <span class="cov5" title="6">{
        language := args["language"]
        code := args["code"]
        focus := args["focus"]

        if language == "" || code == "" </span><span class="cov3" title="3">{
                return nil, NewMCPError(InvalidParams, "Missing required arguments: language and code", nil)
        }</span>

        <span class="cov3" title="3">var analysisText strings.Builder
        analysisText.WriteString(
                fmt.Sprintf("I need you to analyze this %s code and suggest potential transformations:\n\n", language),
        )
        analysisText.WriteString("```" + language + "\n")
        analysisText.WriteString(code)
        analysisText.WriteString("\n```\n\n")

        if focus != "" </span><span class="cov2" title="2">{
                analysisText.WriteString(fmt.Sprintf("Please focus specifically on: %s\n\n", focus))
        }</span>

        <span class="cov3" title="3">analysisText.WriteString("Provide:\n")
        analysisText.WriteString("1. Code structure overview\n")
        analysisText.WriteString("2. Potential improvements or refactoring opportunities\n")
        analysisText.WriteString("3. Specific transformation suggestions using Morfx operations\n")
        analysisText.WriteString("4. Any code quality or best practice recommendations\n")

        return []PromptMessage{
                {
                        Role: "user",
                        Content: []PromptContent{
                                {
                                        Type: "text",
                                        Text: analysisText.String(),
                                },
                        },
                },
        }, nil</span>
}

// generateTransformationGuidePrompt creates a transformation guide prompt
func (s *StdioServer) generateTransformationGuidePrompt(args map[string]string) ([]PromptMessage, error) <span class="cov5" title="5">{
        operation := args["operation"]
        target := args["target"]
        language := args["language"]

        if operation == "" || target == "" </span><span class="cov3" title="3">{
                return nil, NewMCPError(InvalidParams, "Missing required arguments: operation and target", nil)
        }</span>

        <span class="cov2" title="2">var guideText strings.Builder
        guideText.WriteString(
                fmt.Sprintf("I need a step-by-step guide for performing a '%s' operation on '%s'", operation, target),
        )

        if language != "" </span><span class="cov2" title="2">{
                guideText.WriteString(fmt.Sprintf(" in %s", language))
        }</span>

        <span class="cov2" title="2">guideText.WriteString(".\n\n")
        guideText.WriteString("Please provide:\n")
        guideText.WriteString("1. Overview of the transformation\n")
        guideText.WriteString("2. Step-by-step instructions\n")
        guideText.WriteString("3. Morfx tool commands to use\n")
        guideText.WriteString("4. Example queries and parameters\n")
        guideText.WriteString("5. Potential risks and considerations\n")
        guideText.WriteString("6. How to verify the transformation was successful\n")

        return []PromptMessage{
                {
                        Role: "user",
                        Content: []PromptContent{
                                {
                                        Type: "text",
                                        Text: guideText.String(),
                                },
                        },
                },
        }, nil</span>
}

// generateConfidenceExplanationPrompt creates a confidence explanation prompt
func (s *StdioServer) generateConfidenceExplanationPrompt(args map[string]string) ([]PromptMessage, error) <span class="cov4" title="4">{
        score := args["score"]
        factors := args["factors"]

        if score == "" </span><span class="cov1" title="1">{
                return nil, NewMCPError(InvalidParams, "Missing required argument: score", nil)
        }</span>

        <span class="cov3" title="3">var explanationText strings.Builder
        explanationText.WriteString(fmt.Sprintf("Please explain this confidence score: %s\n\n", score))

        if factors != "" </span><span class="cov2" title="2">{
                explanationText.WriteString("Confidence factors:\n")
                explanationText.WriteString(factors)
                explanationText.WriteString("\n\n")
        }</span>

        <span class="cov3" title="3">explanationText.WriteString("Please provide:\n")
        explanationText.WriteString("1. What this confidence score means\n")
        explanationText.WriteString("2. Interpretation of the confidence level (high/medium/low)\n")
        explanationText.WriteString("3. Explanation of each factor and its impact\n")
        explanationText.WriteString("4. Recommendations for how to proceed\n")
        explanationText.WriteString("5. Ways to potentially improve the confidence score\n")

        return []PromptMessage{
                {
                        Role: "user",
                        Content: []PromptContent{
                                {
                                        Type: "text",
                                        Text: explanationText.String(),
                                },
                        },
                },
        }, nil</span>
}

// generateQueryBuilderPrompt creates a query builder prompt
func (s *StdioServer) generateQueryBuilderPrompt(args map[string]string) ([]PromptMessage, error) <span class="cov4" title="4">{
        description := args["description"]
        language := args["language"]

        if description == "" </span><span class="cov1" title="1">{
                return nil, NewMCPError(InvalidParams, "Missing required argument: description", nil)
        }</span>

        <span class="cov3" title="3">var queryText strings.Builder
        queryText.WriteString("I need help building a Morfx query for this request:\n\n")
        queryText.WriteString(fmt.Sprintf("Description: %s\n\n", description))

        if language != "" </span><span class="cov2" title="2">{
                queryText.WriteString(fmt.Sprintf("Language: %s\n\n", language))
        }</span>

        <span class="cov3" title="3">queryText.WriteString("Please provide:\n")
        queryText.WriteString("1. The appropriate Morfx query structure\n")
        queryText.WriteString("2. JSON query object to use\n")
        queryText.WriteString("3. Alternative query approaches if applicable\n")
        queryText.WriteString("4. Expected results and what to look for\n")
        queryText.WriteString("5. Tips for refining the query if needed\n\n")

        queryText.WriteString("Format the query as a JSON object that can be used with Morfx tools.")

        return []PromptMessage{
                {
                        Role: "user",
                        Content: []PromptContent{
                                {
                                        Type: "text",
                                        Text: queryText.String(),
                                },
                        },
                },
        }, nil</span>
}

// generateBestPracticesPrompt creates a best practices prompt
func (s *StdioServer) generateBestPracticesPrompt(args map[string]string) ([]PromptMessage, error) <span class="cov4" title="4">{
        language := args["language"]
        operation := args["operation"]

        if language == "" </span><span class="cov1" title="1">{
                return nil, NewMCPError(InvalidParams, "Missing required argument: language", nil)
        }</span>

        <span class="cov3" title="3">var practicesText strings.Builder
        practicesText.WriteString(
                fmt.Sprintf("Please provide best practices and recommendations for code transformations in %s", language),
        )

        if operation != "" </span><span class="cov2" title="2">{
                practicesText.WriteString(fmt.Sprintf(", specifically for '%s' operations", operation))
        }</span>

        <span class="cov3" title="3">practicesText.WriteString(".\n\n")
        practicesText.WriteString("Please cover:\n")
        practicesText.WriteString("1. General transformation best practices\n")
        practicesText.WriteString("2. Language-specific considerations\n")
        practicesText.WriteString("3. Common pitfalls to avoid\n")
        practicesText.WriteString("4. Testing and validation strategies\n")
        practicesText.WriteString("5. When to use staging vs auto-apply\n")
        practicesText.WriteString("6. Backup and rollback strategies\n")
        practicesText.WriteString("7. Performance considerations for large codebases\n")

        return []PromptMessage{
                {
                        Role: "user",
                        Content: []PromptContent{
                                {
                                        Type: "text",
                                        Text: practicesText.String(),
                                },
                        },
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package prompts

import "github.com/termfx/morfx/mcp/types"

// NewCodeReviewPrompt creates a code review prompt
func NewCodeReviewPrompt() *BasePrompt <span class="cov10" title="5">{
        return &amp;BasePrompt{
                name:        "code_review",
                description: "Comprehensive code review with focus on quality and best practices",
                content: `You are an expert code reviewer. Analyze the provided code for:
1. Code quality and maintainability
2. Performance issues and optimizations
3. Security vulnerabilities
4. Adherence to language best practices
5. Test coverage and quality

Provide specific, actionable feedback with code examples where appropriate.`,
                arguments: []types.PromptArgument{
                        {
                                Name:        "code",
                                Description: "The code to review",
                                Required:    true,
                        },
                        {
                                Name:        "language",
                                Description: "Programming language of the code",
                                Required:    true,
                        },
                        {
                                Name:        "focus_areas",
                                Description: "Specific areas to focus on (optional)",
                                Required:    false,
                        },
                },
        }
}</span>

// NewRefactorPrompt creates a refactoring prompt
func NewRefactorPrompt() *BasePrompt <span class="cov10" title="5">{
        return &amp;BasePrompt{
                name:        "refactor",
                description: "Suggest refactoring improvements for better code structure",
                content: `You are a refactoring expert. Analyze the code and suggest improvements for:
1. Better separation of concerns
2. Reduced complexity
3. Improved testability
4. Design pattern applications
5. Code reusability

Provide before/after examples and explain the benefits of each refactoring.`,
                arguments: []types.PromptArgument{
                        {
                                Name:        "code",
                                Description: "The code to refactor",
                                Required:    true,
                        },
                        {
                                Name:        "goals",
                                Description: "Specific refactoring goals",
                                Required:    false,
                        },
                },
        }
}</span>

// NewTestGenerationPrompt creates a test generation prompt
func NewTestGenerationPrompt() *BasePrompt <span class="cov10" title="5">{
        return &amp;BasePrompt{
                name:        "test_generation",
                description: "Generate comprehensive test cases for code",
                content: `You are a testing expert. Generate comprehensive test cases including:
1. Unit tests for individual functions
2. Edge cases and boundary conditions
3. Error handling scenarios
4. Integration test suggestions
5. Performance test scenarios where relevant

Use the appropriate testing framework for the language.`,
                arguments: []types.PromptArgument{
                        {
                                Name:        "code",
                                Description: "The code to test",
                                Required:    true,
                        },
                        {
                                Name:        "framework",
                                Description: "Testing framework to use",
                                Required:    false,
                        },
                },
        }
}</span>

// NewDocumentationPrompt creates a documentation generation prompt
func NewDocumentationPrompt() *BasePrompt <span class="cov10" title="5">{
        return &amp;BasePrompt{
                name:        "documentation",
                description: "Generate comprehensive documentation for code",
                content: `You are a technical documentation expert. Generate clear documentation including:
1. Function/method descriptions
2. Parameter explanations
3. Return value descriptions
4. Usage examples
5. Important notes and warnings

Follow the language's documentation conventions.`,
                arguments: []types.PromptArgument{
                        {
                                Name:        "code",
                                Description: "The code to document",
                                Required:    true,
                        },
                        {
                                Name:        "style",
                                Description: "Documentation style guide to follow",
                                Required:    false,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package prompts

import (
        "sync"

        "github.com/termfx/morfx/mcp/types"
)

// BasePrompt provides common prompt functionality
type BasePrompt struct {
        name        string
        description string
        content     string
        arguments   []types.PromptArgument
}

// Name returns the prompt name
func (p *BasePrompt) Name() string <span class="cov8" title="14">{
        return p.name
}</span>

// Description returns the prompt description
func (p *BasePrompt) Description() string <span class="cov6" title="6">{
        return p.description
}</span>

// Content returns the prompt content
func (p *BasePrompt) Content() string <span class="cov3" title="2">{
        return p.content
}</span>

// Arguments returns the prompt arguments
func (p *BasePrompt) Arguments() []types.PromptArgument <span class="cov7" title="9">{
        return p.arguments
}</span>

// promptRegistry manages prompts internally
type promptRegistry struct {
        mu      sync.RWMutex
        prompts map[string]types.Prompt
        ordered []string
}

// Registry holds all registered prompts
var Registry = &amp;promptRegistry{
        prompts: make(map[string]types.Prompt),
        ordered: make([]string, 0),
}

// Register adds a prompt to the registry
func (r *promptRegistry) Register(name string, prompt types.Prompt) <span class="cov10" title="22">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.prompts[name]; !exists </span><span class="cov9" title="21">{
                r.ordered = append(r.ordered, name)
        }</span>
        <span class="cov10" title="22">r.prompts[name] = prompt</span>
}

// Get retrieves a prompt by name
func (r *promptRegistry) Get(name string) (types.Prompt, bool) <span class="cov7" title="8">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        prompt, exists := r.prompts[name]
        return prompt, exists
}</span>

// List returns all prompts in registration order
func (r *promptRegistry) List() []types.Prompt <span class="cov5" title="4">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]types.Prompt, 0, len(r.ordered))
        for _, name := range r.ordered </span><span class="cov8" title="14">{
                result = append(result, r.prompts[name])
        }</span>
        <span class="cov5" title="4">return result</span>
}

// Init initializes the prompt registry
func Init() <span class="cov1" title="1">{
        RegisterAll()
}</span>

// RegisterAll registers all built-in prompts
func RegisterAll() <span class="cov5" title="4">{
        // Register all prompts here
        Registry.Register("code_review", NewCodeReviewPrompt())
        Registry.Register("refactor", NewRefactorPrompt())
        Registry.Register("test_generation", NewTestGenerationPrompt())
        Registry.Register("documentation", NewDocumentationPrompt())
}</span>

// Get retrieves a prompt by name
func Get(name string) (types.Prompt, bool) <span class="cov1" title="1">{
        return Registry.Get(name)
}</span>

// GetDefinitions returns all prompt definitions
func GetDefinitions() []types.PromptDefinition <span class="cov1" title="1">{
        prompts := Registry.List()
        definitions := make([]types.PromptDefinition, 0, len(prompts))

        for _, prompt := range prompts </span><span class="cov5" title="4">{
                definitions = append(definitions, types.PromptDefinition{
                        Name:        prompt.Name(),
                        Description: prompt.Description(),
                        Arguments:   prompt.Arguments(),
                })
        }</span>

        <span class="cov1" title="1">return definitions</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
)

// JSON-RPC protocol constants used by the MCP transport layer.
const JSONRPCVersion = "2.0"

// Meta represents the optional `_meta` envelope that can accompany any
// request, notification, or response in the MCP transport. The structure is
// intentionally open-ended to support spec-defined fields like
// `progressToken` while allowing experimental metadata.
type Meta map[string]any

// ProgressToken returns the `_meta.progressToken` value if present.
func (m Meta) ProgressToken() (string, bool) <span class="cov9" title="45">{
        if m == nil </span><span class="cov8" title="22">{
                return "", false
        }</span>
        <span class="cov8" title="23">if token, ok := m["progressToken"].(string); ok &amp;&amp; token != "" </span><span class="cov7" title="18">{
                return token, true
        }</span>
        <span class="cov4" title="5">return "", false</span>
}

// WithProgressToken returns a copy of the metadata map with the provided
// progress token value applied. A zero-length token removes the field.
func (m Meta) WithProgressToken(token string) Meta <span class="cov6" title="10">{
        var clone Meta
        if len(m) == 0 </span><span class="cov6" title="10">{
                clone = make(Meta)
        }</span> else<span class="cov0" title="0"> {
                clone = make(Meta, len(m))
                for k, v := range m </span><span class="cov0" title="0">{
                        clone[k] = v
                }</span>
        }
        <span class="cov6" title="10">if token == "" </span><span class="cov0" title="0">{
                delete(clone, "progressToken")
                return clone
        }</span>
        <span class="cov6" title="10">clone["progressToken"] = token
        return clone</span>
}

// RequestMessage represents a JSON-RPC 2.0 request that expects a response.
type RequestMessage struct {
        JSONRPC string          `json:"jsonrpc"`
        Meta    Meta            `json:"_meta,omitempty"`
        ID      any             `json:"id"`
        Method  string          `json:"method"`
        Params  json.RawMessage `json:"params,omitempty"`
}

// NotificationMessage represents a JSON-RPC 2.0 notification with no ID.
type NotificationMessage struct {
        JSONRPC string          `json:"jsonrpc"`
        Meta    Meta            `json:"_meta,omitempty"`
        Method  string          `json:"method"`
        Params  json.RawMessage `json:"params,omitempty"`
}

// ResponseMessage represents a JSON-RPC 2.0 response to a request.
type ResponseMessage struct {
        JSONRPC string       `json:"jsonrpc"`
        Meta    Meta         `json:"_meta,omitempty"`
        ID      any          `json:"id"`
        Result  any          `json:"result,omitempty"`
        Error   *ErrorObject `json:"error,omitempty"`
}

// ErrorObject represents a JSON-RPC 2.0 error payload.
type ErrorObject struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Data    any    `json:"data,omitempty"`
}

// NewRequestMessage constructs a request envelope for the supplied method.
func NewRequestMessage(id any, method string, params any) (RequestMessage, error) <span class="cov7" title="15">{
        payload, err := marshalParams(params)
        if err != nil </span><span class="cov0" title="0">{
                return RequestMessage{}, err
        }</span>
        <span class="cov7" title="15">return RequestMessage{
                JSONRPC: JSONRPCVersion,
                ID:      id,
                Method:  method,
                Params:  payload,
        }, nil</span>
}

// NewNotificationMessage constructs a notification envelope for the method.
func NewNotificationMessage(method string, params any) (NotificationMessage, error) <span class="cov0" title="0">{
        payload, err := marshalParams(params)
        if err != nil </span><span class="cov0" title="0">{
                return NotificationMessage{}, err
        }</span>
        <span class="cov0" title="0">return NotificationMessage{
                JSONRPC: JSONRPCVersion,
                Method:  method,
                Params:  payload,
        }, nil</span>
}

// SuccessResponse builds a success response with the provided result payload.
func SuccessResponse(id, result any) ResponseMessage <span class="cov10" title="49">{
        return ResponseMessage{
                JSONRPC: JSONRPCVersion,
                ID:      id,
                Result:  result,
        }
}</span>

// ErrorResponse builds a response containing the supplied error object.
func ErrorResponse(id any, code int, message string, data ...any) ResponseMessage <span class="cov8" title="28">{
        var extra any
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                extra = data[0]
        }</span>
        <span class="cov8" title="28">return ResponseMessage{
                JSONRPC: JSONRPCVersion,
                ID:      id,
                Error: &amp;ErrorObject{
                        Code:    code,
                        Message: message,
                        Data:    extra,
                },
        }</span>
}

// ensureVersion validates that a decoded message has the expected jsonrpc value.
func ensureVersion(v string) error <span class="cov8" title="26">{
        if v == JSONRPCVersion </span><span class="cov8" title="23">{
                return nil
        }</span>
        <span class="cov3" title="3">if v == "" </span><span class="cov3" title="3">{
                return fmt.Errorf("missing jsonrpc version")
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("unsupported jsonrpc version: %s", v)</span>
}

func marshalParams(params any) (json.RawMessage, error) <span class="cov7" title="15">{
        if params == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov7" title="15">raw, err := json.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encode params: %w", err)
        }</span>
        <span class="cov7" title="15">return raw, nil</span>
}

// Legacy aliases retained temporarily while refactoring call sites. They will
// be removed once all handlers are migrated to the new naming.
type (
        Request      = RequestMessage
        Response     = ResponseMessage
        Error        = ErrorObject
        Notification = NotificationMessage
)
</pre>
		
		<pre class="file" id="file20" style="display: none">package mcp

import (
        "context"
        "encoding/json"

        "github.com/termfx/morfx/mcp/types"
)

// handleQueryTool delegates to the modular tool registry so tests and
// legacy call-sites use the same implementation as the new tool system.
func (s *StdioServer) handleQueryTool(ctx context.Context, params json.RawMessage) (any, error) <span class="cov10" title="9">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov10" title="9">result, err := s.toolRegistry.Execute(ctx, "query", params)
        if err != nil </span><span class="cov8" title="7">{
                if mcpErr, ok := err.(*types.MCPError); ok </span><span class="cov8" title="7">{
                        return nil, NewMCPError(mcpErr.Code, mcpErr.Message, mcpErr.Data)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov3" title="2">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/termfx/morfx/mcp/types"
)

// ErrToolNotFound indicates that a requested tool is not registered.
var ErrToolNotFound = errors.New("tool not found")

// Registry is a generic registry for MCP components
type Registry[T any] interface {
        Register(name string, component T)
        Get(name string) (T, bool)
        List() []T
        Names() []string
}

// BaseRegistry provides a thread-safe generic registry implementation
type BaseRegistry[T any] struct {
        mu         sync.RWMutex
        components map[string]T
        ordered    []string // Maintain registration order
}

// NewBaseRegistry creates a new generic registry
func NewBaseRegistry[T any]() *BaseRegistry[T] <span class="cov8" title="352">{
        return &amp;BaseRegistry[T]{
                components: make(map[string]T),
                ordered:    make([]string, 0),
        }
}</span>

// Register adds a component to the registry
func (r *BaseRegistry[T]) Register(name string, component T) <span class="cov10" title="1066">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.components[name]; !exists </span><span class="cov9" title="1062">{
                r.ordered = append(r.ordered, name)
        }</span>
        <span class="cov10" title="1066">r.components[name] = component</span>
}

// Get retrieves a component by name
func (r *BaseRegistry[T]) Get(name string) (T, bool) <span class="cov5" title="28">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        component, exists := r.components[name]
        return component, exists
}</span>

// List returns all components in registration order
func (r *BaseRegistry[T]) List() []T <span class="cov4" title="15">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]T, 0, len(r.ordered))
        for _, name := range r.ordered </span><span class="cov6" title="80">{
                result = append(result, r.components[name])
        }</span>
        <span class="cov4" title="15">return result</span>
}

// Names returns all component names in registration order
func (r *BaseRegistry[T]) Names() []string <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]string, len(r.ordered))
        copy(result, r.ordered)
        return result
}</span>

// ToolRegistry manages tool registration and execution
type ToolRegistry struct {
        *BaseRegistry[types.Tool]
        server ServerInterface // Back-reference for handler context
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(server ServerInterface) *ToolRegistry <span class="cov6" title="88">{
        return &amp;ToolRegistry{
                BaseRegistry: NewBaseRegistry[types.Tool](),
                server:       server,
        }
}</span>

// Execute runs a tool by name with the given parameters
func (tr *ToolRegistry) Execute(ctx context.Context, name string, params json.RawMessage) (any, error) <span class="cov5" title="25">{
        tool, exists := tr.Get(name)
        if !exists </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("%w: %s", ErrToolNotFound, name)
        }</span>

        // Tools need server context, so we wrap the handler
        <span class="cov5" title="23">handler := tool.Handler()
        return handler(ctx, params)</span>
}

// GetDefinitions returns tool definitions for MCP protocol
func (tr *ToolRegistry) GetDefinitions() []types.ToolDefinition <span class="cov3" title="5">{
        tools := tr.List()
        definitions := make([]types.ToolDefinition, 0, len(tools))

        for _, tool := range tools </span><span class="cov6" title="50">{
                name := tool.Name()
                title := strings.Title(strings.ReplaceAll(name, "_", " "))
                category := classifyToolCategory(name)
                annotations := map[string]any{
                        "name":             name,
                        "kind":             toolKind(category),
                        "category":         category,
                        "scope":            toolScope(name),
                        "scoped":           strings.HasPrefix(name, "file_"),
                        "entrypoint":       fmt.Sprintf("tools/call:%s", name),
                        "stability":        toolStability(name),
                        "audience":         "developer",
                        "progress":         toolSupportsProgress(name),
                        "output":           "call-tool-result",
                        "structuredResult": "structuredContent",
                }
                definitions = append(definitions, types.ToolDefinition{
                        Name:          name,
                        Title:         title,
                        Description:   tool.Description(),
                        InputSchema:   types.NormalizeSchema(tool.InputSchema()),
                        OutputSchema:  buildCallToolResultSchema(),
                        StructuredKey: "structuredContent",
                        Annotations:   annotations,
                })
        }</span>

        <span class="cov3" title="5">return definitions</span>
}

func classifyToolCategory(name string) string <span class="cov6" title="50">{
        switch </span>{
        case strings.HasPrefix(name, "file_"):<span class="cov4" title="15">
                return "file-transform"</span>
        case name == "query" || name == "file_query":<span class="cov3" title="5">
                return "analysis"</span>
        case name == "apply":<span class="cov3" title="5">
                return "staging"</span>
        default:<span class="cov5" title="25">
                return "code-transform"</span>
        }
}

func toolKind(category string) string <span class="cov6" title="50">{
        switch category </span>{
        case "analysis":<span class="cov3" title="5">
                return "analysis"</span>
        case "staging":<span class="cov3" title="5">
                return "workflow"</span>
        default:<span class="cov5" title="40">
                return "transformation"</span>
        }
}

func toolScope(name string) string <span class="cov6" title="50">{
        if strings.HasPrefix(name, "file_") </span><span class="cov4" title="15">{
                return "file"
        }</span>
        <span class="cov5" title="35">if name == "apply" </span><span class="cov3" title="5">{
                return "workspace"
        }</span>
        <span class="cov5" title="30">return "workspace"</span>
}

func toolStability(name string) string <span class="cov6" title="50">{
        switch name </span>{
        case "apply":<span class="cov3" title="5">
                return "beta"</span>
        default:<span class="cov5" title="45">
                return "stable"</span>
        }
}

var builtinProgressTools = map[string]struct{}{
        "append":        {},
        "apply":         {},
        "delete":        {},
        "insert_after":  {},
        "insert_before": {},
        "query":         {},
        "replace":       {},
}

func toolSupportsProgress(name string) bool <span class="cov6" title="50">{
        if strings.HasPrefix(name, "file_") </span><span class="cov4" title="15">{
                return true
        }</span>
        <span class="cov5" title="35">_, ok := builtinProgressTools[name]
        return ok</span>
}

func buildCallToolResultSchema() map[string]any <span class="cov6" title="50">{
        return types.NormalizeSchema(map[string]any{
                "type": "object",
                "properties": map[string]any{
                        "content": map[string]any{
                                "type": "array",
                                "items": map[string]any{
                                        "type": "object",
                                        "properties": map[string]any{
                                                "type":        map[string]any{"type": "string"},
                                                "text":        map[string]any{"type": "string"},
                                                "uri":         map[string]any{"type": "string", "format": "uri"},
                                                "mimeType":    map[string]any{"type": "string"},
                                                "data":        map[string]any{"type": "object"},
                                                "annotations": map[string]any{"type": "object"},
                                        },
                                        "required":             []string{"type"},
                                        "additionalProperties": true,
                                },
                        },
                        "structuredContent": map[string]any{"type": "object"},
                        "isError":           map[string]any{"type": "boolean"},
                },
                "required":             []string{"content"},
                "additionalProperties": true,
        })
}</span>

// PromptRegistry manages prompt registration
type PromptRegistry struct {
        *BaseRegistry[types.Prompt]
}

// NewPromptRegistry creates a new prompt registry
func NewPromptRegistry() *PromptRegistry <span class="cov6" title="88">{
        return &amp;PromptRegistry{
                BaseRegistry: NewBaseRegistry[types.Prompt](),
        }
}</span>

// ResourceRegistry manages resource registration
type ResourceRegistry struct {
        *BaseRegistry[types.Resource]
}

// NewResourceRegistry creates a new resource registry
func NewResourceRegistry() *ResourceRegistry <span class="cov6" title="88">{
        return &amp;ResourceRegistry{
                BaseRegistry: NewBaseRegistry[types.Resource](),
        }
}</span>

// ResourceTemplateRegistry manages resource template registration
type ResourceTemplateRegistry struct {
        *BaseRegistry[types.ResourceTemplateDefinition]
}

// NewResourceTemplateRegistry creates a new resource template registry
func NewResourceTemplateRegistry() *ResourceTemplateRegistry <span class="cov6" title="88">{
        return &amp;ResourceTemplateRegistry{
                BaseRegistry: NewBaseRegistry[types.ResourceTemplateDefinition](),
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package mcp

import "github.com/termfx/morfx/mcp/types"

func registerDefaultResourceTemplates(reg *ResourceTemplateRegistry) <span class="cov10" title="88">{
        if reg == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="88">reg.Register("workspace-file", types.ResourceTemplateDefinition{
                Name:        "workspace-file",
                Title:       "Workspace File",
                Description: "Read a file from the active workspace by relative path.",
                URITemplate: "file://{path}",
                InputSchema: types.NormalizeSchema(map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "path": map[string]any{
                                        "type":        "string",
                                        "description": "Path to the file, relative to the workspace root.",
                                },
                        },
                        "required": []string{"path"},
                }),
                Annotations: map[string]any{
                        "workspaceRelative": true,
                },
        })

        reg.Register("workspace-directory", types.ResourceTemplateDefinition{
                Name:        "workspace-directory",
                Title:       "Workspace Directory",
                Description: "List files within a workspace directory.",
                URITemplate: "morfx://workspace/{path}",
                InputSchema: types.NormalizeSchema(map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "path": map[string]any{
                                        "type":        "string",
                                        "description": "Directory path relative to the workspace root.",
                                },
                                "recursive": map[string]any{
                                        "type":        "boolean",
                                        "description": "Include nested files when true.",
                                        "default":     false,
                                },
                                "maxEntries": map[string]any{
                                        "type":        "integer",
                                        "description": "Maximum number of entries to include.",
                                        "minimum":     1,
                                        "maximum":     500,
                                },
                        },
                        "required": []string{"path"},
                }),
                Annotations: map[string]any{
                        "workspaceRelative": true,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
        "runtime"
        "strings"
        "time"

        "github.com/termfx/morfx/mcp/resources"
        "github.com/termfx/morfx/mcp/types"
)

// ResourceContent represents the content of a resource
type ResourceContent struct {
        URI      string `json:"uri"`
        MimeType string `json:"mimeType"`
        Text     string `json:"text,omitempty"`
        Blob     []byte `json:"blob,omitempty"`
}

// ResourceDefinitions returns all available resource definitions

var builtinResourceURIs = map[string]struct{}{
        "morfx://server/info":         {},
        "morfx://server/capabilities": {},
        "morfx://providers/languages": {},
        "morfx://session/current":     {},
        "morfx://config/settings":     {},
}

func resourceContentLength(content *ResourceContent) int64 <span class="cov8" title="28">{
        if content == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="28">if content.Text != "" </span><span class="cov8" title="28">{
                return int64(len(content.Text))
        }</span>
        <span class="cov0" title="0">if len(content.Blob) &gt; 0 </span><span class="cov0" title="0">{
                return int64(len(content.Blob))
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func int64Ptr(v int64) *int64 <span class="cov8" title="28">{
        return &amp;v
}</span>

func (s *StdioServer) lookupResource(uri string) (types.Resource, bool) <span class="cov3" title="3">{
        if s != nil &amp;&amp; s.resourceRegistry != nil </span><span class="cov3" title="3">{
                if res, ok := s.resourceRegistry.Get(uri); ok </span><span class="cov1" title="1">{
                        return res, true
                }</span>
        }
        <span class="cov2" title="2">if res, ok := resources.Registry.Get(uri); ok </span><span class="cov0" title="0">{
                return res, true
        }</span>
        <span class="cov2" title="2">return nil, false</span>
}

func (s *StdioServer) ResourceDefinitions() []types.ResourceDefinition <span class="cov5" title="7">{
        defs := []types.ResourceDefinition{
                {
                        URI:         "morfx://server/info",
                        Name:        "server-info",
                        Title:       "Server Information",
                        Description: "Current server status, configuration, and runtime information",
                        MimeType:    "application/json",
                        Annotations: map[string]any{
                                "category": "system",
                                "readonly": true,
                        },
                },
                {
                        URI:         "morfx://server/capabilities",
                        Name:        "server-capabilities",
                        Title:       "Server Capabilities",
                        Description: "Detailed information about server capabilities and supported features",
                        MimeType:    "application/json",
                        Annotations: map[string]any{
                                "category": "system",
                                "readonly": true,
                        },
                },
                {
                        URI:         "morfx://providers/languages",
                        Name:        "providers-languages",
                        Title:       "Supported Languages",
                        Description: "List of programming languages supported for code transformations",
                        MimeType:    "application/json",
                        Annotations: map[string]any{
                                "category": "providers",
                                "readonly": true,
                        },
                },
                {
                        URI:         "morfx://session/current",
                        Name:        "session-current",
                        Title:       "Current Session",
                        Description: "Information about the current transformation session",
                        MimeType:    "application/json",
                        Annotations: map[string]any{
                                "category": "session",
                                "readonly": true,
                        },
                },
                {
                        URI:         "morfx://config/settings",
                        Name:        "config-settings",
                        Title:       "Configuration Settings",
                        Description: "Current server configuration and settings",
                        MimeType:    "application/json",
                        Annotations: map[string]any{
                                "category": "config",
                                "readonly": true,
                        },
                },
        }

        for i := range defs </span><span class="cov8" title="35">{
                enrichResourceDefinition(&amp;defs[i], nil)
                if s != nil </span><span class="cov8" title="35">{
                        s.enrichRuntimeResourceMetadata(&amp;defs[i])
                }</span>
        }

        <span class="cov5" title="7">appendDynamic := func(res types.Resource) </span><span class="cov8" title="35">{
                uri := res.URI()
                definition := types.ResourceDefinition{
                        URI:         uri,
                        Name:        uri,
                        Title:       res.Name(),
                        Description: res.Description(),
                        MimeType:    res.MimeType(),
                        Annotations: map[string]any{
                                "title": res.Name(),
                        },
                }
                enrichResourceDefinition(&amp;definition, res)
                if s != nil </span><span class="cov8" title="35">{
                        s.enrichRuntimeResourceMetadata(&amp;definition)
                }</span>
                <span class="cov8" title="35">defs = append(defs, definition)</span>
        }

        <span class="cov5" title="7">seen := make(map[string]struct{}, len(defs))
        for _, def := range defs </span><span class="cov8" title="35">{
                seen[def.URI] = struct{}{}
        }</span>

        <span class="cov5" title="7">for _, res := range resources.Registry.List() </span><span class="cov8" title="35">{
                if _, exists := seen[res.URI()]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="35">appendDynamic(res)
                seen[res.URI()] = struct{}{}</span>
        }

        <span class="cov5" title="7">if s != nil &amp;&amp; s.resourceRegistry != nil </span><span class="cov5" title="7">{
                for _, res := range s.resourceRegistry.List() </span><span class="cov0" title="0">{
                        if _, exists := seen[res.URI()]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">appendDynamic(res)
                        seen[res.URI()] = struct{}{}</span>
                }
        }

        <span class="cov5" title="7">return defs</span>
}

func (s *StdioServer) enrichRuntimeResourceMetadata(def *types.ResourceDefinition) <span class="cov10" title="70">{
        if def == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="70">if def.Annotations == nil </span><span class="cov0" title="0">{
                def.Annotations = make(map[string]any)
        }</span>
        <span class="cov10" title="70">if _, ok := def.Annotations["audience"]; !ok </span><span class="cov10" title="70">{
                def.Annotations["audience"] = "developer"
        }</span>

        <span class="cov10" title="70">if _, builtin := builtinResourceURIs[def.URI]; builtin </span><span class="cov8" title="35">{
                if _, ok := def.Annotations["cacheControl"]; !ok </span><span class="cov8" title="35">{
                        def.Annotations["cacheControl"] = "static"
                }</span>
                <span class="cov8" title="35">if _, ok := def.Annotations["stability"]; !ok </span><span class="cov8" title="35">{
                        def.Annotations["stability"] = "stable"
                }</span>
                <span class="cov8" title="35">if def.Size == nil </span><span class="cov8" title="35">{
                        if def.URI == "morfx://server/capabilities" </span><span class="cov5" title="7">{
                                return
                        }</span>
                        <span class="cov8" title="28">var content *ResourceContent
                        switch def.URI </span>{
                        case "morfx://server/info":<span class="cov5" title="7">
                                content, _ = s.generateServerInfo()</span>
                        case "morfx://server/capabilities":<span class="cov0" title="0">
                                content, _ = s.generateServerCapabilities()</span>
                        case "morfx://providers/languages":<span class="cov5" title="7">
                                content, _ = s.generateSupportedLanguages()</span>
                        case "morfx://session/current":<span class="cov5" title="7">
                                content, _ = s.generateCurrentSession()</span>
                        case "morfx://config/settings":<span class="cov5" title="7">
                                content, _ = s.generateConfigSettings()</span>
                        }
                        <span class="cov8" title="28">if size := resourceContentLength(content); size &gt; 0 </span><span class="cov8" title="28">{
                                def.Size = int64Ptr(size)
                        }</span>
                }
                <span class="cov8" title="28">return</span>
        }

        <span class="cov8" title="35">if _, ok := def.Annotations["cacheControl"]; !ok </span><span class="cov8" title="35">{
                def.Annotations["cacheControl"] = "dynamic"
        }</span>
        <span class="cov8" title="35">if _, ok := def.Annotations["stability"]; !ok </span><span class="cov8" title="35">{
                def.Annotations["stability"] = "experimental"
        }</span>
        <span class="cov8" title="35">if def.Size != nil </span><span class="cov8" title="35">{
                return
        }</span>
        <span class="cov0" title="0">if res, ok := resources.Registry.Get(def.URI); ok </span><span class="cov0" title="0">{
                if text, err := res.Contents(); err == nil </span><span class="cov0" title="0">{
                        def.Size = int64Ptr(int64(len(text)))
                }</span>
        }
}

func enrichResourceDefinition(def *types.ResourceDefinition, res types.Resource) <span class="cov10" title="70">{
        if def.Title == "" </span><span class="cov0" title="0">{
                def.Title = def.Name
        }</span>
        <span class="cov10" title="70">if def.Annotations == nil </span><span class="cov0" title="0">{
                def.Annotations = make(map[string]any)
        }</span>
        <span class="cov10" title="70">if _, ok := def.Annotations["category"]; !ok </span><span class="cov8" title="35">{
                def.Annotations["category"] = resourceCategory(def.URI)
        }</span>
        <span class="cov10" title="70">if _, ok := def.Annotations["readonly"]; !ok </span><span class="cov8" title="35">{
                def.Annotations["readonly"] = true
        }</span>
        <span class="cov10" title="70">if res != nil </span><span class="cov8" title="35">{
                if text, err := res.Contents(); err == nil </span><span class="cov8" title="35">{
                        size := int64(len(text))
                        def.Size = &amp;size
                }</span>
        }
}

func resourceCategory(uri string) string <span class="cov8" title="35">{
        if idx := strings.Index(uri, "://"); idx != -1 </span><span class="cov8" title="35">{
                return uri[:idx]
        }</span>
        <span class="cov0" title="0">return "custom"</span>
}

// generateResourceContent creates the actual content for a resource URI
func (s *StdioServer) generateResourceContent(uri string) (*ResourceContent, error) <span class="cov6" title="12">{
        switch uri </span>{
        case "morfx://server/info":<span class="cov2" title="2">
                return s.generateServerInfo()</span>
        case "morfx://server/capabilities":<span class="cov2" title="2">
                return s.generateServerCapabilities()</span>
        case "morfx://providers/languages":<span class="cov2" title="2">
                return s.generateSupportedLanguages()</span>
        case "morfx://session/current":<span class="cov2" title="2">
                return s.generateCurrentSession()</span>
        case "morfx://config/settings":<span class="cov2" title="2">
                return s.generateConfigSettings()</span>
        default:<span class="cov2" title="2">
                if res, ok := s.lookupResource(uri); ok </span><span class="cov0" title="0">{
                        text, err := res.Contents()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, types.WrapError(InternalError, "Failed to read resource", err)
                        }</span>
                        <span class="cov0" title="0">return &amp;ResourceContent{
                                URI:      uri,
                                MimeType: res.MimeType(),
                                Text:     text,
                        }, nil</span>
                }
                <span class="cov2" title="2">return nil, NewMCPError(MethodNotFound, "Resource not found", map[string]any{
                        "uri": uri,
                })</span>
        }
}

// generateServerInfo creates server information resource content
func (s *StdioServer) generateServerInfo() (*ResourceContent, error) <span class="cov5" title="10">{
        dbInfo := map[string]any{
                "enabled": s.db != nil,
        }
        if s.db != nil </span><span class="cov0" title="0">{
                dbInfo["type"] = "sqlite"
        }</span> else<span class="cov5" title="10"> {
                dbInfo["type"] = "none"
        }</span>
        <span class="cov5" title="10">if s.config.DatabaseURL != "" </span><span class="cov5" title="10">{
                dbInfo["has_url"] = true
        }</span>

        <span class="cov5" title="10">info := map[string]any{
                "name":    "Morfx MCP Server",
                "version": "1.4.0",
                "runtime": map[string]any{
                        "go_version": runtime.Version(),
                        "platform":   fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
                        "cpus":       runtime.NumCPU(),
                },
                "uptime": map[string]any{
                        "started_at": time.Now().Format(time.RFC3339),
                },
                "database": dbInfo,
                "features": map[string]any{
                        "staging":   s.staging != nil,
                        "sessions":  s.session != nil,
                        "file_ops":  true,
                        "in_memory": true,
                },
        }

        data, err := json.MarshalIndent(info, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(InternalError, "Failed to marshal server info", err)
        }</span>

        <span class="cov5" title="10">return &amp;ResourceContent{
                URI:      "morfx://server/info",
                MimeType: "application/json",
                Text:     string(data),
        }, nil</span>
}

// generateServerCapabilities creates server capabilities resource content
func (s *StdioServer) generateServerCapabilities() (*ResourceContent, error) <span class="cov2" title="2">{
        capabilities := map[string]any{
                "protocol_version": supportedProtocolVersion,
                "tools": map[string]any{
                        "count":    len(s.toolRegistry.List()),
                        "features": []string{"query", "transform", "stage", "apply"},
                },
                "resources": map[string]any{
                        "count":    len(s.ResourceDefinitions()),
                        "features": []string{"read", "subscribe", "notifications"},
                },
                "prompts": map[string]any{
                        "count":    5, // Number of available prompts
                        "features": []string{"get", "list"},
                },
                "languages": map[string]any{
                        "supported": []string{"go"},
                        "planned":   []string{"python", "javascript", "typescript"},
                },
                "transformations": []string{
                        "query", "replace", "delete", "insert_before", "insert_after", "append",
                },
                "file_operations": map[string]any{
                        "supported": true,
                        "features":  []string{"file_query", "file_replace", "file_delete", "backup"},
                },
        }

        data, err := json.MarshalIndent(capabilities, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(InternalError, "Failed to marshal capabilities", err)
        }</span>

        <span class="cov2" title="2">return &amp;ResourceContent{
                URI:      "morfx://server/capabilities",
                MimeType: "application/json",
                Text:     string(data),
        }, nil</span>
}

// generateSupportedLanguages creates supported languages resource content
func (s *StdioServer) generateSupportedLanguages() (*ResourceContent, error) <span class="cov5" title="9">{
        languages := map[string]any{
                "supported": []map[string]any{
                        {
                                "name":         "go",
                                "display_name": "Go",
                                "extensions":   []string{".go"},
                                "features": map[string]any{
                                        "ast_parsing":        true,
                                        "transformations":    true,
                                        "confidence_scoring": true,
                                },
                        },
                },
                "planned": []map[string]any{
                        {
                                "name":         "python",
                                "display_name": "Python",
                                "extensions":   []string{".py"},
                                "status":       "in_development",
                        },
                        {
                                "name":         "javascript",
                                "display_name": "JavaScript",
                                "extensions":   []string{".js", ".jsx"},
                                "status":       "planned",
                        },
                        {
                                "name":         "typescript",
                                "display_name": "TypeScript",
                                "extensions":   []string{".ts", ".tsx"},
                                "status":       "planned",
                        },
                },
        }

        data, err := json.MarshalIndent(languages, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(InternalError, "Failed to marshal languages", err)
        }</span>

        <span class="cov5" title="9">return &amp;ResourceContent{
                URI:      "morfx://providers/languages",
                MimeType: "application/json",
                Text:     string(data),
        }, nil</span>
}

// generateCurrentSession creates current session resource content
func (s *StdioServer) generateCurrentSession() (*ResourceContent, error) <span class="cov5" title="9">{
        sessionInfo := map[string]any{
                "session_id": nil,
                "status":     "active",
                "database":   s.db != nil,
                "staging":    s.staging != nil,
                "mode":       "stateless", // Default to stateless when no database
        }

        if s.session != nil </span><span class="cov0" title="0">{
                sessionInfo["session_id"] = s.session.ID
                sessionInfo["started_at"] = s.session.StartedAt.Format(time.RFC3339)
                sessionInfo["stages_count"] = s.session.StagesCount
                sessionInfo["applies_count"] = s.session.AppliesCount
                sessionInfo["mode"] = "persistent"
        }</span> else<span class="cov5" title="9"> {
                sessionInfo["message"] = "Running in stateless mode - no persistence available"
                sessionInfo["limitations"] = []string{
                        "No staging of transformations",
                        "No session history",
                        "Transformations applied immediately or returned as text",
                }
        }</span>

        <span class="cov5" title="9">data, err := json.MarshalIndent(sessionInfo, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(InternalError, "Failed to marshal session info", err)
        }</span>

        <span class="cov5" title="9">return &amp;ResourceContent{
                URI:      "morfx://session/current",
                MimeType: "application/json",
                Text:     string(data),
        }, nil</span>
}

// generateConfigSettings creates configuration settings resource content
func (s *StdioServer) generateConfigSettings() (*ResourceContent, error) <span class="cov5" title="9">{
        settings := map[string]any{
                "auto_apply_enabled":      s.config.AutoApplyEnabled,
                "auto_apply_threshold":    s.config.AutoApplyThreshold,
                "staging_ttl_minutes":     s.config.StagingTTL.Minutes(),
                "max_stages_per_session":  s.config.MaxStagesPerSession,
                "max_applies_per_session": s.config.MaxAppliesPerSession,
                "debug":                   s.config.Debug,
        }

        if s.config.DatabaseURL != "" </span><span class="cov5" title="9">{
                settings["database_url_present"] = true
        }</span>

        <span class="cov5" title="9">data, err := json.MarshalIndent(settings, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, WrapError(InternalError, "Failed to marshal config settings", err)
        }</span>

        <span class="cov5" title="9">return &amp;ResourceContent{
                URI:      "morfx://config/settings",
                MimeType: "application/json",
                Text:     string(data),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package resources

import (
        "context"
        "fmt"
        "os"
        "sync"

        "github.com/termfx/morfx/mcp/types"
)

// BaseResource provides common resource functionality
type BaseResource struct {
        name        string
        description string
        uri         string
        mimeType    string
        contentFunc func() (string, error)
        watcherFunc func(context.Context) (&lt;-chan types.ResourceUpdate, error)
}

// Name returns the resource name
func (r *BaseResource) Name() string <span class="cov8" title="13">{
        return r.name
}</span>

// Description returns the resource description
func (r *BaseResource) Description() string <span class="cov5" title="5">{
        return r.description
}</span>

// URI returns the resource URI
func (r *BaseResource) URI() string <span class="cov7" title="10">{
        return r.uri
}</span>

// MimeType returns the resource MIME type
func (r *BaseResource) MimeType() string <span class="cov6" title="7">{
        return r.mimeType
}</span>

// Contents returns the resource contents
func (r *BaseResource) Contents() (string, error) <span class="cov6" title="6">{
        if r.contentFunc != nil </span><span class="cov5" title="5">{
                return r.contentFunc()
        }</span>
        <span class="cov1" title="1">return "", fmt.Errorf("no content function defined")</span>
}

// Watch subscribes to resource updates when supported.
func (r *BaseResource) Watch(ctx context.Context) (&lt;-chan types.ResourceUpdate, error) <span class="cov0" title="0">{
        if r.watcherFunc == nil </span><span class="cov0" title="0">{
                return nil, types.ErrResourceWatchUnsupported
        }</span>
        <span class="cov0" title="0">return r.watcherFunc(ctx)</span>
}

// resourceRegistry manages resources internally
type resourceRegistry struct {
        mu        sync.RWMutex
        resources map[string]types.Resource
        ordered   []string
}

// Registry holds all registered resources
var Registry = &amp;resourceRegistry{
        resources: make(map[string]types.Resource),
        ordered:   make([]string, 0),
}

// Register adds a resource to the registry
func (r *resourceRegistry) Register(name string, resource types.Resource) <span class="cov10" title="22">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.resources[name]; !exists </span><span class="cov9" title="21">{
                r.ordered = append(r.ordered, name)
        }</span>
        <span class="cov10" title="22">r.resources[name] = resource</span>
}

// Get retrieves a resource by name
func (r *resourceRegistry) Get(name string) (types.Resource, bool) <span class="cov7" title="8">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        resource, exists := r.resources[name]
        return resource, exists
}</span>

// List returns all resources in registration order
func (r *resourceRegistry) List() []types.Resource <span class="cov5" title="4">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]types.Resource, 0, len(r.ordered))
        for _, name := range r.ordered </span><span class="cov8" title="14">{
                result = append(result, r.resources[name])
        }</span>
        <span class="cov5" title="4">return result</span>
}

// Init initializes the resource registry
func Init() <span class="cov1" title="1">{
        RegisterAll()
}</span>

// RegisterAll registers all built-in resources
func RegisterAll() <span class="cov5" title="4">{
        // Configuration resources
        Registry.Register("config://supported-languages", NewSupportedLanguagesResource())
        Registry.Register("config://transformation-methods", NewTransformationMethodsResource())

        // Documentation resources
        Registry.Register("docs://readme", NewReadmeResource())
        Registry.Register("docs://api", NewAPIDocResource())
}</span>

// Get retrieves a resource by name
func Get(name string) (types.Resource, bool) <span class="cov1" title="1">{
        return Registry.Get(name)
}</span>

// GetDefinitions returns all resource definitions
func GetDefinitions() []types.ResourceDefinition <span class="cov1" title="1">{
        resources := Registry.List()
        definitions := make([]types.ResourceDefinition, 0, len(resources))

        for _, resource := range resources </span><span class="cov5" title="4">{
                title := resource.Name()
                annotations := map[string]any{
                        "title":    title,
                        "readonly": true,
                }
                definitions = append(definitions, types.ResourceDefinition{
                        URI:         resource.URI(),
                        Name:        resource.URI(),
                        Title:       title,
                        Description: resource.Description(),
                        MimeType:    resource.MimeType(),
                        Annotations: annotations,
                })
        }</span>

        <span class="cov1" title="1">return definitions</span>
} // NewSupportedLanguagesResource creates a resource listing supported languages
func NewSupportedLanguagesResource() *BaseResource <span class="cov5" title="5">{
        return &amp;BaseResource{
                name:        "Supported Languages",
                description: "List of programming languages supported by Morfx",
                uri:         "config://supported-languages",
                mimeType:    "application/json",
                contentFunc: func() (string, error) </span><span class="cov1" title="1">{
                        return `{
  "languages": [
    {"name": "go", "extensions": [".go"], "features": ["full"]},
    {"name": "python", "extensions": [".py"], "features": ["full"]},
    {"name": "javascript", "extensions": [".js", ".jsx"], "features": ["full"]},
    {"name": "typescript", "extensions": [".ts", ".tsx"], "features": ["full"]},
    {"name": "php", "extensions": [".php"], "features": ["full"]}
  ]
}`, nil
                }</span>,
        }
}

// NewDynamicResource creates a resource with dynamic content function
func NewDynamicResource(name, description, uri, mime string, content func() (string, error)) types.Resource <span class="cov0" title="0">{
        return &amp;BaseResource{
                name:        name,
                description: description,
                uri:         uri,
                mimeType:    mime,
                contentFunc: content,
        }
}</span>

// NewTransformationMethodsResource creates a resource listing transformation methods
func NewTransformationMethodsResource() *BaseResource <span class="cov5" title="5">{
        return &amp;BaseResource{
                name:        "Transformation Methods",
                description: "Available code transformation methods",
                uri:         "config://transformation-methods",
                mimeType:    "application/json",
                contentFunc: func() (string, error) </span><span class="cov1" title="1">{
                        return `{
  "methods": [
    {"name": "replace", "description": "Replace code elements"},
    {"name": "delete", "description": "Delete code elements"},
    {"name": "insert_before", "description": "Insert code before elements"},
    {"name": "insert_after", "description": "Insert code after elements"},
    {"name": "append", "description": "Append code to elements"}
  ]
}`, nil
                }</span>,
        }
}

// NewReadmeResource creates a resource for the README
func NewReadmeResource() *BaseResource <span class="cov5" title="5">{
        return &amp;BaseResource{
                name:        "README",
                description: "Morfx documentation and usage guide",
                uri:         "docs://readme",
                mimeType:    "text/markdown",
                contentFunc: func() (string, error) </span><span class="cov1" title="1">{
                        // Try to read actual README if available
                        content, err := os.ReadFile("README.md")
                        if err != nil </span><span class="cov1" title="1">{
                                return "# Morfx\n\nDeterministic AST-based code transformations for AI agents.", nil
                        }</span>
                        <span class="cov0" title="0">return string(content), nil</span>
                },
        }
}

// NewAPIDocResource creates a resource for API documentation
func NewAPIDocResource() *BaseResource <span class="cov5" title="5">{
        return &amp;BaseResource{
                name:        "API Documentation",
                description: "Complete API reference for Morfx tools",
                uri:         "docs://api",
                mimeType:    "text/markdown",
                contentFunc: func() (string, error) </span><span class="cov1" title="1">{
                        return `# Morfx API Documentation

## Query Tool
Find code elements using natural language queries.

## Replace Tool
Replace code elements with new implementations.

## Delete Tool
Remove code elements from source files.

## Insert Tools
Insert code before or after specific elements.

## Append Tool
Append code to functions, classes, or files.
`, nil
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mcp

import (
        "context"
        "fmt"
        "sync"
)

// RequestHandler processes a JSON-RPC request message and returns a response.
type RequestHandler func(ctx context.Context, msg RequestMessage) ResponseMessage

// NotificationHandler processes a JSON-RPC notification.
type NotificationHandler func(ctx context.Context, msg NotificationMessage) error

// Router maintains a registry of MCP request and notification handlers and
// provides centralized dispatch with JSON-RPC compliance checks.
type Router struct {
        mu                   sync.RWMutex
        requestHandlers      map[string]RequestHandler
        notificationHandlers map[string]NotificationHandler
}

// NewRouter creates an empty router instance.
func NewRouter() *Router <span class="cov6" title="88">{
        return &amp;Router{
                requestHandlers:      make(map[string]RequestHandler),
                notificationHandlers: make(map[string]NotificationHandler),
        }
}</span>

// RegisterRequest associates a handler with a JSON-RPC method name. Existing
// registrations are replaced.
func (r *Router) RegisterRequest(method string, handler RequestHandler) <span class="cov10" title="1144">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.requestHandlers[method] = handler
}</span>

// RegisterNotification associates a notification handler with a method name.
func (r *Router) RegisterNotification(method string, handler NotificationHandler) <span class="cov7" title="176">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.notificationHandlers[method] = handler
}</span>

// DispatchRequest routes a request message to the appropriate handler. It
// returns a JSON-RPC error response if validation fails or the method is
// unknown.
func (r *Router) DispatchRequest(ctx context.Context, msg RequestMessage) ResponseMessage <span class="cov5" title="24">{
        if err := ensureVersion(msg.JSONRPC); err != nil </span><span class="cov1" title="2">{
                return ErrorResponse(msg.ID, InvalidRequest, err.Error())
        }</span>

        <span class="cov4" title="22">r.mu.RLock()
        handler, ok := r.requestHandlers[msg.Method]
        r.mu.RUnlock()
        if !ok </span><span class="cov2" title="3">{
                return ErrorResponse(msg.ID, MethodNotFound, fmt.Sprintf("Method not found: %s", msg.Method))
        }</span>

        <span class="cov4" title="19">resp := handler(ctx, msg)
        if resp.JSONRPC == "" </span><span class="cov0" title="0">{
                resp.JSONRPC = JSONRPCVersion
        }</span>
        <span class="cov4" title="19">return resp</span>
}

// DispatchNotification routes a notification message. If validation fails or
// the method is unknown the handler returns an error for logging.
func (r *Router) DispatchNotification(ctx context.Context, msg NotificationMessage) error <span class="cov1" title="2">{
        if err := ensureVersion(msg.JSONRPC); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">r.mu.RLock()
        handler, ok := r.notificationHandlers[msg.Method]
        r.mu.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("notification handler not registered: %s", msg.Method)
        }</span>

        <span class="cov1" title="1">return handler(ctx, msg)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mcp

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// SafetyManager handles all safety-related operations
type SafetyManager struct {
        config     SafetyConfig
        fileLocks  map[string]*fileLock
        locksMutex sync.RWMutex
        txLog      *TransactionLog
}

// NewSafetyManager creates a new safety manager with the given config
func NewSafetyManager(config SafetyConfig) *SafetyManager <span class="cov5" title="124">{
        sm := &amp;SafetyManager{
                config:    config,
                fileLocks: make(map[string]*fileLock),
        }

        if config.TransactionLog </span><span class="cov4" title="87">{
                sm.txLog = NewTransactionLog()
        }</span>

        <span class="cov5" title="124">return sm</span>
}

// ValidateOperation checks if an operation meets safety requirements
func (sm *SafetyManager) ValidateOperation(op *SafetyOperation) error <span class="cov2" title="10">{
        // Check file count limits
        if len(op.Files) &gt; sm.config.MaxFiles </span><span class="cov1" title="2">{
                return NewMCPError(TooManyFiles,
                        fmt.Sprintf("Operation exceeds file limit: %d &gt; %d", len(op.Files), sm.config.MaxFiles),
                        map[string]any{
                                "requested": len(op.Files),
                                "limit":     sm.config.MaxFiles,
                        })
        }</span>

        // Check individual file sizes and total size
        <span class="cov2" title="7">var totalSize int64
        for _, file := range op.Files </span><span class="cov2" title="6">{
                if file.Size &gt; sm.config.MaxFileSize </span><span class="cov1" title="1">{
                        return NewMCPError(FileTooLarge,
                                fmt.Sprintf("File exceeds size limit: %s (%d bytes &gt; %d bytes)",
                                        file.Path, file.Size, sm.config.MaxFileSize),
                                map[string]any{
                                        "file":  file.Path,
                                        "size":  file.Size,
                                        "limit": sm.config.MaxFileSize,
                                })
                }</span>
                <span class="cov2" title="5">totalSize += file.Size</span>
        }

        <span class="cov2" title="6">if totalSize &gt; sm.config.MaxTotalSize </span><span class="cov1" title="1">{
                return NewMCPError(TotalSizeTooLarge,
                        fmt.Sprintf("Total operation size exceeds limit: %d &gt; %d", totalSize, sm.config.MaxTotalSize),
                        map[string]any{
                                "total": totalSize,
                                "limit": sm.config.MaxTotalSize,
                        })
        }</span>

        // Validate confidence based on mode
        <span class="cov2" title="5">switch sm.config.ConfidenceMode </span>{
        case "per_file":<span class="cov1" title="1">
                for _, file := range op.Files </span><span class="cov1" title="1">{
                        if file.Confidence &lt; sm.config.PerFileThreshold </span><span class="cov0" title="0">{
                                return NewMCPError(PerFileConfidenceLow,
                                        fmt.Sprintf("File confidence too low: %s (%.3f &lt; %.3f)",
                                                file.Path, file.Confidence, sm.config.PerFileThreshold),
                                        map[string]any{
                                                "file":       file.Path,
                                                "confidence": file.Confidence,
                                                "threshold":  sm.config.PerFileThreshold,
                                        })
                        }</span>
                }
        case "global":<span class="cov0" title="0">
                if op.GlobalConfidence &lt; sm.config.GlobalThreshold </span><span class="cov0" title="0">{
                        return NewMCPError(ConfidenceTooLow,
                                fmt.Sprintf("Global confidence too low: %.3f &lt; %.3f",
                                        op.GlobalConfidence, sm.config.GlobalThreshold))
                }</span>
        case "both":<span class="cov0" title="0">
                // Check both per-file and global
                for _, file := range op.Files </span><span class="cov0" title="0">{
                        if file.Confidence &lt; sm.config.PerFileThreshold </span><span class="cov0" title="0">{
                                return NewMCPError(PerFileConfidenceLow,
                                        fmt.Sprintf("File confidence too low: %s (%.3f &lt; %.3f)",
                                                file.Path, file.Confidence, sm.config.PerFileThreshold))
                        }</span>
                }
                <span class="cov0" title="0">if op.GlobalConfidence &lt; sm.config.GlobalThreshold </span><span class="cov0" title="0">{
                        return NewMCPError(ConfidenceTooLow,
                                fmt.Sprintf("Global confidence too low: %.3f &lt; %.3f",
                                        op.GlobalConfidence, sm.config.GlobalThreshold))
                }</span>
        }

        <span class="cov2" title="5">return nil</span>
}

// ValidateFileIntegrity checks if files haven't been modified externally
func (sm *SafetyManager) ValidateFileIntegrity(files []FileIntegrityCheck) error <span class="cov2" title="6">{
        if !sm.config.ValidateFileHashes </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="5">for _, file := range files </span><span class="cov2" title="5">{
                currentHash, err := calculateFileHash(file.Path)
                if err != nil </span><span class="cov1" title="1">{
                        return WrapError(FileSystemError,
                                fmt.Sprintf("Failed to calculate hash for %s", file.Path), err)
                }</span>

                <span class="cov2" title="4">if currentHash != file.ExpectedHash </span><span class="cov1" title="1">{
                        return NewMCPError(FileModified,
                                fmt.Sprintf("File was modified externally: %s", file.Path),
                                map[string]any{
                                        "file":     file.Path,
                                        "expected": file.ExpectedHash,
                                        "actual":   currentHash,
                                })
                }</span>
        }

        <span class="cov1" title="3">return nil</span>
}

// AtomicWrite performs an atomic write operation
func (sm *SafetyManager) AtomicWrite(path, content string) error <span class="cov3" title="19">{
        mode := os.FileMode(0o644)
        if info, err := os.Stat(path); err == nil </span><span class="cov1" title="2">{
                mode = info.Mode().Perm()
        }</span> else<span class="cov3" title="17"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return WrapError(FileSystemError, fmt.Sprintf("Failed to stat file %s", path), err)
        }</span>

        <span class="cov3" title="19">if !sm.config.AtomicWrites </span><span class="cov3" title="11">{
                // Fall back to regular write
                return os.WriteFile(path, []byte(content), mode)
        }</span>

        // Create temporary file with random suffix
        <span class="cov2" title="8">suffix, err := generateRandomSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return WrapError(AtomicWriteFailed, "Failed to generate random suffix", err)
        }</span>

        <span class="cov2" title="8">tmpPath := path + ".tmp." + suffix

        // Create backup if requested
        var backupPath string
        if sm.config.CreateBackups </span><span class="cov2" title="6">{
                backupPath = path + sm.config.BackupSuffix
                if err := sm.createBackup(path, backupPath); err != nil </span><span class="cov0" title="0">{
                        return WrapError(BackupFailed, "Failed to create backup", err)
                }</span>
        }

        // Write to temporary file
        <span class="cov2" title="8">if err := os.WriteFile(tmpPath, []byte(content), mode); err != nil </span><span class="cov1" title="1">{
                sm.cleanupFailedWrite(tmpPath, backupPath)
                return WrapError(AtomicWriteFailed, "Failed to write temporary file", err)
        }</span>

        // Fsync if requested
        <span class="cov2" title="7">if sm.config.UseFsync </span><span class="cov0" title="0">{
                if err := sm.syncFile(tmpPath); err != nil </span><span class="cov0" title="0">{
                        sm.cleanupFailedWrite(tmpPath, backupPath)
                        return WrapError(AtomicWriteFailed, "Failed to sync temporary file", err)
                }</span>
        }

        // Log transaction
        <span class="cov2" title="7">if sm.txLog != nil </span><span class="cov2" title="5">{
                txID := sm.txLog.BeginTransaction(path, tmpPath, backupPath)
                defer sm.txLog.CompleteTransaction(txID)
        }</span>

        // Atomic rename
        <span class="cov2" title="7">if err := os.Rename(tmpPath, path); err != nil </span><span class="cov0" title="0">{
                sm.cleanupFailedWrite(tmpPath, backupPath)
                return WrapError(AtomicWriteFailed, "Failed to rename temporary file", err)
        }</span>

        // Fsync directory if requested
        <span class="cov2" title="7">if sm.config.UseFsync </span><span class="cov0" title="0">{
                if err := sm.syncDir(filepath.Dir(path)); err != nil </span><span class="cov0" title="0">{
                        // File is already written, this is just a warning
                        fmt.Fprintf(os.Stderr, "Warning: Failed to sync directory: %v\n", err)
                }</span>
        }

        <span class="cov2" title="7">return nil</span>
}

// LockFile acquires an exclusive lock on a file
func (sm *SafetyManager) LockFile(path string) (*FileLock, error) <span class="cov2" title="10">{
        if path == "" </span><span class="cov1" title="1">{
                return nil, NewMCPError(InvalidParams, "File path cannot be empty")
        }</span>

        <span class="cov2" title="9">if !sm.config.FileLocking </span><span class="cov1" title="1">{
                return &amp;FileLock{path: path, manager: sm}, nil // No-op lock
        }</span>

        <span class="cov2" title="8">sm.locksMutex.Lock()
        defer sm.locksMutex.Unlock()

        // Check if already locked
        if _, exists := sm.fileLocks[path]; exists </span><span class="cov1" title="1">{
                return nil, NewMCPError(FileLocked,
                        fmt.Sprintf("File is already locked: %s", path))
        }</span>

        // Try to acquire OS-level lock
        <span class="cov2" title="7">lock, err := sm.acquireOSLock(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="6">sm.fileLocks[path] = lock
        return &amp;FileLock{path: path, manager: sm, osLock: lock}, nil</span>
}

// ReleaseLock releases a file lock
func (sm *SafetyManager) ReleaseLock(path string) error <span class="cov2" title="9">{
        if !sm.config.FileLocking </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="8">sm.locksMutex.Lock()
        defer sm.locksMutex.Unlock()

        lock, exists := sm.fileLocks[path]
        if !exists </span><span class="cov1" title="2">{
                return nil // Already released
        }</span>

        <span class="cov2" title="6">if err := lock.release(); err != nil </span><span class="cov0" title="0">{
                return WrapError(FileSystemError, "Failed to release file lock", err)
        }</span>

        <span class="cov2" title="6">delete(sm.fileLocks, path)
        return nil</span>
}

// acquireOSLock tries to acquire an OS-level file lock with timeout
func (sm *SafetyManager) acquireOSLock(path string) (*fileLock, error) <span class="cov2" title="9">{
        lockPath := path + ".lock"

        deadline := time.Now().Add(sm.config.LockTimeout)
        for time.Now().Before(deadline) </span><span class="cov10" title="31834">{
                file, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0o644)
                if err == nil </span><span class="cov2" title="7">{
                        // Successfully created lock file
                        lock := &amp;fileLock{
                                path:     lockPath,
                                file:     file,
                                acquired: time.Now(),
                        }

                        // Write PID to lock file
                        fmt.Fprintf(file, "%d\n", os.Getpid())
                        file.Sync()

                        return lock, nil
                }</span>

                // Check if lock is stale
                <span class="cov9" title="31827">if sm.isLockStale(lockPath) </span><span class="cov9" title="31825">{
                        os.Remove(lockPath) // Remove stale lock
                        continue</span>
                }

                // Wait a bit before retrying
                <span class="cov1" title="2">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov1" title="2">return nil, NewMCPError(LockTimeout,
                fmt.Sprintf("Could not acquire lock for %s within %v", path, sm.config.LockTimeout))</span>
}

// isLockStale checks if a lock file is stale (process no longer exists)
func (sm *SafetyManager) isLockStale(lockPath string) bool <span class="cov9" title="31831">{
        content, err := os.ReadFile(lockPath)
        if err != nil </span><span class="cov9" title="31826">{
                return true // Can't read = stale
        }</span>

        <span class="cov2" title="5">var pid int
        if n, err := fmt.Sscanf(string(content), "%d", &amp;pid); err != nil || n != 1 </span><span class="cov1" title="1">{
                return true // Invalid format = stale
        }</span>

        <span class="cov2" title="4">return !isProcessAlive(pid)</span>
}

// Helper functions

func (sm *SafetyManager) createBackup(src, dst string) error <span class="cov2" title="8">{
        info, err := os.Stat(src)
        if err != nil </span><span class="cov2" title="6">{
                if os.IsNotExist(err) </span><span class="cov2" title="6">{
                        return nil // No file to backup
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="2">content, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="2">mode := info.Mode().Perm()
        if mode == 0 </span><span class="cov0" title="0">{
                mode = 0o644
        }</span>
        <span class="cov1" title="2">if err := os.WriteFile(dst, content, mode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="2">return os.Chmod(dst, mode)</span>
}

func (sm *SafetyManager) cleanupFailedWrite(tmpPath, backupPath string) <span class="cov1" title="3">{
        os.Remove(tmpPath)
        if backupPath != "" </span><span class="cov1" title="3">{
                os.Remove(backupPath)
        }</span>
}

func (sm *SafetyManager) syncFile(path string) error <span class="cov1" title="2">{
        file, err := os.OpenFile(path, os.O_WRONLY, 0)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()
        return file.Sync()</span>
}

func (sm *SafetyManager) syncDir(path string) error <span class="cov1" title="2">{
        dir, err := os.Open(path)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">defer dir.Close()
        return dir.Sync()</span>
}

// calculateFileHash computes SHA256 hash of a file
func calculateFileHash(path string) (string, error) <span class="cov2" title="8">{
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="2">{
                return "", err
        }</span>
        <span class="cov2" title="6">hash := sha256.Sum256(content)
        return hex.EncodeToString(hash[:]), nil</span>
}

// generateRandomSuffix creates a random suffix for temporary files
func generateRandomSuffix() (string, error) <span class="cov3" title="15">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov3" title="15">return hex.EncodeToString(bytes), nil</span>
}

// Data structures

type SafetyOperation struct {
        Files            []SafetyFile `json:"files"`
        GlobalConfidence float64      `json:"global_confidence"`
}

type SafetyFile struct {
        Path       string  `json:"path"`
        Size       int64   `json:"size"`
        Confidence float64 `json:"confidence"`
}

type FileIntegrityCheck struct {
        Path         string `json:"path"`
        ExpectedHash string `json:"expected_hash"`
}

type FileLock struct {
        path    string
        manager *SafetyManager
        osLock  *fileLock
}

func (fl *FileLock) Release() error <span class="cov0" title="0">{
        if fl.manager != nil </span><span class="cov0" title="0">{
                return fl.manager.ReleaseLock(fl.path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type fileLock struct {
        path     string
        file     *os.File
        acquired time.Time
}

func (fl *fileLock) release() error <span class="cov2" title="7">{
        if fl.file != nil </span><span class="cov2" title="7">{
                fl.file.Close()
                return os.Remove(fl.path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//go:build !windows

package mcp

import (
        "os"
        "syscall"
)

func isProcessAlive(pid int) bool <span class="cov10" title="4">{
        if pid &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="4">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="4">return process.Signal(syscall.Signal(0)) == nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package mcp

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "sync"
        "sync/atomic"

        "gorm.io/gorm"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/db"
        "github.com/termfx/morfx/mcp/prompts"
        "github.com/termfx/morfx/mcp/resources"
        "github.com/termfx/morfx/mcp/tools"
        "github.com/termfx/morfx/mcp/types"
        "github.com/termfx/morfx/models"
        "github.com/termfx/morfx/providers"
        "github.com/termfx/morfx/providers/golang"
        "github.com/termfx/morfx/providers/javascript"
        "github.com/termfx/morfx/providers/php"
        "github.com/termfx/morfx/providers/python"
        "github.com/termfx/morfx/providers/typescript"
)

// StdioServer handles MCP communication over stdio
type StdioServer struct {
        config Config
        db     *gorm.DB

        reader  *bufio.Reader
        writer  *bufio.Writer
        writeMu sync.Mutex

        // Modular registries
        toolRegistry             *ToolRegistry
        promptRegistry           *PromptRegistry
        resourceRegistry         *ResourceRegistry
        resourceTemplateRegistry *ResourceTemplateRegistry
        router                   *Router
        sessionState             *SessionState

        // Provider registry
        providers *providers.Registry

        // File processor for filesystem operations
        fileProcessor *core.FileProcessor

        // Session tracking
        session *models.Session

        // Staging manager
        staging *StagingManager

        // Safety manager
        safety *SafetyManager

        // Debug logging
        debugLog func(format string, args ...any)

        // Pending request tracking for server-initiated workflows
        pendingMu sync.Mutex
        pending   map[string]chan ResponseMessage
        idCounter atomic.Uint64

        // In-flight request cancellation tracking
        inflightMu      sync.Mutex
        inflightCancels map[string]context.CancelFunc

        // Resource subscription management
        resourceSubsMu    sync.Mutex
        resourceSubs      map[string]map[string]*resourceSubscription
        resourceSubIDSeed atomic.Uint64

        inboundCount  atomic.Int64
        outboundCount atomic.Int64
}

type resourceSubscription struct {
        cancel context.CancelFunc
}

// MCPMetrics captures lightweight counters for observability.
type MCPMetrics struct {
        InboundMessages  int64 `json:"inbound_messages"`
        OutboundMessages int64 `json:"outbound_messages"`
        PendingRequests  int   `json:"pending_requests"`
}

// NewStdioServer creates a new MCP server that communicates over stdio
func NewStdioServer(config Config) (*StdioServer, error) <span class="cov6" title="88">{
        server := &amp;StdioServer{
                config:          config,
                reader:          bufio.NewReader(os.Stdin),
                writer:          bufio.NewWriter(os.Stdout),
                providers:       providers.NewRegistry(),
                router:          NewRouter(),
                sessionState:    NewSessionState(),
                pending:         make(map[string]chan ResponseMessage),
                inflightCancels: make(map[string]context.CancelFunc),
                resourceSubs:    make(map[string]map[string]*resourceSubscription),
        }

        // Initialize modular registries
        server.toolRegistry = NewToolRegistry(server)
        server.promptRegistry = NewPromptRegistry()
        server.resourceRegistry = NewResourceRegistry()
        server.resourceTemplateRegistry = NewResourceTemplateRegistry()

        // Set debug logger
        logWriter := config.LogWriter
        if logWriter == nil </span><span class="cov1" title="1">{
                logWriter = os.Stderr
        }</span>

        <span class="cov6" title="88">if config.Debug </span><span class="cov2" title="3">{
                server.debugLog = func(format string, args ...any) </span><span class="cov5" title="29">{
                        fmt.Fprintf(logWriter, "[DEBUG] "+format+"\n", args...)
                }</span>
        } else<span class="cov6" title="85"> {
                server.debugLog = func(format string, args ...any) </span>{<span class="cov9" title="751">}</span>
        }

        // Initialize database if URL provided
        <span class="cov6" title="88">if config.DatabaseURL != "" &amp;&amp; config.DatabaseURL != "skip" </span><span class="cov2" title="4">{
                database, err := db.Connect(config.DatabaseURL, config.Debug)
                if err != nil </span><span class="cov1" title="1">{
                        // Log the error but continue without database for better compatibility
                        server.debugLog("Database connection failed, continuing without persistence: %v", err)
                        // Don't fail the server initialization - just continue without database features
                        // Explicitly set these to nil to ensure clean state
                        server.db = nil
                        server.session = nil
                        server.staging = nil
                }</span> else<span class="cov2" title="3"> {
                        server.db = database

                        // Create session
                        session := &amp;models.Session{
                                ID: generateSessionID(),
                        }
                        if err := server.db.Create(session).Error; err != nil </span><span class="cov0" title="0">{
                                server.debugLog("Failed to create session: %v", err)
                                server.session = nil
                        }</span> else<span class="cov2" title="3"> {
                                server.session = session
                                server.debugLog("Session created: %s", session.ID)
                        }</span>

                        // Initialize staging manager only if we have a working database
                        <span class="cov2" title="3">if server.db != nil </span><span class="cov2" title="3">{
                                server.staging = NewStagingManager(server.db, config)
                        }</span>
                }
        }

        // NEW: Initialize modular registries
        <span class="cov6" title="88">tools.Init(server)
        prompts.Init()
        resources.Init()
        registerDefaultResourceTemplates(server.resourceTemplateRegistry)
        server.debugLog("Initialized modular components")

        // Mirror global tool registrations into the server registry for legacy handlers
        for _, tool := range tools.Registry.List() </span><span class="cov9" title="880">{
                server.toolRegistry.Register(tool.Name(), tool)
        }</span>

        // Register providers
        <span class="cov6" title="88">server.providers.Register(golang.New())
        server.debugLog("Registered Go provider")

        server.providers.Register(javascript.New())
        server.debugLog("Registered JavaScript provider")

        server.providers.Register(typescript.New())
        server.debugLog("Registered TypeScript provider")

        server.providers.Register(php.New())
        server.debugLog("Registered PHP provider")

        server.providers.Register(python.New())
        server.debugLog("Registered Python provider")

        // Register dynamic spec resource via standard resources endpoint
        resources.Registry.Register("config://query-spec", resources.NewDynamicResource(
                "Query Spec",
                "Supported languages and query types",
                "config://query-spec",
                "application/json",
                func() (string, error) </span><span class="cov3" title="7">{
                        // Build JSON spec dynamically
                        type langSpec struct {
                                Language   string   `json:"language"`
                                Extensions []string `json:"extensions"`
                                Types      []string `json:"types"`
                        }
                        providersList := server.providers.Languages()
                        // sort is not critical; keep order short
                        var specs []langSpec
                        for _, lang := range providersList </span><span class="cov5" title="35">{
                                if p, ok := server.providers.Get(lang); ok </span><span class="cov5" title="35">{
                                        specs = append(specs, langSpec{
                                                Language:   p.Language(),
                                                Extensions: p.Extensions(),
                                                Types:      p.SupportedQueryTypes(),
                                        })
                                }</span>
                        }
                        <span class="cov3" title="7">b, _ := json.MarshalIndent(specs, "", "  ")
                        return string(b), nil</span>
                },
        ))

        // Initialize file processor with providers
        <span class="cov6" title="88">server.fileProcessor = core.NewFileProcessor(&amp;providerRegistryAdapter{server.providers})
        server.debugLog("Initialized file processor")

        // Initialize safety manager
        server.safety = NewSafetyManager(config.Safety)
        server.debugLog("Initialized safety manager")

        // Register request/notification handlers with the router
        server.registerHandlers()

        return server, nil</span>
}

// providerRegistryAdapter adapts providers.Registry to core.ProviderRegistry
type providerRegistryAdapter struct {
        *providers.Registry
}

func (pra *providerRegistryAdapter) Get(language string) (core.Provider, bool) <span class="cov1" title="2">{
        provider, exists := pra.Registry.Get(language)
        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>
        <span class="cov1" title="1">return &amp;providerAdapter{provider}, true</span>
}

// providerAdapter adapts providers.Provider to core.Provider
type providerAdapter struct {
        providers.Provider
}

func (pa *providerAdapter) Language() string <span class="cov1" title="1">{
        return pa.Provider.Language()
}</span>

func (pa *providerAdapter) Query(source string, query core.AgentQuery) core.QueryResult <span class="cov0" title="0">{
        return pa.Provider.Query(source, query)
}</span>

func (pa *providerAdapter) Transform(source string, op core.TransformOp) core.TransformResult <span class="cov0" title="0">{
        return pa.Provider.Transform(source, op)
}</span>

func (s *StdioServer) registerHandlers() <span class="cov6" title="88">{
        s.router.RegisterRequest("initialize", s.wrapRequestHandler(s.handleInitialize))
        s.router.RegisterRequest("initialized", s.wrapRequestHandler(s.handleInitialized))
        s.router.RegisterNotification("notifications/initialized", s.wrapNotificationHandler(s.handleInitialized))
        s.router.RegisterRequest("ping", s.wrapRequestHandler(s.handlePing))
        s.router.RegisterRequest("tools/list", s.wrapRequestHandler(s.handleListTools))
        s.router.RegisterRequest("tools/call", s.wrapRequestHandler(s.handleCallTool))
        s.router.RegisterRequest("prompts/list", s.wrapRequestHandler(s.handleListPrompts))
        s.router.RegisterRequest("prompts/get", s.wrapRequestHandler(s.handleGetPrompt))
        s.router.RegisterRequest("resources/list", s.wrapRequestHandler(s.handleListResources))
        s.router.RegisterRequest("resources/read", s.wrapRequestHandler(s.handleReadResource))
        s.router.RegisterRequest("resources/templates/list", s.wrapRequestHandler(s.handleListResourceTemplates))
        s.router.RegisterRequest("resources/subscribe", s.wrapRequestHandler(s.handleSubscribeResource))
        s.router.RegisterRequest("resources/unsubscribe", s.wrapRequestHandler(s.handleUnsubscribeResource))
        s.router.RegisterRequest("logging/setLevel", s.wrapRequestHandler(s.handleSetLoggingLevel))
        s.router.RegisterNotification("notifications/cancelled", s.handleCancelledNotification)
}</span>

func (s *StdioServer) wrapRequestHandler(fn func(context.Context, Request) Response) RequestHandler <span class="cov10" title="1144">{
        return func(ctx context.Context, msg RequestMessage) ResponseMessage </span><span class="cov4" title="19">{
                reqID := stringifyID(msg.ID)
                progressToken, _ := msg.Meta.ProgressToken()
                keys := []string{reqID}
                if progressToken != "" </span><span class="cov2" title="4">{
                        keys = append(keys, progressToken)
                }</span>

                <span class="cov4" title="19">reqCtx, cancel := context.WithCancel(ctx)
                if progressToken != "" </span><span class="cov2" title="4">{
                        reqCtx = withProgressToken(reqCtx, progressToken)
                }</span>
                <span class="cov4" title="19">if len(keys) &gt; 0 </span><span class="cov4" title="19">{
                        s.registerCancellation(cancel, keys...)
                        defer func() </span><span class="cov4" title="19">{
                                s.clearCancellation(keys...)
                                cancel()
                        }</span>()
                } else<span class="cov0" title="0"> {
                        defer cancel()
                }</span>

                <span class="cov4" title="19">return fn(reqCtx, msg)</span>
        }
}

func (s *StdioServer) wrapNotificationHandler(fn func(context.Context, Request) Response) NotificationHandler <span class="cov6" title="88">{
        return func(ctx context.Context, msg NotificationMessage) error </span><span class="cov0" title="0">{
                req := RequestMessage{
                        JSONRPC: msg.JSONRPC,
                        Meta:    msg.Meta,
                        Method:  msg.Method,
                        Params:  msg.Params,
                }
                fn(ctx, req)
                return nil
        }</span>
}

// handleRequest is retained for tests that exercise legacy routing behaviour.
// It delegates to the router using a background context.
func (s *StdioServer) handleRequest(req Request) Response <span class="cov4" title="18">{
        return s.router.DispatchRequest(context.Background(), req)
}</span>

// Start begins processing JSON-RPC requests from stdin
func (s *StdioServer) Start() error <span class="cov3" title="5">{
        sessionID := ""
        if s.session != nil </span><span class="cov0" title="0">{
                sessionID = s.session.ID
        }</span>
        <span class="cov3" title="5">s.debugLog("MCP server started, session: %s", sessionID)

        decoder := json.NewDecoder(s.reader)

        for </span><span class="cov3" title="9">{
                var raw json.RawMessage
                err := decoder.Decode(&amp;raw)
                if err == io.EOF </span><span class="cov3" title="5">{
                        s.debugLog("EOF received, shutting down gracefully")
                        return nil
                }</span>
                <span class="cov2" title="4">if err != nil </span><span class="cov1" title="1">{
                        if err == io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                                s.debugLog("Unexpected EOF, waiting for more data")
                                continue</span>
                        }
                        <span class="cov1" title="1">s.debugLog("JSON decode error: %v", err)
                        s.sendResponse(ErrorResponse(nil, ParseError, err.Error()))
                        decoder = json.NewDecoder(s.reader)
                        continue</span>
                }

                <span class="cov2" title="3">rawStr := string(raw)
                if len(rawStr) &gt; 512 </span><span class="cov0" title="0">{
                        rawStr = rawStr[:512] + "..."
                }</span>
                <span class="cov2" title="3">s.debugLog("Received: %s", rawStr)
                s.inboundCount.Add(1)

                var envelope struct {
                        JSONRPC string           `json:"jsonrpc"`
                        ID      *json.RawMessage `json:"id"`
                        Method  string           `json:"method"`
                }

                if err := json.Unmarshal(raw, &amp;envelope); err != nil </span><span class="cov0" title="0">{
                        s.debugLog("Failed to parse message envelope: %v", err)
                        s.sendResponse(ErrorResponse(nil, ParseError, "Invalid JSON-RPC message"))
                        continue</span>
                }

                <span class="cov2" title="3">ctx := context.Background()

                if envelope.ID != nil </span><span class="cov1" title="2">{
                        if envelope.Method == "" </span><span class="cov0" title="0">{
                                var resp ResponseMessage
                                if err := json.Unmarshal(raw, &amp;resp); err != nil </span><span class="cov0" title="0">{
                                        s.debugLog("Failed to parse response: %v", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if !s.resolvePendingResponse(resp) </span><span class="cov0" title="0">{
                                        s.debugLog("No pending request for response id: %v", resp.ID)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov1" title="2">var req RequestMessage
                        if err := json.Unmarshal(raw, &amp;req); err != nil </span><span class="cov0" title="0">{
                                s.debugLog("Failed to parse request: %v", err)
                                s.sendResponse(ErrorResponse(nil, ParseError, "Invalid request"))
                                continue</span>
                        }
                        <span class="cov1" title="2">ctx := context.WithValue(ctx, requestContextKey, req)
                        resp := s.router.DispatchRequest(ctx, req)
                        s.sendResponse(resp)
                        continue</span>
                }

                <span class="cov1" title="1">var note NotificationMessage
                if err := json.Unmarshal(raw, &amp;note); err != nil </span><span class="cov0" title="0">{
                        s.debugLog("Failed to parse notification: %v", err)
                        continue</span>
                }
                <span class="cov1" title="1">if err := s.router.DispatchNotification(ctx, note); err != nil </span><span class="cov1" title="1">{
                        s.debugLog("Notification dispatch error: %v", err)
                }</span>
        }
}

// sendResponse writes a response to stdout
func (s *StdioServer) sendResponse(resp Response) <span class="cov2" title="4">{
        data, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                s.debugLog("Failed to marshal response: %v", err)
                return
        }</span>

        <span class="cov2" title="4">s.debugLog("Sending: %s", string(data))
        s.writeFrame(data)</span>
}

func (s *StdioServer) sendRequestMessage(req RequestMessage) error <span class="cov4" title="15">{
        data, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov4" title="15">if len(data) &gt; 512 </span><span class="cov0" title="0">{
                s.debugLog("Sending request %v...", string(data[:512]))
        }</span> else<span class="cov4" title="15"> {
                s.debugLog("Sending request: %s", string(data))
        }</span>

        <span class="cov4" title="15">s.writeFrame(data)
        return nil</span>
}

func (s *StdioServer) writeFrame(data []byte) <span class="cov6" title="71">{
        s.writeMu.Lock()
        defer s.writeMu.Unlock()

        fmt.Fprintf(s.writer, "%s\n", data)
        s.outboundCount.Add(1)
        _ = s.writer.Flush()
}</span>

func (s *StdioServer) resolvePendingResponse(resp ResponseMessage) bool <span class="cov3" title="9">{
        id := stringifyID(resp.ID)
        if id == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="9">s.pendingMu.Lock()
        ch, ok := s.pending[id]
        if ok </span><span class="cov3" title="9">{
                delete(s.pending, id)
        }</span>
        <span class="cov3" title="9">s.pendingMu.Unlock()

        if ok </span><span class="cov3" title="9">{
                ch &lt;- resp
                close(ch)
        }</span>
        <span class="cov3" title="9">return ok</span>
}

// Metrics exposes lightweight counters useful for debugging and observability.
func (s *StdioServer) Metrics() MCPMetrics <span class="cov0" title="0">{
        s.pendingMu.Lock()
        pending := len(s.pending)
        s.pendingMu.Unlock()

        return MCPMetrics{
                InboundMessages:  s.inboundCount.Load(),
                OutboundMessages: s.outboundCount.Load(),
                PendingRequests:  pending,
        }
}</span>

func stringifyID(id any) string <span class="cov5" title="28">{
        switch v := id.(type) </span>{
        case string:<span class="cov4" title="13">
                return v</span>
        case json.Number:<span class="cov0" title="0">
                return v.String()</span>
        case float64:<span class="cov0" title="0">
                return fmt.Sprintf("%.0f", v)</span>
        case int:<span class="cov3" title="9">
                return fmt.Sprintf("%d", v)</span>
        case int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case nil:<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov3" title="6">
                return fmt.Sprintf("%v", v)</span>
        }
}

func (s *StdioServer) registerCancellation(cancel context.CancelFunc, keys ...string) <span class="cov4" title="19">{
        if cancel == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="19">s.inflightMu.Lock()
        for _, key := range keys </span><span class="cov5" title="23">{
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="23">s.inflightCancels[key] = cancel</span>
        }
        <span class="cov4" title="19">s.inflightMu.Unlock()</span>
}

func (s *StdioServer) clearCancellation(keys ...string) <span class="cov4" title="19">{
        s.inflightMu.Lock()
        for _, key := range keys </span><span class="cov5" title="23">{
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="23">delete(s.inflightCancels, key)</span>
        }
        <span class="cov4" title="19">s.inflightMu.Unlock()</span>
}

func (s *StdioServer) cancelByKey(key string) bool <span class="cov1" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">s.inflightMu.Lock()
        cancel, ok := s.inflightCancels[key]
        if ok </span><span class="cov1" title="1">{
                delete(s.inflightCancels, key)
        }</span>
        <span class="cov1" title="1">s.inflightMu.Unlock()

        if ok &amp;&amp; cancel != nil </span><span class="cov1" title="1">{
                cancel()
        }</span>
        <span class="cov1" title="1">return ok</span>
}

// callClient sends a JSON-RPC request to the client and waits for a response.
func (s *StdioServer) callClient(ctx context.Context, method string, params any, meta Meta) (ResponseMessage, error) <span class="cov4" title="15">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov4" title="15">id := fmt.Sprintf("srv-%d", s.idCounter.Add(1))
        resultCh := make(chan ResponseMessage, 1)

        s.pendingMu.Lock()
        s.pending[id] = resultCh
        s.pendingMu.Unlock()

        req, err := NewRequestMessage(id, method, params)
        if err != nil </span><span class="cov0" title="0">{
                s.pendingMu.Lock()
                delete(s.pending, id)
                s.pendingMu.Unlock()
                return ResponseMessage{}, err
        }</span>
        <span class="cov4" title="15">req.Meta = meta
        progressToken, _ := meta.ProgressToken()

        if err := s.sendRequestMessage(req); err != nil </span><span class="cov0" title="0">{
                s.pendingMu.Lock()
                delete(s.pending, id)
                s.pendingMu.Unlock()
                return ResponseMessage{}, err
        }</span>

        <span class="cov4" title="15">select </span>{
        case resp := &lt;-resultCh:<span class="cov3" title="9">
                return resp, nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="2">
                s.pendingMu.Lock()
                if ch, ok := s.pending[id]; ok </span><span class="cov1" title="2">{
                        delete(s.pending, id)
                        close(ch)
                }</span>
                <span class="cov1" title="2">s.pendingMu.Unlock()
                s.sendCancelledNotification(id, progressToken)
                return ResponseMessage{}, ctx.Err()</span>
        }
}

// RequestSamplingMessage asks the client to generate a sampling message per MCP spec.
func (s *StdioServer) RequestSamplingMessage(ctx context.Context, params any, meta Meta) (ResponseMessage, error) <span class="cov3" title="5">{
        return s.callClient(ctx, "sampling/createMessage", params, meta)
}</span>

// RequestSampling requests a sampling message from the client and records it.
func (s *StdioServer) RequestSampling(ctx context.Context, params map[string]any) (map[string]any, error) <span class="cov3" title="5">{
        if params == nil </span><span class="cov0" title="0">{
                params = make(map[string]any)
        }</span>
        <span class="cov3" title="5">meta := Meta{}
        if token, ok := progressTokenFromContext(ctx); ok </span><span class="cov3" title="5">{
                meta = meta.WithProgressToken(token)
        }</span>

        <span class="cov3" title="5">resp, err := s.RequestSamplingMessage(ctx, params, meta)
        if err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov2" title="3">if resp.Error != nil </span><span class="cov0" title="0">{
                if resp.Error.Code == MethodNotFound </span><span class="cov0" title="0">{
                        s.debugLog("Client does not support sampling/createMessage; skipping")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("sampling error: %s", resp.Error.Message)</span>
        }

        <span class="cov2" title="3">result := normalizeResponseMap(resp.Result)
        s.sessionState.AppendSamplingRecord(params, result)
        return result, nil</span>
}

// sendElicitationRequest triggers an elicitation/create workflow on the client.
func (s *StdioServer) sendElicitationRequest(ctx context.Context, params any, meta Meta) (ResponseMessage, error) <span class="cov3" title="5">{
        return s.callClient(ctx, "elicitation/create", params, meta)
}</span>

// RequestElicitation requests an elicitation flow and records the interaction.
func (s *StdioServer) RequestElicitation(ctx context.Context, params map[string]any) (map[string]any, error) <span class="cov3" title="5">{
        if params == nil </span><span class="cov0" title="0">{
                params = make(map[string]any)
        }</span>
        <span class="cov3" title="5">meta := Meta{}
        if token, ok := progressTokenFromContext(ctx); ok </span><span class="cov3" title="5">{
                meta = meta.WithProgressToken(token)
        }</span>

        <span class="cov3" title="5">resp, err := s.sendElicitationRequest(ctx, params, meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="5">if resp.Error != nil </span><span class="cov1" title="1">{
                if resp.Error.Code == MethodNotFound </span><span class="cov1" title="1">{
                        s.debugLog("Client does not support elicitation/create; continuing without confirmation")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("elicitation error: %s", resp.Error.Message)</span>
        }

        <span class="cov2" title="4">result := normalizeResponseMap(resp.Result)
        s.sessionState.AppendElicitationRecord(params, result)
        return result, nil</span>
}

// RequestRoots negotiates shared roots/list with the client.
func (s *StdioServer) RequestRoots(ctx context.Context, params any, meta Meta) (ResponseMessage, error) <span class="cov3" title="5">{
        return s.callClient(ctx, "roots/list", params, meta)
}</span>

func (s *StdioServer) handleCancelledNotification(ctx context.Context, msg NotificationMessage) error <span class="cov1" title="1">{
        var params struct {
                RequestID     string `json:"requestId,omitempty"`
                ProgressToken string `json:"progressToken,omitempty"`
        }

        if len(msg.Params) &gt; 0 </span><span class="cov1" title="1">{
                if err := json.Unmarshal(msg.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.debugLog("Invalid cancellation payload: %v", err)
                        return nil
                }</span>
        }

        <span class="cov1" title="1">handled := false
        if params.ProgressToken != "" </span><span class="cov1" title="1">{
                handled = s.cancelByKey(params.ProgressToken) || handled
        }</span>
        <span class="cov1" title="1">if params.RequestID != "" </span><span class="cov0" title="0">{
                handled = s.cancelByKey(params.RequestID) || handled
        }</span>

        <span class="cov1" title="1">if !handled </span><span class="cov0" title="0">{
                s.debugLog("Cancellation received for unknown key: token=%s id=%s", params.ProgressToken, params.RequestID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RegisterTool adds or overrides a tool handler in the modular registry.
// Primarily used in tests to stub tool behavior.
func (s *StdioServer) RegisterTool(name string, handler types.ToolHandler) <span class="cov3" title="5">{
        customTool := tools.NewTool(name).
                WithDescription("Custom tool registered at runtime").
                WithInputSchema(map[string]any{"type": "object"}).
                WithHandler(handler).
                Build()

        s.toolRegistry.Register(name, customTool)
}</span>

// RegisterResource adds or overrides a resource in the server registry.
func (s *StdioServer) RegisterResource(resource types.Resource) <span class="cov1" title="1">{
        if resource == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">s.resourceRegistry.Register(resource.URI(), resource)
        s.sendResourceListChangedNotification()</span>
}

// Close cleans up resources
func (s *StdioServer) Close() error <span class="cov5" title="24">{
        if s.db != nil </span><span class="cov1" title="2">{
                sqlDB, err := s.db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">return sqlDB.Close()</span>
        }
        <span class="cov4" title="22">return nil</span>
}

func normalizeResponseMap(result any) map[string]any <span class="cov3" title="7">{
        if result == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="7">if existing, ok := result.(map[string]any); ok </span><span class="cov3" title="7">{
                return existing
        }</span>
        <span class="cov0" title="0">if raw, err := json.Marshal(result); err == nil </span><span class="cov0" title="0">{
                var decoded map[string]any
                if err := json.Unmarshal(raw, &amp;decoded); err == nil </span><span class="cov0" title="0">{
                        return decoded
                }</span>
        }
        <span class="cov0" title="0">return map[string]any{"value": result}</span>
}

func (s *StdioServer) addResourceSubscription(uri string, cancel context.CancelFunc) string <span class="cov1" title="1">{
        if cancel == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">id := fmt.Sprintf("res-sub-%d", s.resourceSubIDSeed.Add(1))
        s.resourceSubsMu.Lock()
        if _, ok := s.resourceSubs[uri]; !ok </span><span class="cov1" title="1">{
                s.resourceSubs[uri] = make(map[string]*resourceSubscription)
        }</span>
        <span class="cov1" title="1">s.resourceSubs[uri][id] = &amp;resourceSubscription{cancel: cancel}
        s.resourceSubsMu.Unlock()
        return id</span>
}

func (s *StdioServer) removeResourceSubscription(uri, id string) <span class="cov1" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">s.resourceSubsMu.Lock()
        defer s.resourceSubsMu.Unlock()
        if subs, ok := s.resourceSubs[uri]; ok </span><span class="cov0" title="0">{
                delete(subs, id)
                if len(subs) == 0 </span><span class="cov0" title="0">{
                        delete(s.resourceSubs, uri)
                }</span>
        }
}

func (s *StdioServer) cancelResourceSubscription(uri, id string) <span class="cov1" title="1">{
        s.resourceSubsMu.Lock()
        sub, ok := s.resourceSubs[uri][id]
        if ok </span><span class="cov1" title="1">{
                delete(s.resourceSubs[uri], id)
                if len(s.resourceSubs[uri]) == 0 </span><span class="cov1" title="1">{
                        delete(s.resourceSubs, uri)
                }</span>
        }
        <span class="cov1" title="1">s.resourceSubsMu.Unlock()
        if ok &amp;&amp; sub != nil &amp;&amp; sub.cancel != nil </span><span class="cov1" title="1">{
                sub.cancel()
        }</span>
}

func (s *StdioServer) cancelAllResourceSubscriptions(uri string) <span class="cov1" title="1">{
        s.resourceSubsMu.Lock()
        subs := s.resourceSubs[uri]
        delete(s.resourceSubs, uri)
        s.resourceSubsMu.Unlock()
        for _, sub := range subs </span><span class="cov0" title="0">{
                if sub != nil &amp;&amp; sub.cancel != nil </span><span class="cov0" title="0">{
                        sub.cancel()
                }</span>
        }
}

func (s *StdioServer) forwardResourceUpdates(uri, id string, updates &lt;-chan types.ResourceUpdate, cancel context.CancelFunc) <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                if cancel != nil </span><span class="cov1" title="1">{
                        cancel()
                }</span>
                <span class="cov1" title="1">s.removeResourceSubscription(uri, id)</span>
        }()

        <span class="cov1" title="1">if updates == nil </span><span class="cov0" title="0">{
                s.debugLog("resource %s watcher returned nil channel", uri)
                return
        }</span>

        <span class="cov1" title="1">for update := range updates </span><span class="cov1" title="1">{
                target := update.URI
                if target == "" </span><span class="cov0" title="0">{
                        target = uri
                }</span>
                <span class="cov1" title="1">switch update.Type </span>{
                case types.ResourceUpdateTypeListChanged:<span class="cov0" title="0">
                        s.sendResourceListChangedNotification()</span>
                case types.ResourceUpdateTypeRemoved:<span class="cov0" title="0">
                        if target != "" </span><span class="cov0" title="0">{
                                s.sendResourceUpdatedNotification(target)
                        }</span>
                        <span class="cov0" title="0">s.sendResourceListChangedNotification()</span>
                default:<span class="cov1" title="1">
                        if target != "" </span><span class="cov1" title="1">{
                                s.sendResourceUpdatedNotification(target)
                        }</span>
                }
        }
}

type contextKey string

const requestContextKey contextKey = "mcp_request_message"
</pre>
		
		<pre class="file" id="file29" style="display: none">package mcp

import (
        "context"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
        "github.com/termfx/morfx/providers"
)

// ServerInterface is now an alias to types.ServerInterface
type ServerInterface = types.ServerInterface

// Ensure StdioServer implements ServerInterface
var _ types.ServerInterface = (*StdioServer)(nil)

// GetProviders returns the provider registry
func (s *StdioServer) GetProviders() *providers.Registry <span class="cov6" title="9">{
        return s.providers
}</span>

// GetFileProcessor returns the file processor
func (s *StdioServer) GetFileProcessor() *core.FileProcessor <span class="cov0" title="0">{
        return s.fileProcessor
}</span>

// GetStaging returns the staging manager
func (s *StdioServer) GetStaging() any <span class="cov2" title="2">{
        if s.staging == nil </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.staging</span>
}

// GetSafety returns the safety manager
func (s *StdioServer) GetSafety() any <span class="cov0" title="0">{
        if s.safety == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.safety</span>
}

// ReportProgress emits a progress notification if the context carries a token.
func (s *StdioServer) ReportProgress(ctx context.Context, progress, total float64, message string) <span class="cov10" title="46">{
        if token, ok := progressTokenFromContext(ctx); ok </span><span class="cov8" title="23">{
                s.sendProgressNotification(token, progress, total, message)
        }</span>
}

// ConfirmApply requests client confirmation before applying staged changes.
func (s *StdioServer) ConfirmApply(ctx context.Context, summary string) error <span class="cov4" title="4">{
        params := map[string]any{
                "title": "Apply staged changes",
                "prompt": []map[string]any{
                        {
                                "role": "assistant",
                                "content": []map[string]any{
                                        {
                                                "type": "text",
                                                "text": summary,
                                        },
                                },
                        },
                },
                "choices": []map[string]any{
                        {"label": "Apply changes", "value": "confirm"},
                        {"label": "Cancel", "value": "cancel"},
                },
        }

        result, err := s.RequestElicitation(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="4">if result != nil </span><span class="cov3" title="3">{
                if choice, ok := result["choice"].(string); ok &amp;&amp; choice == "cancel" </span><span class="cov0" title="0">{
                        return context.Canceled
                }</span>
        }

        <span class="cov4" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package mcp

import (
        "sync"
        "time"

        "github.com/termfx/morfx/mcp/types"
)

// SessionState captures negotiated protocol details and client preferences for
// the active MCP connection.
type SessionState struct {
        mu                 sync.RWMutex
        initialized        bool
        protocolVersion    string
        clientCapabilities map[string]any
        loggingLevel       LogLevel
        clientRoots        []string
        samplingHistory    []types.SamplingRecord
        elicitationHistory []types.ElicitationRecord
}

// NewSessionState returns a session state with sensible defaults.
func NewSessionState() *SessionState <span class="cov10" title="107">{
        return &amp;SessionState{
                clientCapabilities: make(map[string]any),
                loggingLevel:       LogLevelInfo,
        }
}</span>

// MarkInitialized records the negotiated protocol version and client
// capabilities.
func (s *SessionState) MarkInitialized(protocolVersion string, capabilities map[string]any) <span class="cov5" title="8">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.initialized = true
        s.protocolVersion = protocolVersion
        s.clientRoots = nil
        s.samplingHistory = nil
        s.elicitationHistory = nil

        if capabilities == nil </span><span class="cov1" title="1">{
                s.clientCapabilities = make(map[string]any)
        }</span> else<span class="cov4" title="7"> {
                clone := make(map[string]any, len(capabilities))
                for k, v := range capabilities </span><span class="cov0" title="0">{
                        clone[k] = v
                }</span>
                <span class="cov4" title="7">s.clientCapabilities = clone</span>
        }
}

// Initialized reports whether the handshake has completed.
func (s *SessionState) Initialized() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.initialized
}</span>

// ProtocolVersion returns the negotiated protocol version.
func (s *SessionState) ProtocolVersion() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.protocolVersion
}</span>

// ClientCapabilities returns a shallow copy of the negotiated capabilities.
func (s *SessionState) ClientCapabilities() map[string]any <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        clone := make(map[string]any, len(s.clientCapabilities))
        for k, v := range s.clientCapabilities </span><span class="cov0" title="0">{
                clone[k] = v
        }</span>
        <span class="cov0" title="0">return clone</span>
}

// SetLoggingLevel stores the requested minimum logging level.
func (s *SessionState) SetLoggingLevel(level LogLevel) <span class="cov3" title="4">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.loggingLevel = level
}</span>

// LoggingLevel returns the currently configured minimum logging level.
func (s *SessionState) LoggingLevel() LogLevel <span class="cov6" title="14">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.loggingLevel
}</span>

// SetClientRoots records the roots returned by the client.
func (s *SessionState) SetClientRoots(roots []string) <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        clone := make([]string, len(roots))
        copy(clone, roots)
        s.clientRoots = clone
}</span>

// ClientRoots returns the negotiated root directories from the client, if any.
func (s *SessionState) ClientRoots() []string <span class="cov2" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        clone := make([]string, len(s.clientRoots))
        copy(clone, s.clientRoots)
        return clone
}</span>

// AppendSamplingRecord stores a sampling exchange for later inspection.
func (s *SessionState) AppendSamplingRecord(params map[string]any, result map[string]any) <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()
        record := types.SamplingRecord{
                Timestamp: time.Now().UTC(),
                Params:    cloneMap(params),
                Result:    cloneMap(result),
        }
        s.samplingHistory = append(s.samplingHistory, record)
}</span>

// SamplingHistory retrieves a copy of recorded sampling exchanges.
func (s *SessionState) SamplingHistory() []types.SamplingRecord <span class="cov3" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        clone := make([]types.SamplingRecord, len(s.samplingHistory))
        copy(clone, s.samplingHistory)
        return clone
}</span>

// AppendElicitationRecord stores an elicitation exchange.
func (s *SessionState) AppendElicitationRecord(params map[string]any, result map[string]any) <span class="cov3" title="4">{
        s.mu.Lock()
        defer s.mu.Unlock()
        record := types.ElicitationRecord{
                Timestamp: time.Now().UTC(),
                Params:    cloneMap(params),
                Result:    cloneMap(result),
        }
        s.elicitationHistory = append(s.elicitationHistory, record)
}</span>

// ElicitationHistory returns recorded elicitation exchanges.
func (s *SessionState) ElicitationHistory() []types.ElicitationRecord <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        clone := make([]types.ElicitationRecord, len(s.elicitationHistory))
        copy(clone, s.elicitationHistory)
        return clone
}</span>

func cloneMap(input map[string]any) map[string]any <span class="cov6" title="14">{
        if input == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov6" title="14">clone := make(map[string]any, len(input))
        for k, v := range input </span><span class="cov7" title="23">{
                clone[k] = v
        }</span>
        <span class="cov6" title="14">return clone</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package mcp

import (
        "context"
        "fmt"
        "time"

        "gorm.io/gorm"

        "github.com/termfx/morfx/models"
)

// StagingManager handles staging and applying transformations
type StagingManager struct {
        db     *gorm.DB
        config Config
}

// NewStagingManager creates a new staging manager
func NewStagingManager(db *gorm.DB, config Config) *StagingManager <span class="cov10" title="6">{
        return &amp;StagingManager{
                db:     db,
                config: config,
        }
}</span>

// CreateStage creates a new staged transformation while honoring cancellation.
func (sm *StagingManager) CreateStage(ctx context.Context, stage *models.Stage) error <span class="cov4" title="2">{
        // Validate stage is not nil
        if stage == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stage cannot be nil")
        }</span>

        <span class="cov4" title="2">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov4" title="2">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">db := sm.db.WithContext(ctx)

        // Generate ID if not set
        if stage.ID == "" </span><span class="cov1" title="1">{
                stage.ID = generateID("stg")
        }</span>

        // Set defaults only if not already set
        <span class="cov4" title="2">if stage.Status == "" </span><span class="cov4" title="2">{
                stage.Status = "pending"
        }</span>

        // Set expiration only if not already set
        <span class="cov4" title="2">if stage.ExpiresAt.IsZero() </span><span class="cov4" title="2">{
                stage.ExpiresAt = time.Now().Add(sm.config.StagingTTL)
        }</span>

        // Save to database
        <span class="cov4" title="2">if err := db.Create(stage).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return ctx.Err()</span>
}

// GetStage retrieves a stage by ID
func (sm *StagingManager) GetStage(id string) (*models.Stage, error) <span class="cov0" title="0">{
        var stage models.Stage
        err := sm.db.First(&amp;stage, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;stage, nil</span>
}

// ApplyStage applies a staged transformation while honoring cancellation.
func (sm *StagingManager) ApplyStage(ctx context.Context, stageID string, autoApplied bool) (*models.Apply, error) <span class="cov0" title="0">{
        var apply *models.Apply
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err := sm.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get the stage
                <span class="cov0" title="0">var stage models.Stage
                if err := tx.First(&amp;stage, "id = ?", stageID).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("stage not found: %w", err)
                }</span>

                // Check status
                <span class="cov0" title="0">if stage.Status != "pending" </span><span class="cov0" title="0">{
                        return fmt.Errorf("stage already %s", stage.Status)
                }</span>

                // Check expiration
                <span class="cov0" title="0">if time.Now().After(stage.ExpiresAt) </span><span class="cov0" title="0">{
                        // Update status to expired
                        stage.Status = "expired"
                        tx.Save(&amp;stage)
                        return fmt.Errorf("stage expired")
                }</span>

                // Create apply record
                <span class="cov0" title="0">apply = &amp;models.Apply{
                        ID:          generateID("apl"),
                        StageID:     stageID,
                        AutoApplied: autoApplied,
                        AppliedBy:   "mcp",
                }

                if autoApplied </span><span class="cov0" title="0">{
                        apply.AppliedBy = "auto"
                }</span>

                <span class="cov0" title="0">if err := tx.Create(apply).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create apply record: %w", err)
                }</span>

                // Update stage status
                <span class="cov0" title="0">now := time.Now()
                stage.Status = "applied"
                stage.AppliedAt = &amp;now

                if err := tx.Save(&amp;stage).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update stage: %w", err)
                }</span>

                // Update session statistics if available
                <span class="cov0" title="0">if stage.SessionID != "" </span><span class="cov0" title="0">{
                        tx.Model(&amp;models.Session{}).
                                Where("id = ?", stage.SessionID).
                                Update("applies_count", gorm.Expr("applies_count + ?", 1))
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return apply, nil</span>
}

// ListPendingStages lists all pending stages for a session
func (sm *StagingManager) ListPendingStages(sessionID string) ([]models.Stage, error) <span class="cov0" title="0">{
        var stages []models.Stage
        err := sm.db.
                Where("session_id = ? AND status = ?", sessionID, "pending").
                Order("created_at DESC").
                Find(&amp;stages).Error
        return stages, err
}</span>

// CleanupExpiredStages marks expired stages
func (sm *StagingManager) CleanupExpiredStages() error <span class="cov0" title="0">{
        return sm.db.Model(&amp;models.Stage{}).
                Where("status = ? AND expires_at &lt; ?", "pending", time.Now()).
                Update("status", "expired").Error
}</span>

// DeleteAppliedStages removes applied stages from database
func (sm *StagingManager) DeleteAppliedStages(sessionID string) error <span class="cov0" title="0">{
        return sm.db.Where("session_id = ? AND status = ?", sessionID, "applied").
                Delete(&amp;models.Stage{}).Error
}</span>

// DeleteStage removes a specific stage by ID
func (sm *StagingManager) DeleteStage(stageID string) error <span class="cov0" title="0">{
        return sm.db.Where("id = ?", stageID).Delete(&amp;models.Stage{}).Error
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package mcp

import (
        "testing"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"

        "github.com/termfx/morfx/models"
)

// setupAsyncStagingDB creates a temporary SQLite database suitable for both unit and integration tests.
func setupAsyncStagingDB(t *testing.T) *gorm.DB <span class="cov10" title="3">{
        t.Helper()
        tempDB := t.TempDir() + "/test.db"
        db, err := gorm.Open(sqlite.Open(tempDB+"?cache=shared&amp;mode=rwc"), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov10" title="3">if err := db.AutoMigrate(&amp;models.Session{}, &amp;models.Stage{}, &amp;models.Apply{}); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to migrate database: %v", err)
        }</span>

        <span class="cov10" title="3">return db</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// AppendTool handles appending code to elements or files
type AppendTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewAppendTool creates a new append tool
func NewAppendTool(server types.ServerInterface) *AppendTool <span class="cov9" title="9">{
        tool := &amp;AppendTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "append",
                description: "Append code to source - uses target if specified, otherwise intelligently places content",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language": CommonSchemas.Language,
                                "source":   CommonSchemas.Source,
                                "path":     CommonSchemas.Path,
                                "content": map[string]any{
                                        "type":        "string",
                                        "description": "Code to append",
                                },
                                "target": map[string]any{
                                        "type":        "object",
                                        "description": "Optional target scope (struct, function, etc)",
                                        "properties": map[string]any{
                                                "type": map[string]any{"type": "string"},
                                                "name": map[string]any{"type": "string"},
                                        },
                                },
                        },
                        "required": []string{"language", "content"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the append tool
func (t *AppendTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov10" title="11">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov10" title="11">var args struct {
                Language string          `json:"language"`
                Source   string          `json:"source"`
                Path     string          `json:"path"`
                Target   json.RawMessage `json:"target,omitempty"`
                Content  string          `json:"content"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid append parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov10" title="11">if (args.Source == "" &amp;&amp; args.Path == "") || (args.Source != "" &amp;&amp; args.Path != "") </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>
        <span class="cov10" title="11">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate that content is provided (can be empty string, but must be present)
        // Check if the field was actually provided in the JSON
        <span class="cov10" title="11">var rawArgs map[string]json.RawMessage
        if err := json.Unmarshal(params, &amp;rawArgs); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid parameters", err)
        }</span>
        <span class="cov10" title="11">if _, hasContent := rawArgs["content"]; !hasContent </span><span class="cov1" title="1">{
                return nil, types.NewMCPError(types.InvalidParams, "Missing required parameter: content", nil)
        }</span>

        // Get source code
        <span class="cov9" title="10">var source string
        if args.Path != "" </span><span class="cov3" title="2">{
                content, err := os.ReadFile(args.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov3" title="2">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov8" title="8"> {
                source = args.Source
        }</span>
        <span class="cov9" title="10">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider
        <span class="cov9" title="10">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.LanguageNotFound, "Language not supported", nil)
        }</span>
        <span class="cov9" title="10">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Build transform operation
        op := core.TransformOp{
                Method:      "append",
                Replacement: args.Content,
        }

        // Parse optional target
        if len(args.Target) &gt; 0 &amp;&amp; string(args.Target) != "null" </span><span class="cov6" title="4">{
                var target core.AgentQuery
                if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
                }</span>
                <span class="cov6" title="4">op.Target = target</span>
        }
        <span class="cov9" title="10">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute transformation
        <span class="cov9" title="10">result := provider.Transform(source, op)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "Append operation failed", result.Error)
        }</span>
        <span class="cov9" title="10">notifyProgress(ctx, t.server, 70, 100, "transformed source")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="10">notifyProgress(ctx, t.server, 90, 100, "finalizing")

        return t.server.FinalizeTransform(ctx, types.TransformRequest{
                Language:       args.Language,
                Operation:      "append",
                Target:         op.Target,
                TargetJSON:     args.Target,
                Path:           args.Path,
                OriginalSource: source,
                Result:         result,
                ResponseText:   t.formatResponse(result, args.Path),
                Content:        args.Content,
        })</span>
}

// formatResponse formats the append result
func (t *AppendTool) formatResponse(result core.TransformResult, path string) string <span class="cov9" title="10">{
        if result.Error != nil </span><span class="cov0" title="0">{
                return "Append operation failed"
        }</span>

        <span class="cov9" title="10">response := "✅ Append operation completed successfully\n\n"

        if path != "" </span><span class="cov3" title="2">{
                response += "📄 File: " + path + "\n\n"
        }</span>

        <span class="cov9" title="10">response += "Content appended:\n"
        if result.MatchCount &gt; 0 </span><span class="cov9" title="10">{
                response += fmt.Sprintf("  %d locations modified\n", result.MatchCount)
        }</span>

        <span class="cov9" title="10">response += fmt.Sprintf("\nConfidence: %.1f%%", result.Confidence.Score*100)

        return response</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"

        "github.com/termfx/morfx/mcp/types"
)

// ApplyTool handles applying staged transformations
type ApplyTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewApplyTool creates a new apply tool
func NewApplyTool(server types.ServerInterface) *ApplyTool <span class="cov9" title="10">{
        tool := &amp;ApplyTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "apply",
                description: "Apply staged code transformations",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "id": map[string]any{
                                        "type":        "string",
                                        "description": "Specific stage ID to apply",
                                },
                                "all": map[string]any{
                                        "type":        "boolean",
                                        "description": "Apply all pending stages",
                                },
                                "latest": map[string]any{
                                        "type":        "boolean",
                                        "description": "Apply the most recent pending stage",
                                },
                        },
                        "required": []string{},
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the apply tool
func (t *ApplyTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov9" title="11">{
        var args struct {
                ID     string `json:"id,omitempty"`
                All    bool   `json:"all,omitempty"`
                Latest bool   `json:"latest,omitempty"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov1" title="1">{
                return nil, types.WrapError(types.InvalidParams, "Invalid apply parameters", err)
        }</span>

        <span class="cov9" title="10">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="10">staging := t.server.GetStaging()
        if staging == nil </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams,
                        "Staging not available",
                        map[string]any{"reason": "Database connection required for staging"})
        }</span>
        <span class="cov9" title="10">if !isStagingEnabled(staging) </span><span class="cov1" title="1">{
                return nil, types.NewMCPError(types.InvalidParams, "staging is not enabled", nil)
        }</span>

        <span class="cov8" title="9">notifyProgress(ctx, t.server, 20, 100, "staging ready")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="9">mode := ""
        appliedIDs := make([]string, 0)

        paramCount := 0
        if args.ID != "" </span><span class="cov6" title="4">{
                paramCount++
        }</span>
        <span class="cov8" title="9">if args.All </span><span class="cov4" title="3">{
                paramCount++
        }</span>
        <span class="cov8" title="9">if args.Latest </span><span class="cov4" title="3">{
                paramCount++
        }</span>
        <span class="cov8" title="9">if paramCount &gt; 1 </span><span class="cov1" title="1">{
                return nil, types.NewMCPError(types.InvalidParams,
                        "conflicting parameters: specify only one of 'id', 'all', or 'latest'",
                        nil)
        }</span>
        <span class="cov8" title="8">if paramCount == 0 </span><span class="cov1" title="1">{
                args.Latest = true
        }</span>

        <span class="cov8" title="8">notifyProgress(ctx, t.server, 35, 100, "prepared request")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="8">var summary map[string]any

        switch </span>{
        case args.ID != "":<span class="cov4" title="3">
                mode = "single"
                notifyProgress(ctx, t.server, 60, 100, "applying stage")
                if err := t.server.ConfirmApply(ctx, fmt.Sprintf("Apply stage %s", args.ID)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov4" title="3">stageType := reflect.TypeOf(staging)
                if method, ok := stageType.MethodByName("GetStage"); ok </span><span class="cov4" title="3">{
                        results := method.Func.Call([]reflect.Value{reflect.ValueOf(staging), reflect.ValueOf(args.ID)})
                        if len(results) &gt;= 2 </span><span class="cov4" title="3">{
                                if exists, ok := results[1].Interface().(bool); ok &amp;&amp; !exists </span><span class="cov1" title="1">{
                                        return nil, types.NewMCPError(types.InvalidParams,
                                                "stage not found: "+args.ID,
                                                nil)
                                }</span>
                        }
                }

                <span class="cov3" title="2">if err := invokeApplyStage(staging, ctx, args.ID, false); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">appliedIDs = append(appliedIDs, args.ID)
                summary = map[string]any{"mode": mode, "stageId": args.ID}</span>

        case args.All:<span class="cov3" title="2">
                mode = "all"
                notifyProgress(ctx, t.server, 60, 100, "applying all stages")
                if err := t.server.ConfirmApply(ctx, "Apply all pending stages"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov3" title="2">ids, err := collectStageIDs(staging)
                if err != nil || len(ids) == 0 </span><span class="cov0" title="0">{
                        return nil, types.NewMCPError(types.InvalidParams, "no stages available", nil)
                }</span>
                <span class="cov3" title="2">for _, stageID := range ids </span><span class="cov7" title="6">{
                        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov7" title="6">if err := invokeApplyStage(staging, ctx, stageID, false); err == nil </span><span class="cov7" title="6">{
                                appliedIDs = append(appliedIDs, stageID)
                        }</span>
                }
                <span class="cov3" title="2">summary = map[string]any{"mode": mode, "appliedCount": len(appliedIDs)}</span>

        case args.Latest:<span class="cov4" title="3">
                mode = "latest"
                notifyProgress(ctx, t.server, 60, 100, "applying latest stage")
                stageID, err := latestStageID(staging)
                if err != nil || stageID == "" </span><span class="cov1" title="1">{
                        return nil, types.NewMCPError(types.InvalidParams, "no stages available", nil)
                }</span>
                <span class="cov3" title="2">if err := t.server.ConfirmApply(ctx, fmt.Sprintf("Apply latest stage %s", stageID)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">if err := invokeApplyStage(staging, ctx, stageID, false); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">appliedIDs = append(appliedIDs, stageID)
                summary = map[string]any{"mode": mode, "stageId": stageID}</span>

        default:<span class="cov0" title="0">
                return nil, types.NewMCPError(types.InvalidParams, "unsupported apply parameters", nil)</span>
        }

        <span class="cov7" title="6">structured := map[string]any{"mode": mode}
        if len(appliedIDs) &gt; 0 </span><span class="cov7" title="6">{
                structured["applied"] = append([]string{}, appliedIDs...)
        }</span>
        <span class="cov7" title="6">if mode == "all" </span><span class="cov3" title="2">{
                structured["appliedCount"] = len(appliedIDs)
        }</span>

        <span class="cov7" title="6">sampling, err := t.sampleApply(ctx, summary)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">if sampling != nil </span><span class="cov1" title="1">{
                structured["sampling"] = sampling
        }</span>

        <span class="cov7" title="6">notifyProgress(ctx, t.server, 90, 100, "completed")

        message := "Apply operation completed"
        switch mode </span>{
        case "single":<span class="cov3" title="2">
                message = "Applied stage: " + appliedIDs[0]</span>
        case "latest":<span class="cov3" title="2">
                message = "Applied latest stage: " + appliedIDs[0]</span>
        case "all":<span class="cov3" title="2">
                message = fmt.Sprintf("Applied %d stage(s)", len(appliedIDs))</span>
        }

        <span class="cov7" title="6">return map[string]any{
                "content":           []map[string]any{{"type": "text", "text": message}},
                "applied":           appliedIDs,
                "structuredContent": structured,
        }, nil</span>
}

func isStagingEnabled(staging any) bool <span class="cov9" title="10">{
        if method, ok := reflect.TypeOf(staging).MethodByName("IsEnabled"); ok </span><span class="cov9" title="10">{
                results := method.Func.Call([]reflect.Value{reflect.ValueOf(staging)})
                if len(results) &gt; 0 </span><span class="cov9" title="10">{
                        if enabled, ok := results[0].Interface().(bool); ok </span><span class="cov9" title="10">{
                                return enabled
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

func collectStageIDs(staging any) ([]string, error) <span class="cov6" title="5">{
        method, ok := reflect.TypeOf(staging).MethodByName("GetAllStages")
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("staging manager does not support GetAllStages")
        }</span>
        <span class="cov6" title="5">results := method.Func.Call([]reflect.Value{reflect.ValueOf(staging)})
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov6" title="5">stages, ok := results[0].Interface().([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov6" title="5">ids := make([]string, 0, len(stages))
        for _, stage := range stages </span><span class="cov10" title="12">{
                if stageMap, ok := stage.(map[string]any); ok </span><span class="cov10" title="12">{
                        if stageID, ok := stageMap["id"].(string); ok &amp;&amp; stageID != "" </span><span class="cov10" title="12">{
                                ids = append(ids, stageID)
                        }</span>
                }
        }
        <span class="cov6" title="5">return ids, nil</span>
}

func latestStageID(staging any) (string, error) <span class="cov4" title="3">{
        if method, ok := reflect.TypeOf(staging).MethodByName("GetLatestStage"); ok </span><span class="cov0" title="0">{
                results := method.Func.Call([]reflect.Value{reflect.ValueOf(staging)})
                if len(results) &gt; 0 </span><span class="cov0" title="0">{
                        if stageMap, ok := results[0].Interface().(map[string]any); ok </span><span class="cov0" title="0">{
                                if stageID, ok := stageMap["id"].(string); ok </span><span class="cov0" title="0">{
                                        return stageID, nil
                                }</span>
                        }
                }
        }
        <span class="cov4" title="3">ids, err := collectStageIDs(staging)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="3">if len(ids) == 0 </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov3" title="2">return ids[0], nil</span>
}

func (t *ApplyTool) sampleApply(ctx context.Context, summary map[string]any) (map[string]any, error) <span class="cov7" title="6">{
        if t.server == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov7" title="6">if summary == nil </span><span class="cov0" title="0">{
                summary = map[string]any{}
        }</span>

        <span class="cov7" title="6">notifyProgress(ctx, t.server, 72, 100, "requesting sampling")
        payload := map[string]any{
                "workflow": "apply",
                "summary":  summary,
        }

        resp, err := t.server.RequestSampling(ctx, payload)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return map[string]any{"error": err.Error()}, nil</span>
        }

        <span class="cov7" title="6">notifyProgress(ctx, t.server, 78, 100, "sampling complete")
        return resp, nil</span>
}

func invokeApplyStage(staging any, ctx context.Context, stageID string, auto bool) error <span class="cov9" title="10">{
        applyMethod, ok := reflect.TypeOf(staging).MethodByName("ApplyStage")
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("staging manager does not expose ApplyStage")
        }</span>

        <span class="cov9" title="10">args := []reflect.Value{reflect.ValueOf(staging)}
        switch applyMethod.Type.NumIn() </span>{
        case 4:<span class="cov0" title="0"> // receiver, context, stageID, bool
                args = append(args, reflect.ValueOf(ctx), reflect.ValueOf(stageID), reflect.ValueOf(auto))</span>
        case 3:<span class="cov0" title="0"> // receiver, stageID, bool
                args = append(args, reflect.ValueOf(stageID), reflect.ValueOf(auto))</span>
        case 2:<span class="cov9" title="10"> // receiver, stageID
                args = append(args, reflect.ValueOf(stageID))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported ApplyStage signature")</span>
        }

        <span class="cov9" title="10">results := applyMethod.Func.Call(args)
        if len(results) &gt; 0 </span><span class="cov9" title="10">{
                if errVal := results[len(results)-1]; errVal.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) </span><span class="cov9" title="10">{
                        if !errVal.IsNil() </span><span class="cov0" title="0">{
                                if err, ok := errVal.Interface().(error); ok </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov9" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package tools

import (
        "context"
        "encoding/json"

        "github.com/termfx/morfx/mcp/types"
)

// BaseTool provides common tool functionality
type BaseTool struct {
        name        string
        description string
        inputSchema map[string]any
        handler     types.ToolHandler
}

// Name returns the tool name
func (t *BaseTool) Name() string <span class="cov5" title="13">{
        return t.name
}</span>

// Description returns the tool description
func (t *BaseTool) Description() string <span class="cov2" title="2">{
        return t.description
}</span>

// InputSchema returns the tool's input schema
func (t *BaseTool) InputSchema() map[string]any <span class="cov4" title="8">{
        return t.inputSchema
}</span>

// Handler returns the tool's handler function
func (t *BaseTool) Handler() types.ToolHandler <span class="cov2" title="3">{
        return t.handler
}</span>

// ToolBuilder helps construct tools with fluent interface
type ToolBuilder struct {
        tool *BaseTool
}

// NewTool creates a new tool builder
func NewTool(name string) *ToolBuilder <span class="cov0" title="0">{
        return &amp;ToolBuilder{
                tool: &amp;BaseTool{
                        name:        name,
                        inputSchema: make(map[string]any),
                },
        }
}</span>

// WithDescription sets the tool description
func (b *ToolBuilder) WithDescription(desc string) *ToolBuilder <span class="cov0" title="0">{
        b.tool.description = desc
        return b
}</span>

// WithInputSchema sets the input schema
func (b *ToolBuilder) WithInputSchema(schema map[string]any) *ToolBuilder <span class="cov0" title="0">{
        b.tool.inputSchema = schema
        return b
}</span>

// WithHandler sets the handler function
func (b *ToolBuilder) WithHandler(handler types.ToolHandler) *ToolBuilder <span class="cov0" title="0">{
        b.tool.handler = handler
        return b
}</span>

// Build returns the constructed tool
func (b *ToolBuilder) Build() types.Tool <span class="cov0" title="0">{
        return b.tool
}</span>

// CommonSchemas provides reusable schema definitions
var CommonSchemas = struct {
        Language    map[string]any
        Source      map[string]any
        Path        map[string]any
        Query       map[string]any
        Replacement map[string]any
        Target      map[string]any
}{
        Language: map[string]any{
                "type":        "string",
                "description": "Programming language",
        },
        Source: map[string]any{
                "type":        "string",
                "description": "Source code (for in-memory mode)",
        },
        Path: map[string]any{
                "type":        "string",
                "description": "File path to modify (for file writer mode)",
        },
        Query: map[string]any{
                "type":        "object",
                "description": "Query to find code elements",
                "properties": map[string]any{
                        "type": map[string]any{
                                "type":        "string",
                                "description": "Element type (function, struct, class, etc)",
                        },
                        "name": map[string]any{
                                "type":        "string",
                                "description": "Name pattern (supports wildcards)",
                        },
                },
        },
        Replacement: map[string]any{
                "type":        "string",
                "description": "Replacement code",
        },
        Target: map[string]any{
                "type":        "object",
                "description": "Target to modify",
                "properties": map[string]any{
                        "type": map[string]any{
                                "type": "string",
                        },
                        "name": map[string]any{
                                "type": "string",
                        },
                },
        },
}

// ParseParams is a helper to unmarshal parameters with proper error handling
func ParseParams[T any](params json.RawMessage) (*T, error) <span class="cov0" title="0">{
        var result T
        if err := json.Unmarshal(params, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;result, nil</span>
}

func notifyProgress(ctx context.Context, server types.ServerInterface, progress, total float64, message string) <span class="cov10" title="251">{
        if server == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="251">server.ReportProgress(ctx, progress, total, message)</span>
}

func isCancelled(ctx context.Context) error <span class="cov9" title="234">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov9" title="234">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="234">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// DeleteTool handles code element deletion
type DeleteTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewDeleteTool creates a new delete tool
func NewDeleteTool(server types.ServerInterface) *DeleteTool <span class="cov10" title="8">{
        tool := &amp;DeleteTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "delete",
                description: "Delete code elements matching a query",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language": CommonSchemas.Language,
                                "source":   CommonSchemas.Source,
                                "path":     CommonSchemas.Path,
                                "target":   CommonSchemas.Target,
                        },
                        "required": []string{"language", "target"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the delete tool
func (t *DeleteTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov9" title="7">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov9" title="7">var args struct {
                Language string          `json:"language"`
                Source   string          `json:"source"`
                Path     string          `json:"path"`
                Target   json.RawMessage `json:"target"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid delete parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov9" title="7">if (args.Source == "" &amp;&amp; args.Path == "") || (args.Source != "" &amp;&amp; args.Path != "") </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>

        <span class="cov9" title="7">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source code
        <span class="cov9" title="7">var source string
        if args.Path != "" </span><span class="cov4" title="2">{
                content, err := os.ReadFile(args.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov4" title="2">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov7" title="5"> {
                source = args.Source
        }</span>
        <span class="cov9" title="7">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider
        <span class="cov9" title="7">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.LanguageNotFound, "Language not supported", nil)
        }</span>
        <span class="cov9" title="7">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Parse target
        var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov4" title="2">{
                return nil, types.WrapError(types.InvalidParams, "target must be an object", err)
        }</span>
        <span class="cov7" title="5">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute transformation
        <span class="cov7" title="5">op := core.TransformOp{
                Method: "delete",
                Target: target,
        }

        result := provider.Transform(source, op)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "Delete operation failed", result.Error)
        }</span>
        <span class="cov7" title="5">notifyProgress(ctx, t.server, 70, 100, "transformed source")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="5">notifyProgress(ctx, t.server, 90, 100, "finalizing")

        return t.server.FinalizeTransform(ctx, types.TransformRequest{
                Language:       args.Language,
                Operation:      "delete",
                Target:         target,
                TargetJSON:     args.Target,
                Path:           args.Path,
                OriginalSource: source,
                Result:         result,
                ResponseText:   t.formatResponse(result, args.Path),
        })</span>
}

// formatResponse formats the deletion result
func (t *DeleteTool) formatResponse(result core.TransformResult, path string) string <span class="cov7" title="5">{
        if result.Error != nil </span><span class="cov0" title="0">{
                return "Delete operation failed: " + result.Error.Error()
        }</span>

        <span class="cov7" title="5">response := "✅ Delete operation completed successfully\n\n"

        if path != "" </span><span class="cov4" title="2">{
                response += "📄 File: " + path + "\n\n"
        }</span>

        <span class="cov7" title="5">if result.MatchCount &gt; 0 </span><span class="cov7" title="5">{
                response += fmt.Sprintf("Deletions made: %d\n", result.MatchCount)
        }</span>

        <span class="cov7" title="5">response += fmt.Sprintf("\nConfidence: %.1f%%", result.Confidence.Score*100)

        return response</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// FileDeleteTool handles deletion across multiple files
type FileDeleteTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewFileDeleteTool creates a new file delete tool
func NewFileDeleteTool(server types.ServerInterface) *FileDeleteTool <span class="cov10" title="5">{
        tool := &amp;FileDeleteTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "file_delete",
                description: "Delete code elements across multiple files",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "scope": map[string]any{
                                        "type":        "object",
                                        "description": "File scope to process",
                                        "properties": map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Root directory path",
                                                },
                                                "include": map[string]any{
                                                        "type":        "array",
                                                        "description": "File patterns to include",
                                                        "items":       map[string]any{"type": "string"},
                                                },
                                        },
                                        "required": []string{"path"},
                                },
                                "target": CommonSchemas.Target,
                                "dry_run": map[string]any{
                                        "type":        "boolean",
                                        "description": "Preview changes without applying",
                                },
                                "backup": map[string]any{
                                        "type":        "boolean",
                                        "description": "Create backup files",
                                },
                        },
                        "required": []string{"scope", "target"},
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the file delete tool
func (t *FileDeleteTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov0" title="0">var args struct {
                Scope  core.FileScope  `json:"scope"`
                Target json.RawMessage `json:"target"`
                DryRun bool            `json:"dry_run"`
                Backup bool            `json:"backup"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid file delete parameters", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse target
        <span class="cov0" title="0">var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 20, 100, "prepared target")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create transform operation
        <span class="cov0" title="0">fileOp := core.FileTransformOp{
                TransformOp: core.TransformOp{
                        Method: "delete",
                        Target: target,
                },
                Scope:    args.Scope,
                DryRun:   args.DryRun,
                Backup:   args.Backup,
                Parallel: true,
        }
        notifyProgress(ctx, t.server, 35, 100, "prepared operation")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute with timeout
        <span class="cov0" title="0">opCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
        defer cancel()

        fileProcessor := t.server.GetFileProcessor()
        result, err := fileProcessor.TransformFiles(opCtx, fileOp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "File delete failed", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 80, 100, "processed files")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Format response
        <span class="cov0" title="0">return map[string]any{
                "content": []map[string]any{
                        {
                                "type": "text",
                                "text": t.formatResponse(result, args.DryRun),
                        },
                },
                "files_processed": result.FilesScanned,
                "files_modified":  result.FilesModified,
                "dry_run":         args.DryRun,
        }, nil</span>
}

// formatResponse formats the file delete results
func (t *FileDeleteTool) formatResponse(result *core.FileTransformResult, dryRun bool) string <span class="cov0" title="0">{
        mode := ""
        if dryRun </span><span class="cov0" title="0">{
                mode = " [DRY RUN]"
        }</span>

        <span class="cov0" title="0">response := fmt.Sprintf("✅ File delete operation completed%s\n\n", mode)
        response += fmt.Sprintf("Files scanned: %d\n", result.FilesScanned)
        response += fmt.Sprintf("Files modified: %d\n", result.FilesModified)
        response += fmt.Sprintf("Total deletions: %d\n", result.TotalMatches)

        if len(result.Files) &gt; 0 </span><span class="cov0" title="0">{
                response += "\nModified files:\n"
                for _, file := range result.Files </span><span class="cov0" title="0">{
                        if file.MatchCount &gt; 0 </span><span class="cov0" title="0">{
                                response += fmt.Sprintf("📄 %s: %d deletions\n", file.FilePath, file.MatchCount)
                        }</span>
                }
        }

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                response += "\n⚠️  This was a dry run. No files were actually modified."
        }</span>

        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// FileQueryTool handles code queries across multiple files
type FileQueryTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewFileQueryTool creates a new file query tool
func NewFileQueryTool(server types.ServerInterface) *FileQueryTool <span class="cov6" title="8">{
        tool := &amp;FileQueryTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "file_query",
                description: "Find code elements across multiple files using natural language queries",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "scope": map[string]any{
                                        "type":        "object",
                                        "description": "File scope to search",
                                        "properties": map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Root directory path to scan",
                                                },
                                                "include": map[string]any{
                                                        "type":        "array",
                                                        "description": "File patterns to include (*.go, **/*.ts)",
                                                        "items":       map[string]any{"type": "string"},
                                                },
                                                "exclude": map[string]any{
                                                        "type":        "array",
                                                        "description": "File patterns to exclude",
                                                        "items":       map[string]any{"type": "string"},
                                                },
                                                "language": map[string]any{
                                                        "type":        "string",
                                                        "description": "Programming language filter",
                                                },
                                                "max_files": map[string]any{
                                                        "type":        "integer",
                                                        "description": "Maximum files to process (0 = unlimited)",
                                                },
                                        },
                                        "required": []string{"path"},
                                },
                                "query": CommonSchemas.Query,
                        },
                        "required": []string{"scope", "query"},
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the file query tool
func (t *FileQueryTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov8" title="14">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="14">var args struct {
                Scope *core.FileScope `json:"scope"`
                Query json.RawMessage `json:"query"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid file query parameters", err)
        }</span>
        <span class="cov8" title="14">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate scope is provided
        <span class="cov8" title="14">if args.Scope == nil </span><span class="cov1" title="1">{
                return nil, types.NewMCPError(types.InvalidParams, "scope is required", nil)
        }</span>

        // Validate scope path
        <span class="cov7" title="13">if args.Scope.Path == "" </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "scope.path is required", nil)
        }</span>

        // Check if path exists
        <span class="cov7" title="13">if _, err := os.Stat(args.Scope.Path); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, types.NewMCPError(types.InvalidParams, "path does not exist: "+args.Scope.Path, nil)
        }</span>
        <span class="cov7" title="12">notifyProgress(ctx, t.server, 20, 100, "prepared scope")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse the query
        <span class="cov7" title="12">var query core.AgentQuery
        if err := json.Unmarshal(args.Query, &amp;query); err != nil </span><span class="cov1" title="1">{
                return nil, types.WrapError(types.InvalidParams, "Invalid query structure", err)
        }</span>
        <span class="cov7" title="11">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute file query with timeout
        <span class="cov7" title="11">opCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        fileProcessor := t.server.GetFileProcessor()
        matches, err := fileProcessor.QueryFiles(opCtx, *args.Scope, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "File query failed", err)
        }</span>
        <span class="cov7" title="11">notifyProgress(ctx, t.server, 80, 100, "processed files")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Format response
        <span class="cov7" title="11">responseText := t.formatFileQueryResponse(matches, *args.Scope)

        // Format response for tests compatibility
        // Always use the map format for content to be consistent
        fileList := make([]any, 0)
        if len(matches) &gt; 0 </span><span class="cov7" title="10">{
                seen := make(map[string]bool)
                for _, m := range matches </span><span class="cov10" title="29">{
                        if !seen[m.FilePath] </span><span class="cov10" title="29">{
                                seen[m.FilePath] = true
                                fileList = append(fileList, map[string]any{
                                        "path":    m.FilePath,
                                        "matches": 1,
                                })
                        }</span>
                }
        }

        <span class="cov7" title="11">return map[string]any{
                "content": map[string]any{
                        "type":  "text",
                        "text":  responseText,
                        "files": fileList,
                },
                "matches": len(matches),
                "files":   t.countUniqueFiles(matches),
        }, nil</span>
}

// formatFileQueryResponse formats file query matches as human-readable text
func (t *FileQueryTool) formatFileQueryResponse(matches []core.FileMatch, scope core.FileScope) string <span class="cov7" title="11">{
        if len(matches) == 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("No matches found in %s", scope.Path)
        }</span>

        // Group matches by file
        <span class="cov7" title="10">fileGroups := make(map[string][]core.FileMatch)
        for _, fm := range matches </span><span class="cov10" title="29">{
                fileGroups[fm.FilePath] = append(fileGroups[fm.FilePath], fm)
        }</span>

        <span class="cov7" title="10">var response string
        response = fmt.Sprintf("Found %d matches across %d files in %s:\n\n",
                len(matches), len(fileGroups), scope.Path)

        for filePath, fileMatches := range fileGroups </span><span class="cov10" title="29">{
                response += fmt.Sprintf("📄 %s (%d matches):\n", filePath, len(fileMatches))
                for _, match := range fileMatches </span><span class="cov10" title="29">{
                        response += fmt.Sprintf("  • %s '%s' at line %d, column %d\n",
                                match.Type, match.Name,
                                match.Location.Line, match.Location.Column)
                        if match.Content != "" </span><span class="cov10" title="29">{
                                // Show first line of content
                                firstLine := match.Content
                                if idx := len(firstLine); idx &gt; 80 </span><span class="cov0" title="0">{
                                        firstLine = firstLine[:77] + "..."
                                }</span>
                                <span class="cov10" title="29">response += fmt.Sprintf("    %s\n", firstLine)</span>
                        }
                }
                <span class="cov10" title="29">response += "\n"</span>
        }

        <span class="cov7" title="10">return response</span>
}

// countUniqueFiles counts unique files in matches
func (t *FileQueryTool) countUniqueFiles(matches []core.FileMatch) int <span class="cov7" title="11">{
        unique := make(map[string]bool)
        for _, m := range matches </span><span class="cov10" title="29">{
                unique[m.FilePath] = true
        }</span>
        <span class="cov7" title="11">return len(unique)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// FileReplaceTool handles replacement across multiple files
type FileReplaceTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewFileReplaceTool creates a new file replace tool
func NewFileReplaceTool(server types.ServerInterface) *FileReplaceTool <span class="cov10" title="5">{
        tool := &amp;FileReplaceTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "file_replace",
                description: "Replace code elements across multiple files",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "scope": map[string]any{
                                        "type":        "object",
                                        "description": "File scope to process",
                                        "properties": map[string]any{
                                                "path": map[string]any{
                                                        "type":        "string",
                                                        "description": "Root directory path",
                                                },
                                                "include": map[string]any{
                                                        "type":        "array",
                                                        "description": "File patterns to include",
                                                        "items":       map[string]any{"type": "string"},
                                                },
                                                "exclude": map[string]any{
                                                        "type":        "array",
                                                        "description": "File patterns to exclude",
                                                        "items":       map[string]any{"type": "string"},
                                                },
                                        },
                                        "required": []string{"path"},
                                },
                                "target":      CommonSchemas.Target,
                                "replacement": CommonSchemas.Replacement,
                                "dry_run": map[string]any{
                                        "type":        "boolean",
                                        "description": "Preview changes without applying",
                                },
                                "backup": map[string]any{
                                        "type":        "boolean",
                                        "description": "Create backup files",
                                },
                        },
                        "required": []string{"scope", "target", "replacement"},
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the file replace tool
func (t *FileReplaceTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov0" title="0">var args struct {
                Scope       core.FileScope  `json:"scope"`
                Target      json.RawMessage `json:"target"`
                Replacement string          `json:"replacement"`
                DryRun      bool            `json:"dry_run"`
                Backup      bool            `json:"backup"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid file replace parameters", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse target
        <span class="cov0" title="0">var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 20, 100, "prepared target")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create transform operation
        <span class="cov0" title="0">fileOp := core.FileTransformOp{
                TransformOp: core.TransformOp{
                        Method:      "replace",
                        Target:      target,
                        Replacement: args.Replacement,
                },
                Scope:    args.Scope,
                DryRun:   args.DryRun,
                Backup:   args.Backup,
                Parallel: true,
        }
        notifyProgress(ctx, t.server, 35, 100, "prepared operation")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute with timeout
        <span class="cov0" title="0">opCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
        defer cancel()

        fileProcessor := t.server.GetFileProcessor()
        result, err := fileProcessor.TransformFiles(opCtx, fileOp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "File replace failed", err)
        }</span>
        <span class="cov0" title="0">notifyProgress(ctx, t.server, 80, 100, "processed files")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Format response
        <span class="cov0" title="0">return map[string]any{
                "content": []map[string]any{
                        {
                                "type": "text",
                                "text": t.formatResponse(result, args.DryRun),
                        },
                },
                "files_processed": result.FilesScanned,
                "files_modified":  result.FilesModified,
                "dry_run":         args.DryRun,
        }, nil</span>
}

// formatResponse formats the file replace results
func (t *FileReplaceTool) formatResponse(result *core.FileTransformResult, dryRun bool) string <span class="cov0" title="0">{
        mode := ""
        if dryRun </span><span class="cov0" title="0">{
                mode = " [DRY RUN]"
        }</span>

        <span class="cov0" title="0">response := fmt.Sprintf("✅ File replace operation completed%s\n\n", mode)
        response += fmt.Sprintf("Files scanned: %d\n", result.FilesScanned)
        response += fmt.Sprintf("Files modified: %d\n", result.FilesModified)
        response += fmt.Sprintf("Total matches: %d\n", result.TotalMatches)

        if len(result.Files) &gt; 0 </span><span class="cov0" title="0">{
                response += "\nModified files:\n"
                for _, file := range result.Files </span><span class="cov0" title="0">{
                        if file.MatchCount &gt; 0 </span><span class="cov0" title="0">{
                                response += fmt.Sprintf("📄 %s: %d changes\n", file.FilePath, file.MatchCount)
                        }</span>
                }
        }

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                response += "\n⚠️  This was a dry run. No files were actually modified."
        }</span>

        <span class="cov0" title="0">return response</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// InsertAfterTool handles inserting code after elements
type InsertAfterTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewInsertAfterTool creates a new insert after tool
func NewInsertAfterTool(server types.ServerInterface) *InsertAfterTool <span class="cov10" title="8">{
        tool := &amp;InsertAfterTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "insert_after",
                description: "Insert code after elements matching a query",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language": CommonSchemas.Language,
                                "source":   CommonSchemas.Source,
                                "path":     CommonSchemas.Path,
                                "target":   CommonSchemas.Target,
                                "content": map[string]any{
                                        "type":        "string",
                                        "description": "Code to insert",
                                },
                        },
                        "required": []string{"language", "target", "content"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the insert after tool
func (t *InsertAfterTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov7" title="5">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov7" title="5">var args struct {
                Language string          `json:"language"`
                Source   string          `json:"source"`
                Path     string          `json:"path"`
                Target   json.RawMessage `json:"target"`
                Content  string          `json:"content"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid insert_after parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov7" title="5">if (args.Source == "" &amp;&amp; args.Path == "") || (args.Source != "" &amp;&amp; args.Path != "") </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>
        <span class="cov7" title="5">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source code
        <span class="cov7" title="5">var source string
        if args.Path != "" </span><span class="cov1" title="1">{
                content, err := os.ReadFile(args.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov1" title="1">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov7" title="4"> {
                source = args.Source
        }</span>
        <span class="cov7" title="5">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider
        <span class="cov7" title="5">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.LanguageNotFound, "Language not supported", nil)
        }</span>
        <span class="cov7" title="5">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Parse target
        var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov1" title="1">{
                return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
        }</span>
        <span class="cov7" title="4">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute transformation
        <span class="cov7" title="4">op := core.TransformOp{
                Method:      "insert_after",
                Target:      target,
                Replacement: args.Content,
        }

        result := provider.Transform(source, op)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "Insert after operation failed", result.Error)
        }</span>
        <span class="cov7" title="4">notifyProgress(ctx, t.server, 70, 100, "transformed source")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="4">notifyProgress(ctx, t.server, 90, 100, "finalizing")

        return t.server.FinalizeTransform(ctx, types.TransformRequest{
                Language:       args.Language,
                Operation:      "insert_after",
                Target:         target,
                TargetJSON:     args.Target,
                Path:           args.Path,
                OriginalSource: source,
                Result:         result,
                ResponseText:   t.formatResponse(result, args.Path),
                Content:        args.Content,
        })</span>
}

// formatResponse formats the insertion result
func (t *InsertAfterTool) formatResponse(result core.TransformResult, path string) string <span class="cov7" title="4">{
        if result.Error != nil </span><span class="cov0" title="0">{
                return "Insert after operation failed"
        }</span>

        <span class="cov7" title="4">response := "✅ Insert after operation completed successfully\n\n"

        if path != "" </span><span class="cov1" title="1">{
                response += "📄 File: " + path + "\n\n"
        }</span>

        <span class="cov7" title="4">response += "Insertions made:\n"
        if result.MatchCount &gt; 0 </span><span class="cov7" title="4">{
                response += fmt.Sprintf("  %d locations modified\n", result.MatchCount)
        }</span>

        <span class="cov7" title="4">response += fmt.Sprintf("\nConfidence: %.1f%%", result.Confidence.Score*100)

        return response</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// InsertBeforeTool handles inserting code before elements
type InsertBeforeTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewInsertBeforeTool creates a new insert before tool
func NewInsertBeforeTool(server types.ServerInterface) *InsertBeforeTool <span class="cov10" title="8">{
        tool := &amp;InsertBeforeTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "insert_before",
                description: "Insert code before elements matching a query",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language": CommonSchemas.Language,
                                "source":   CommonSchemas.Source,
                                "path":     CommonSchemas.Path,
                                "target":   CommonSchemas.Target,
                                "content": map[string]any{
                                        "type":        "string",
                                        "description": "Code to insert",
                                },
                        },
                        "required": []string{"language", "target", "content"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the insert before tool
func (t *InsertBeforeTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov8" title="6">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="6">var args struct {
                Language string          `json:"language"`
                Source   string          `json:"source"`
                Path     string          `json:"path"`
                Target   json.RawMessage `json:"target"`
                Content  string          `json:"content"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid insert_before parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov8" title="6">if (args.Source == "" &amp;&amp; args.Path == "") || (args.Source != "" &amp;&amp; args.Path != "") </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>
        <span class="cov8" title="6">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source code
        <span class="cov8" title="6">var source string
        if args.Path != "" </span><span class="cov1" title="1">{
                content, err := os.ReadFile(args.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov1" title="1">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov7" title="5"> {
                source = args.Source
        }</span>
        <span class="cov8" title="6">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider
        <span class="cov8" title="6">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.LanguageNotFound, "Language not supported", nil)
        }</span>
        <span class="cov8" title="6">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Parse target
        var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
        }</span>
        <span class="cov8" title="6">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute transformation
        <span class="cov8" title="6">op := core.TransformOp{
                Method:      "insert_before",
                Target:      target,
                Replacement: args.Content,
        }

        result := provider.Transform(source, op)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "Insert before operation failed", result.Error)
        }</span>
        <span class="cov8" title="6">notifyProgress(ctx, t.server, 70, 100, "transformed source")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="6">notifyProgress(ctx, t.server, 90, 100, "finalizing")

        return t.server.FinalizeTransform(ctx, types.TransformRequest{
                Language:       args.Language,
                Operation:      "insert_before",
                Target:         target,
                TargetJSON:     args.Target,
                Path:           args.Path,
                OriginalSource: source,
                Result:         result,
                ResponseText:   t.formatResponse(result, args.Path),
                Content:        args.Content,
        })</span>
}

// formatResponse formats the insertion result
func (t *InsertBeforeTool) formatResponse(result core.TransformResult, path string) string <span class="cov8" title="6">{
        if result.Error != nil </span><span class="cov0" title="0">{
                return "Insert before operation failed"
        }</span>

        <span class="cov8" title="6">response := "✅ Insert before operation completed successfully\n\n"

        if path != "" </span><span class="cov1" title="1">{
                response += "📄 File: " + path + "\n\n"
        }</span>

        <span class="cov8" title="6">response += "Insertions made:\n"
        if result.MatchCount &gt; 0 </span><span class="cov8" title="6">{
                response += fmt.Sprintf("  %d locations modified\n", result.MatchCount)
        }</span>

        <span class="cov8" title="6">response += fmt.Sprintf("\nConfidence: %.1f%%", result.Confidence.Score*100)

        return response</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// QueryTool handles code element queries
type QueryTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewQueryTool creates a new query tool
func NewQueryTool(server types.ServerInterface) *QueryTool <span class="cov8" title="8">{
        tool := &amp;QueryTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "query",
                description: "Find code elements using natural language queries",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language": CommonSchemas.Language,
                                "source":   CommonSchemas.Source,
                                "path":     CommonSchemas.Path,
                                "query":    CommonSchemas.Query,
                        },
                        "required": []string{"language", "query"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the query tool
func (t *QueryTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov10" title="11">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov10" title="11">var args struct {
                Language string          `json:"language"`
                Source   *string         `json:"source,omitempty"`
                Path     *string         `json:"path,omitempty"`
                Query    json.RawMessage `json:"query"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid query parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov10" title="11">sourceProvided := args.Source != nil
        pathProvided := args.Path != nil

        if (!sourceProvided &amp;&amp; !pathProvided) || (sourceProvided &amp;&amp; pathProvided) </span><span class="cov3" title="2">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>
        <span class="cov9" title="9">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source code
        <span class="cov9" title="9">var source string
        if pathProvided </span><span class="cov5" title="3">{
                // FILE WRITER MODE: Read from filesystem
                content, err := os.ReadFile(*args.Path)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov3" title="2">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov7" title="6"> {
                // IN-MEMORY MODE: Use provided source (can be empty string)
                source = *args.Source
        }</span>
        <span class="cov8" title="8">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider for language
        <span class="cov8" title="8">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov3" title="2">{
                return nil, types.NewMCPError(types.LanguageNotFound,
                        fmt.Sprintf("No provider for language: %s", args.Language),
                        map[string]any{
                                "requested": args.Language,
                                "supported": []string{"go", "python", "javascript", "typescript", "php"},
                        })
        }</span>
        <span class="cov7" title="6">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Parse the query
        var query core.AgentQuery
        if err := json.Unmarshal(args.Query, &amp;query); err != nil </span><span class="cov1" title="1">{
                return nil, types.WrapError(types.InvalidParams, "Invalid query structure", err)
        }</span>
        <span class="cov7" title="5">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute query
        <span class="cov7" title="5">result := provider.Query(source, query)
        if result.Error != nil </span><span class="cov0" title="0">{
                // Check if it's a syntax error or other
                errMsg := result.Error.Error()
                if strings.Contains(errMsg, "parse") || strings.Contains(errMsg, "syntax") </span><span class="cov0" title="0">{
                        return nil, types.NewMCPError(types.SyntaxError, "Failed to parse source code",
                                map[string]any{"details": errMsg})
                }</span>
                <span class="cov0" title="0">return nil, types.WrapError(types.TransformFailed, "Query execution failed", result.Error)</span>
        }
        <span class="cov7" title="5">notifyProgress(ctx, t.server, 70, 100, "evaluated query")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Format matches as human-readable text
        <span class="cov7" title="5">var responseText string
        if len(result.Matches) == 0 </span><span class="cov0" title="0">{
                responseText = "No matches found"
        }</span> else<span class="cov7" title="5"> {
                responseText = fmt.Sprintf("Found %d match", len(result.Matches))
                if len(result.Matches) != 1 </span><span class="cov0" title="0">{
                        responseText += "es"
                }</span>
                <span class="cov7" title="5">responseText += ":\n\n"

                for _, match := range result.Matches </span><span class="cov7" title="5">{
                        responseText += fmt.Sprintf("• %s '%s' at line %d, column %d",
                                match.Type, match.Name,
                                match.Location.Line, match.Location.Column)
                        if match.Content != "" </span><span class="cov7" title="5">{
                                responseText += fmt.Sprintf("\n  Content: %s", match.Content)
                        }</span>
                        <span class="cov7" title="5">responseText += "\n"</span>
                }
        }

        // Add file info if in FILE WRITER MODE
        <span class="cov7" title="5">if pathProvided </span><span class="cov3" title="2">{
                responseText = fmt.Sprintf("File: %s\n\n%s", *args.Path, responseText)
        }</span>

        // Return as MCP content blocks
        <span class="cov7" title="5">return map[string]any{
                "content": []map[string]any{
                        {
                                "type": "text",
                                "text": responseText,
                        },
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"

        "github.com/termfx/morfx/mcp/types"
)

// toolRegistry manages tools internally
type toolRegistry struct {
        mu      sync.RWMutex
        tools   map[string]types.Tool
        ordered []string
        server  types.ServerInterface
}

// Registry holds all registered tools
var Registry *toolRegistry

// Init initializes the tool registry with the server
func Init(server types.ServerInterface) <span class="cov2" title="5">{
        Registry = &amp;toolRegistry{
                tools:   make(map[string]types.Tool),
                ordered: make([]string, 0),
                server:  server,
        }
        RegisterAll(server)
}</span>

// Register adds a tool to the registry
func (r *toolRegistry) Register(name string, tool types.Tool) <span class="cov6" title="301">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.tools[name]; !exists </span><span class="cov4" title="56">{
                r.ordered = append(r.ordered, name)
        }</span>
        <span class="cov6" title="301">r.tools[name] = tool</span>
}

// Get retrieves a tool by name
func (r *toolRegistry) Get(name string) (types.Tool, bool) <span class="cov7" title="1014">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        tool, exists := r.tools[name]
        return tool, exists
}</span>

// List returns all tools in registration order
func (r *toolRegistry) List() []types.Tool <span class="cov7" title="1001">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]types.Tool, 0, len(r.ordered))
        for _, name := range r.ordered </span><span class="cov10" title="13753">{
                result = append(result, r.tools[name])
        }</span>
        <span class="cov7" title="1001">return result</span>
}

// Execute runs a tool by name with the given parameters
func (r *toolRegistry) Execute(ctx context.Context, name string, params json.RawMessage) (any, error) <span class="cov1" title="2">{
        tool, exists := r.Get(name)
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tool not found: %s", name)
        }</span>

        <span class="cov1" title="1">handler := tool.Handler()
        return handler(ctx, params)</span>
}

// RegisterAll registers all built-in tools
func RegisterAll(server types.ServerInterface) <span class="cov2" title="5">{
        // Query tools
        Registry.Register("query", NewQueryTool(server))
        Registry.Register("file_query", NewFileQueryTool(server))

        // Transformation tools
        Registry.Register("replace", NewReplaceTool(server))
        Registry.Register("file_replace", NewFileReplaceTool(server))
        Registry.Register("delete", NewDeleteTool(server))
        Registry.Register("file_delete", NewFileDeleteTool(server))
        Registry.Register("insert_before", NewInsertBeforeTool(server))
        Registry.Register("insert_after", NewInsertAfterTool(server))
        Registry.Register("append", NewAppendTool(server))

        // Staging tools
        Registry.Register("apply", NewApplyTool(server))
}</span>

// Get retrieves a tool by name
func Get(name string) (types.Tool, bool) <span class="cov0" title="0">{
        return Registry.Get(name)
}</span>

// Execute runs a tool by name
func Execute(ctx context.Context, name string, params []byte) (any, error) <span class="cov0" title="0">{
        return Registry.Execute(ctx, name, params)
}</span>

// GetDefinitions returns all tool definitions
func GetDefinitions() []types.ToolDefinition <span class="cov0" title="0">{
        tools := Registry.List()
        definitions := make([]types.ToolDefinition, 0, len(tools))

        for _, tool := range tools </span><span class="cov0" title="0">{
                definitions = append(definitions, types.ToolDefinition{
                        Name:        tool.Name(),
                        Title:       tool.Name(),
                        Description: tool.Description(),
                        InputSchema: tool.InputSchema(),
                        Annotations: map[string]any{"title": tool.Name()},
                })
        }</span>

        <span class="cov0" title="0">return definitions</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/mcp/types"
)

// ReplaceTool handles code element replacement
type ReplaceTool struct {
        *BaseTool
        server types.ServerInterface
}

// NewReplaceTool creates a new replace tool
func NewReplaceTool(server types.ServerInterface) *ReplaceTool <span class="cov10" title="8">{
        tool := &amp;ReplaceTool{
                server: server,
        }

        tool.BaseTool = &amp;BaseTool{
                name:        "replace",
                description: "Replace code elements matching a query",
                inputSchema: map[string]any{
                        "type": "object",
                        "properties": map[string]any{
                                "language":    CommonSchemas.Language,
                                "source":      CommonSchemas.Source,
                                "path":        CommonSchemas.Path,
                                "target":      CommonSchemas.Target,
                                "replacement": CommonSchemas.Replacement,
                        },
                        "required": []string{"language", "target", "replacement"},
                        "oneOf": []map[string]any{
                                {"required": []string{"source"}},
                                {"required": []string{"path"}},
                        },
                },
                handler: tool.handle,
        }

        return tool
}</span>

// handle executes the replace tool

func (t *ReplaceTool) handle(ctx context.Context, params json.RawMessage) (any, error) <span class="cov9" title="7">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov9" title="7">var args struct {
                Language    string          `json:"language"`
                Source      string          `json:"source"`
                Path        string          `json:"path"`
                Target      json.RawMessage `json:"target"`
                Replacement string          `json:"replacement"`
        }

        if err := json.Unmarshal(params, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.InvalidParams, "Invalid replace parameters", err)
        }</span>

        // Validate that exactly one of source or path is provided
        <span class="cov9" title="7">if (args.Source == "" &amp;&amp; args.Path == "") || (args.Source != "" &amp;&amp; args.Path != "") </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.InvalidParams, "Exactly one of 'source' or 'path' must be provided", nil)
        }</span>

        <span class="cov9" title="7">notifyProgress(ctx, t.server, 5, 100, "validating")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get source code
        <span class="cov9" title="7">var source string
        if args.Path != "" </span><span class="cov4" title="2">{
                content, err := os.ReadFile(args.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, types.WrapError(types.FileSystemError, "Failed to read file", err)
                }</span>
                <span class="cov4" title="2">source = string(content)
                notifyProgress(ctx, t.server, 15, 100, "loaded file")</span>
        } else<span class="cov7" title="5"> {
                source = args.Source
        }</span>

        <span class="cov9" title="7">if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get provider
        <span class="cov9" title="7">provider, exists := t.server.GetProviders().Get(args.Language)
        if !exists </span><span class="cov0" title="0">{
                return nil, types.NewMCPError(types.LanguageNotFound, "Language not supported", nil)
        }</span>

        <span class="cov9" title="7">notifyProgress(ctx, t.server, 25, 100, "resolved provider")

        // Parse target
        var target core.AgentQuery
        if err := json.Unmarshal(args.Target, &amp;target); err != nil </span><span class="cov4" title="2">{
                return nil, types.WrapError(types.InvalidParams, "Invalid target structure", err)
        }</span>

        // Execute transformation
        <span class="cov7" title="5">op := core.TransformOp{
                Method:      "replace",
                Target:      target,
                Replacement: args.Replacement,
        }

        result := provider.Transform(source, op)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, types.WrapError(types.TransformFailed, "Replace operation failed", result.Error)
        }</span>

        <span class="cov7" title="5">notifyProgress(ctx, t.server, 70, 100, "transformed source")
        if err := isCancelled(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="5">notifyProgress(ctx, t.server, 90, 100, "finalizing")

        return t.server.FinalizeTransform(ctx, types.TransformRequest{
                Language:       args.Language,
                Operation:      "replace",
                Target:         target,
                TargetJSON:     args.Target,
                Path:           args.Path,
                OriginalSource: source,
                Result:         result,
                ResponseText:   t.formatResponse(result, args.Path),
        })</span>
}

// formatResponse formats the transformation result
func (t *ReplaceTool) formatResponse(result core.TransformResult, path string) string <span class="cov7" title="5">{
        if result.Error != nil </span><span class="cov0" title="0">{
                return "Replace operation failed: " + result.Error.Error()
        }</span>

        <span class="cov7" title="5">response := "✅ Replace operation completed successfully\n\n"

        if path != "" </span><span class="cov4" title="2">{
                response += "📄 File: " + path + "\n\n"
        }</span>

        <span class="cov7" title="5">if result.MatchCount &gt; 0 </span><span class="cov7" title="5">{
                response += fmt.Sprintf("Replacements made: %d\n", result.MatchCount)
        }</span>

        <span class="cov7" title="5">if result.Diff != "" </span><span class="cov7" title="5">{
                response += "\nChanges:\n" + result.Diff + "\n"
        }</span>

        <span class="cov7" title="5">response += "\nConfidence: " + formatConfidence(result.Confidence.Score)

        return response</span>
}

// formatConfidence formats confidence score as visual indicator
func formatConfidence(confidence float64) string <span class="cov7" title="5">{
        bars := int(confidence * 10)
        filled := strings.Repeat("█", bars)
        empty := strings.Repeat("░", 10-bars)
        return filled + empty + " " + fmt.Sprintf("%.1f%%", confidence*100)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package tools

import (
        "testing"
)

// extractContentText is a helper to extract text from the content field which can be either
// a map[string]any with a text field or an array of such maps
func extractContentText(t *testing.T, result any) string <span class="cov0" title="0">{
        t.Helper()

        resultMap, ok := result.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                t.Fatal("Result should be a map")
                return ""
        }</span>

        // content can be either []map[string]any or []interface{}
        <span class="cov0" title="0">if contentArray, ok := resultMap["content"].([]map[string]any); ok &amp;&amp; len(contentArray) &gt; 0 </span><span class="cov0" title="0">{
                if text, ok := contentArray[0]["text"].(string); ok </span><span class="cov0" title="0">{
                        return text
                }</span>
        } else<span class="cov0" title="0"> if contentInterface, ok := resultMap["content"].([]any); ok &amp;&amp; len(contentInterface) &gt; 0 </span><span class="cov0" title="0">{
                if contentItem, ok := contentInterface[0].(map[string]any); ok </span><span class="cov0" title="0">{
                        if text, ok := contentItem["text"].(string); ok </span><span class="cov0" title="0">{
                                return text
                        }</span>
                }
        }

        <span class="cov0" title="0">t.Error("Could not extract text from content")
        return ""</span>
}

// hasContentArray checks if result has a content array field
func hasContentArray(result any) bool <span class="cov9" title="5">{
        resultMap, ok := result.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov9" title="5">_, hasArray := resultMap["content"].([]map[string]any)
        if !hasArray </span><span class="cov0" title="0">{
                _, hasArray = resultMap["content"].([]any)
        }</span>

        <span class="cov9" title="5">return hasArray</span>
}

// Fix for old tests that expect content to be a map
// This converts the new format to the old format for compatibility
func convertContentToMap(result any) (map[string]any, bool) <span class="cov0" title="0">{
        resultMap, ok := result.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Try to get content array and convert to map
        <span class="cov0" title="0">contentMap := make(map[string]any)

        if contentArray, ok := resultMap["content"].([]map[string]any); ok &amp;&amp; len(contentArray) &gt; 0 </span><span class="cov0" title="0">{
                // Use the first item as the content map
                contentMap = contentArray[0]
        }</span> else<span class="cov0" title="0"> if contentInterface, ok := resultMap["content"].([]any); ok &amp;&amp; len(contentInterface) &gt; 0 </span><span class="cov0" title="0">{
                if item, ok := contentInterface[0].(map[string]any); ok </span><span class="cov0" title="0">{
                        contentMap = item
                }</span>
        }

        // Update the result to use the map format
        <span class="cov0" title="0">resultMap["content"] = contentMap
        return contentMap, true</span>
}

func toStringSlice(value any) []string <span class="cov10" title="6">{
        switch v := value.(type) </span>{
        case []string:<span class="cov10" title="6">
                return v</span>
        case []any:<span class="cov0" title="0">
                out := make([]string, 0, len(v))
                for _, item := range v </span><span class="cov0" title="0">{
                        if s, ok := item.(string); ok </span><span class="cov0" title="0">{
                                out = append(out, s)
                        }</span>
                }
                <span class="cov0" title="0">return out</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// TransactionLog manages transaction logging for rollback capability
type TransactionLog struct {
        transactions map[string]*Transaction
        mutex        sync.RWMutex
        logFile      string
}

// NewTransactionLog creates a new transaction log
func NewTransactionLog() *TransactionLog <span class="cov10" title="87">{
        logDir := "./.morfx/transactions"
        os.MkdirAll(logDir, 0o755)

        logFile := filepath.Join(logDir, fmt.Sprintf("tx_%d.log", time.Now().Unix()))

        return &amp;TransactionLog{
                transactions: make(map[string]*Transaction),
                logFile:      logFile,
        }
}</span>

// BeginTransaction starts a new transaction
func (tl *TransactionLog) BeginTransaction(targetPath, tmpPath, backupPath string) string <span class="cov4" title="5">{
        tl.mutex.Lock()
        defer tl.mutex.Unlock()

        txID := generateTransactionID()
        tx := &amp;Transaction{
                ID:         txID,
                TargetPath: targetPath,
                TmpPath:    tmpPath,
                BackupPath: backupPath,
                Status:     "pending",
                StartTime:  time.Now(),
        }

        tl.transactions[txID] = tx
        tl.logTransaction(tx)

        return txID
}</span>

// CompleteTransaction marks a transaction as completed
func (tl *TransactionLog) CompleteTransaction(txID string) <span class="cov4" title="5">{
        tl.mutex.Lock()
        defer tl.mutex.Unlock()

        tx, exists := tl.transactions[txID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="5">tx.Status = "completed"
        tx.EndTime = time.Now()
        tl.logTransaction(tx)

        // Clean up completed transaction after a delay
        go func() </span><span class="cov4" title="5">{
                time.Sleep(5 * time.Minute)
                tl.cleanupTransaction(txID)
        }</span>()
}

// FailTransaction marks a transaction as failed and triggers rollback
func (tl *TransactionLog) FailTransaction(txID string, reason error) error <span class="cov0" title="0">{
        tl.mutex.Lock()
        defer tl.mutex.Unlock()

        tx, exists := tl.transactions[txID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %s", txID)
        }</span>

        <span class="cov0" title="0">tx.Status = "failed"
        tx.Error = reason.Error()
        tx.EndTime = time.Now()

        // Perform rollback but keep the failed status
        err := tl.rollbackTransactionInternal(tx, false) // false = don't change status
        if err != nil </span><span class="cov0" title="0">{
                // If rollback fails, note it but keep failed status
                tx.Error = fmt.Sprintf("%s; rollback failed: %v", tx.Error, err)
        }</span>

        <span class="cov0" title="0">tl.logTransaction(tx)
        return err</span>
}

// RollbackTransaction performs rollback for a specific transaction
func (tl *TransactionLog) RollbackTransaction(txID string) error <span class="cov0" title="0">{
        tl.mutex.RLock()
        tx, exists := tl.transactions[txID]
        tl.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %s", txID)
        }</span>

        <span class="cov0" title="0">return tl.rollbackTransaction(tx)</span>
}

// rollbackTransaction performs the actual rollback logic
func (tl *TransactionLog) rollbackTransaction(tx *Transaction) error <span class="cov0" title="0">{
        return tl.rollbackTransactionInternal(tx, true) // true = change status to rolled_back
}</span>

func (tl *TransactionLog) rollbackTransactionInternal(tx *Transaction, changeStatus bool) error <span class="cov0" title="0">{
        // If we have a backup, restore it
        if tx.BackupPath != "" &amp;&amp; fileExists(tx.BackupPath) </span><span class="cov0" title="0">{
                if err := os.Rename(tx.BackupPath, tx.TargetPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to restore backup: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // No backup available, just remove the target if it exists
                if fileExists(tx.TargetPath) </span><span class="cov0" title="0">{
                        if err := os.Remove(tx.TargetPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to remove target file: %w", err)
                        }</span>
                }
        }

        // Clean up temporary file if it still exists
        <span class="cov0" title="0">if tx.TmpPath != "" &amp;&amp; fileExists(tx.TmpPath) </span><span class="cov0" title="0">{
                os.Remove(tx.TmpPath)
        }</span>

        <span class="cov0" title="0">if changeStatus </span><span class="cov0" title="0">{
                tx.Status = "rolled_back"
                tx.EndTime = time.Now()
                tl.logTransaction(tx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPendingTransactions returns all pending transactions
func (tl *TransactionLog) GetPendingTransactions() []*Transaction <span class="cov0" title="0">{
        tl.mutex.RLock()
        defer tl.mutex.RUnlock()

        var pending []*Transaction
        for _, tx := range tl.transactions </span><span class="cov0" title="0">{
                if tx.Status == "pending" </span><span class="cov0" title="0">{
                        pending = append(pending, tx)
                }</span>
        }

        <span class="cov0" title="0">return pending</span>
}

// RollbackAll rolls back all pending transactions
func (tl *TransactionLog) RollbackAll() error <span class="cov0" title="0">{
        pending := tl.GetPendingTransactions()

        var errors []string
        for _, tx := range pending </span><span class="cov0" title="0">{
                if err := tl.rollbackTransaction(tx); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("tx %s: %v", tx.ID, err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rollback errors: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logTransaction writes transaction state to log file
func (tl *TransactionLog) logTransaction(tx *Transaction) <span class="cov5" title="10">{
        data, err := json.Marshal(tx)
        if err != nil </span><span class="cov0" title="0">{
                return // Best effort logging
        }</span>

        // Append to log file
        <span class="cov5" title="10">file, err := os.OpenFile(tl.logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="10">defer file.Close()

        file.WriteString(string(data) + "\n")
        file.Sync()</span>
}

// cleanupTransaction removes old transaction data
func (tl *TransactionLog) cleanupTransaction(txID string) <span class="cov0" title="0">{
        tl.mutex.Lock()
        defer tl.mutex.Unlock()

        tx, exists := tl.transactions[txID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up backup files for completed transactions
        <span class="cov0" title="0">if tx.Status == "completed" &amp;&amp; tx.BackupPath != "" </span><span class="cov0" title="0">{
                os.Remove(tx.BackupPath)
        }</span>

        <span class="cov0" title="0">delete(tl.transactions, txID)</span>
}

// generateTransactionID creates a unique transaction ID
func generateTransactionID() string <span class="cov4" title="5">{
        suffix, _ := generateRandomSuffix()
        return fmt.Sprintf("tx_%d_%s", time.Now().UnixNano(), suffix[:8])
}</span>

// fileExists checks if a file exists
func fileExists(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return err == nil
}</span>

// Transaction represents a file operation transaction
type Transaction struct {
        ID         string    `json:"id"`
        TargetPath string    `json:"target_path"`
        TmpPath    string    `json:"tmp_path"`
        BackupPath string    `json:"backup_path"`
        Status     string    `json:"status"` // "pending", "completed", "failed", "rolled_back"
        Error      string    `json:"error,omitempty"`
        StartTime  time.Time `json:"start_time"`
        EndTime    time.Time `json:"end_time"`
}

// TransactionSummary provides a summary of transaction log state
type TransactionSummary struct {
        TotalTransactions      int `json:"total_transactions"`
        PendingTransactions    int `json:"pending_transactions"`
        CompletedTransactions  int `json:"completed_transactions"`
        FailedTransactions     int `json:"failed_transactions"`
        RolledBackTransactions int `json:"rolled_back_transactions"`
}

// GetSummary returns a summary of the transaction log
func (tl *TransactionLog) GetSummary() TransactionSummary <span class="cov1" title="1">{
        tl.mutex.RLock()
        defer tl.mutex.RUnlock()

        summary := TransactionSummary{}
        summary.TotalTransactions = len(tl.transactions)

        for _, tx := range tl.transactions </span><span class="cov1" title="1">{
                switch tx.Status </span>{
                case "pending":<span class="cov0" title="0">
                        summary.PendingTransactions++</span>
                case "completed":<span class="cov1" title="1">
                        summary.CompletedTransactions++</span>
                case "failed":<span class="cov0" title="0">
                        summary.FailedTransactions++</span>
                case "rolled_back":<span class="cov0" title="0">
                        summary.RolledBackTransactions++</span>
                }
        }

        <span class="cov1" title="1">return summary</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package mcp

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "os"

        "github.com/termfx/morfx/mcp/types"
        "github.com/termfx/morfx/models"
        "gorm.io/datatypes"
)

// FinalizeTransform implements types.ServerInterface. It centralises staging, auto-apply,
// and response formatting so tool handlers stay lean and consistent.
func (s *StdioServer) FinalizeTransform(ctx context.Context, req types.TransformRequest) (map[string]any, error) <span class="cov6" title="2">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov6" title="2">fileMode := req.Path != ""
        responseText := req.ResponseText
        shouldAutoApply := s.config.AutoApplyEnabled &amp;&amp; req.Result.Confidence.Score &gt;= s.config.AutoApplyThreshold

        originalHash := ""
        if req.OriginalSource != "" </span><span class="cov6" title="2">{
                originalHash = calculateSHA256(req.OriginalSource)
        }</span>

        <span class="cov6" title="2">var status string = "completed"
        var referenceID string
        autoApplied := false
        modifiedWritten := false

        // Helper to ensure we only write once we have validation in place.
        writeFile := func() error </span><span class="cov1" title="1">{
                if !fileMode || req.Result.Modified == "" || modifiedWritten </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov1" title="1">if sm := s.safety; sm != nil </span><span class="cov1" title="1">{
                        op := &amp;SafetyOperation{
                                Files: []SafetyFile{
                                        {
                                                Path:       req.Path,
                                                Size:       int64(len(req.Result.Modified)),
                                                Confidence: req.Result.Confidence.Score,
                                        },
                                },
                                GlobalConfidence: req.Result.Confidence.Score,
                        }
                        if err := sm.ValidateOperation(op); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov1" title="1">if originalHash != "" </span><span class="cov1" title="1">{
                                checks := []FileIntegrityCheck{{
                                        Path:         req.Path,
                                        ExpectedHash: originalHash,
                                }}
                                if err := sm.ValidateFileIntegrity(checks); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov1" title="1">if err := sm.AtomicWrite(req.Path, req.Result.Modified); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="1">modifiedWritten = true
                        return nil</span>
                }

                // Fallback direct write when safety manager is unavailable.
                <span class="cov0" title="0">mode := os.FileMode(0o644)
                if info, err := os.Stat(req.Path); err == nil </span><span class="cov0" title="0">{
                        mode = info.Mode().Perm()
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile(req.Path, []byte(req.Result.Modified), mode); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">modifiedWritten = true
                return nil</span>
        }

        // Attempt staging when available.
        <span class="cov6" title="2">if s.staging != nil </span><span class="cov1" title="1">{
                stage := s.buildStage(req, originalHash)
                applied := false

                if err := s.staging.CreateStage(ctx, stage); err != nil </span><span class="cov0" title="0">{
                        responseText += fmt.Sprintf("\n⚠️ Failed to stage transformation: %v", err)
                }</span> else<span class="cov1" title="1"> {
                        status = "staged"
                        referenceID = stage.ID

                        if shouldAutoApply </span><span class="cov0" title="0">{
                                if fileMode </span><span class="cov0" title="0">{
                                        if err := writeFile(); err != nil </span><span class="cov0" title="0">{
                                                shouldAutoApply = false
                                                responseText += fmt.Sprintf("\n⚠️ Auto-apply aborted: %v", err)
                                        }</span>
                                }
                        }

                        <span class="cov1" title="1">if shouldAutoApply </span><span class="cov0" title="0">{
                                applyResult, err := s.staging.ApplyStage(ctx, stage.ID, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        shouldAutoApply = false
                                        responseText += fmt.Sprintf("\n⚠️ Failed to auto-apply: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        applied = true
                                        autoApplied = true
                                        status = "applied"
                                        if applyResult != nil </span><span class="cov0" title="0">{
                                                referenceID = applyResult.ID
                                        }</span> else<span class="cov0" title="0"> {
                                                referenceID = stage.ID
                                        }</span>
                                }
                        }

                        <span class="cov1" title="1">if applied </span><span class="cov0" title="0">{
                                if fileMode </span><span class="cov0" title="0">{
                                        responseText += fmt.Sprintf("\n✅ Auto-applied and saved (ID: %s)", referenceID)
                                }</span> else<span class="cov0" title="0"> {
                                        responseText += fmt.Sprintf("\n✅ Auto-applied (ID: %s)", referenceID)
                                }</span>
                        } else<span class="cov1" title="1"> {
                                responseText += fmt.Sprintf("\n📋 Staged for review (ID: %s)", stage.ID)
                                if fileMode </span><span class="cov1" title="1">{
                                        responseText += "\nUse the apply tool to write changes to disk."
                                }</span>
                        }
                }
        } else<span class="cov1" title="1"> {
                // No staging available – only auto-apply can persist changes.
                if shouldAutoApply </span><span class="cov1" title="1">{
                        if err := writeFile(); err != nil </span><span class="cov0" title="0">{
                                shouldAutoApply = false
                                responseText += fmt.Sprintf("\n⚠️ Auto-apply aborted: %v", err)
                        }</span> else<span class="cov1" title="1"> {
                                autoApplied = true
                                status = "applied"
                                responseText += "\n✅ Auto-applied"
                        }</span>
                } else<span class="cov0" title="0"> if fileMode </span><span class="cov0" title="0">{
                        responseText += "\n⚠️ Auto-apply disabled – file not modified. Apply the diff manually."
                }</span>
        }

        // If auto-apply requested but we could not fulfil it in staging path, and file mode,
        // ensure the file is not left modified inadvertently.
        <span class="cov6" title="2">if fileMode &amp;&amp; shouldAutoApply &amp;&amp; !autoApplied </span>{<span class="cov0" title="0">
                // We reach here if staging prevented auto apply; ensure we roll back any write.
                // Since writeFile only sets modifiedWritten when successful, no action needed.
        }</span>

        <span class="cov6" title="2">resp := map[string]any{
                "content": []map[string]any{{
                        "type": "text",
                        "text": responseText,
                }},
                "confidence": req.Result.Confidence.Score,
                "matches":    req.Result.MatchCount,
        }

        if fileMode </span><span class="cov6" title="2">{
                resp["path"] = req.Path
        }</span>
        <span class="cov6" title="2">if status != "" </span><span class="cov6" title="2">{
                resp["result"] = status
        }</span>
        <span class="cov6" title="2">if referenceID != "" </span><span class="cov1" title="1">{
                resp["id"] = referenceID
        }</span>
        <span class="cov6" title="2">if req.Result.Modified != "" </span><span class="cov6" title="2">{
                resp["modified"] = req.Result.Modified
        }</span>

        <span class="cov6" title="2">return resp, nil</span>
}

func (s *StdioServer) buildStage(req types.TransformRequest, originalHash string) *models.Stage <span class="cov1" title="1">{
        targetJSON := req.TargetJSON
        if len(targetJSON) == 0 </span><span class="cov1" title="1">{
                if encoded, err := json.Marshal(req.Target); err == nil </span><span class="cov1" title="1">{
                        targetJSON = encoded
                }</span>
        }

        <span class="cov1" title="1">stageID := generateID("stg")
        stage := &amp;models.Stage{
                ID:        stageID,
                Language:  req.Language,
                Operation: req.Operation,

                TargetType:  req.Target.Type,
                TargetName:  req.Target.Name,
                TargetQuery: datatypes.JSON(targetJSON),

                Original: req.OriginalSource,
                Modified: req.Result.Modified,
                Content:  req.Content,
                Diff:     req.Result.Diff,

                BaseDigest:  originalHash,
                AfterDigest: calculateSHA256(req.Result.Modified),

                ConfidenceScore:   req.Result.Confidence.Score,
                ConfidenceLevel:   req.Result.Confidence.Level,
                ConfidenceFactors: mustMarshalJSON(req.Result.Confidence.Factors),
        }

        if s.session != nil </span><span class="cov1" title="1">{
                stage.SessionID = s.session.ID
        }</span>

        <span class="cov1" title="1">if req.Path != "" </span><span class="cov1" title="1">{
                scope := map[string]any{
                        "file_path":        req.Path,
                        "safety_validated": s.safety != nil,
                        "file_size":        len(req.Result.Modified),
                }
                if originalHash != "" </span><span class="cov1" title="1">{
                        scope["original_hash"] = originalHash
                }</span>
                <span class="cov1" title="1">stage.ScopeAST = mustMarshalJSON(scope)</span>
        }

        <span class="cov1" title="1">return stage</span>
}

func calculateSHA256(content string) string <span class="cov10" title="3">{
        if content == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov10" title="3">sum := sha256Sum([]byte(content))
        return fmt.Sprintf("%x", sum)</span>
}

func mustMarshalJSON(value any) datatypes.JSON <span class="cov6" title="2">{
        if value == nil </span><span class="cov0" title="0">{
                return datatypes.JSON([]byte("null"))
        }</span>
        <span class="cov6" title="2">data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return datatypes.JSON([]byte("null"))
        }</span>
        <span class="cov6" title="2">return datatypes.JSON(data)</span>
}

func sha256Sum(data []byte) [32]byte <span class="cov10" title="3">{
        return sha256.Sum256(data)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package types provides shared types and interfaces for MCP components
// This avoids circular dependencies between packages
package types

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/providers"
)

// ServerInterface defines what tools need from the server
type ServerInterface interface {
        GetProviders() *providers.Registry
        GetFileProcessor() *core.FileProcessor
        GetStaging() any
        GetSafety() any
        ReportProgress(ctx context.Context, progress, total float64, message string)
        ConfirmApply(ctx context.Context, summary string) error
        RequestSampling(ctx context.Context, params map[string]any) (map[string]any, error)
        RequestElicitation(ctx context.Context, params map[string]any) (map[string]any, error)
        FinalizeTransform(ctx context.Context, req TransformRequest) (map[string]any, error)
}

// ToolHandler represents a function that handles a tool call
type ToolHandler func(ctx context.Context, params json.RawMessage) (any, error)

// Component represents a registrable MCP component (tool, prompt, resource)
type Component interface {
        Name() string
        Description() string
}

// Tool represents an executable tool with handler
type Tool interface {
        Component
        Handler() ToolHandler
        InputSchema() map[string]any
}

// TransformRequest captures the information needed to finalize a transformation.
type TransformRequest struct {
        Language       string               `json:"language"`
        Operation      string               `json:"operation"`
        Target         core.AgentQuery      `json:"target"`
        TargetJSON     json.RawMessage      `json:"target_json"`
        Path           string               `json:"path,omitempty"`
        OriginalSource string               `json:"original_source"`
        Result         core.TransformResult `json:"result"`
        ResponseText   string               `json:"response_text"`
        Content        string               `json:"content,omitempty"`
}

// PromptArgument represents an argument for a prompt
type PromptArgument struct {
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        Required    bool   `json:"required,omitempty"`
}

// Prompt represents a system prompt
type Prompt interface {
        Component
        Content() string
        Arguments() []PromptArgument
}

// Resource represents a readable resource
type Resource interface {
        Component
        URI() string
        MimeType() string
        Contents() (string, error)
}

// WatchableResource is implemented by resources that can push update notifications.
type WatchableResource interface {
        Resource
        Watch(ctx context.Context) (&lt;-chan ResourceUpdate, error)
}

// ErrResourceWatchUnsupported is returned when a resource does not support subscriptions.
var ErrResourceWatchUnsupported = errors.New("resource does not support watch")

// ResourceUpdateType identifies the kind of update emitted by a watchable resource.
type ResourceUpdateType string

const (
        ResourceUpdateTypeUpdated     ResourceUpdateType = "updated"
        ResourceUpdateTypeRemoved     ResourceUpdateType = "removed"
        ResourceUpdateTypeListChanged ResourceUpdateType = "list_changed"
)

// ResourceUpdate describes a change emitted by a watchable resource.
type ResourceUpdate struct {
        URI  string             `json:"uri,omitempty"`
        Type ResourceUpdateType `json:"type,omitempty"`
        Data map[string]any     `json:"data,omitempty"`
}

// DefaultJSONSchemaURI represents the canonical JSON Schema reference for responses.
const DefaultJSONSchemaURI = "https://json-schema.org/draft/2020-12/schema"

// NormalizeSchema clones the provided schema and injects required defaults.
func NormalizeSchema(schema map[string]any) map[string]any <span class="cov0" title="0">{
        cloned := cloneSchemaMap(schema)
        if cloned == nil </span><span class="cov0" title="0">{
                cloned = map[string]any{}
        }</span>
        <span class="cov0" title="0">if _, ok := cloned["type"]; !ok </span><span class="cov0" title="0">{
                cloned["type"] = "object"
        }</span>
        <span class="cov0" title="0">if _, ok := cloned["$schema"]; !ok </span><span class="cov0" title="0">{
                cloned["$schema"] = DefaultJSONSchemaURI
        }</span>
        <span class="cov0" title="0">return cloned</span>
}

func cloneSchemaMap(source map[string]any) map[string]any <span class="cov0" title="0">{
        if source == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make(map[string]any, len(source))
        for key, value := range source </span><span class="cov0" title="0">{
                result[key] = cloneSchemaValue(value)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func cloneSchemaSlice(source []any) []any <span class="cov0" title="0">{
        if source == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]any, len(source))
        for i, value := range source </span><span class="cov0" title="0">{
                result[i] = cloneSchemaValue(value)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func cloneSchemaValue(value any) any <span class="cov0" title="0">{
        switch typed := value.(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                return cloneSchemaMap(typed)</span>
        case []any:<span class="cov0" title="0">
                return cloneSchemaSlice(typed)</span>
        default:<span class="cov0" title="0">
                return typed</span>
        }
}

// ToolDefinition mirrors the spec-defined Tool metadata exposed to clients.
type ToolDefinition struct {
        Name          string         `json:"name"`
        Title         string         `json:"title,omitempty"`
        Description   string         `json:"description,omitempty"`
        InputSchema   map[string]any `json:"inputSchema,omitempty"`
        OutputSchema  map[string]any `json:"outputSchema,omitempty"`
        Annotations   map[string]any `json:"annotations,omitempty"`
        StructuredKey string         `json:"structuredResultKey,omitempty"`
}

// PromptDefinition describes a prompt for the MCP client.
type PromptDefinition struct {
        Name        string           `json:"name"`
        Title       string           `json:"title,omitempty"`
        Description string           `json:"description,omitempty"`
        Arguments   []PromptArgument `json:"arguments,omitempty"`
        Annotations map[string]any   `json:"annotations,omitempty"`
}

// ResourceDefinition describes a resource for the MCP client.
type ResourceDefinition struct {
        URI         string         `json:"uri"`
        Name        string         `json:"name"`
        Title       string         `json:"title,omitempty"`
        Description string         `json:"description,omitempty"`
        MimeType    string         `json:"mimeType,omitempty"`
        Annotations map[string]any `json:"annotations,omitempty"`
        Size        *int64         `json:"size,omitempty"`
}

// SamplingRecord captures a server-initiated sampling exchange with the client.
type SamplingRecord struct {
        Timestamp time.Time      `json:"timestamp"`
        Params    map[string]any `json:"params"`
        Result    map[string]any `json:"result,omitempty"`
}

// ElicitationRecord captures an elicitation interaction with the client.
type ElicitationRecord struct {
        Timestamp time.Time      `json:"timestamp"`
        Params    map[string]any `json:"params"`
        Result    map[string]any `json:"result,omitempty"`
}

// ResourceTemplateDefinition describes a templated resource entry point exposed by the server.
type ResourceTemplateDefinition struct {
        Name        string         `json:"name"`
        Title       string         `json:"title,omitempty"`
        Description string         `json:"description,omitempty"`
        URITemplate string         `json:"uriTemplate"`
        InputSchema map[string]any `json:"inputSchema,omitempty"`
        Annotations map[string]any `json:"annotations,omitempty"`
}

// Error codes for MCP
const (
        InvalidParams    = -32602
        FileSystemError  = -32001
        LanguageNotFound = -32002
        SyntaxError      = -32003
        TransformFailed  = -32004
        CustomErrorStart = -32999
)

// MCPError represents an MCP protocol error
type MCPError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Data    any    `json:"data,omitempty"`
}

// ContentBlock represents a unit of textual content returned by prompts or tools.
type ContentBlock struct {
        Type        string         `json:"type"`
        Text        string         `json:"text,omitempty"`
        URI         string         `json:"uri,omitempty"`
        MimeType    string         `json:"mimeType,omitempty"`
        Data        map[string]any `json:"data,omitempty"`
        Annotations map[string]any `json:"annotations,omitempty"`
}

// CallToolResult models the standard MCP response payload for tool invocations.
type CallToolResult struct {
        Content           []ContentBlock `json:"content"`
        StructuredContent any            `json:"structuredContent,omitempty"`
        IsError           bool           `json:"isError,omitempty"`
}

// Error implements the error interface
func (e *MCPError) Error() string <span class="cov10" title="2">{
        return e.Message
}</span>

// NewMCPError creates a new MCP error
func NewMCPError(code int, message string, data any) *MCPError <span class="cov10" title="2">{
        return &amp;MCPError{
                Code:    code,
                Message: message,
                Data:    data,
        }
}</span>

// WrapError wraps an error with MCP error code
func WrapError(code int, message string, err error) *MCPError <span class="cov1" title="1">{
        data := map[string]any{
                "error": err.Error(),
        }
        return NewMCPError(code, message, data)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package mcp

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"
)

// generateSessionID creates a unique session identifier
func generateSessionID() string <span class="cov9" title="1055">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp if random fails
                return fmt.Sprintf("ses_%d", time.Now().UnixNano())
        }</span>
        <span class="cov9" title="1055">return fmt.Sprintf("ses_%s", hex.EncodeToString(bytes))</span>
}

// generateID creates a unique identifier with a prefix
func generateID(prefix string) string <span class="cov10" title="1105">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp
                return fmt.Sprintf("%s_%d", prefix, time.Now().UnixNano())
        }</span>
        <span class="cov10" title="1105">return fmt.Sprintf("%s_%s", prefix, hex.EncodeToString(bytes))</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

import (
        "time"

        "gorm.io/datatypes"
)

// Stage represents a pending code transformation
type Stage struct {
        ID        string `gorm:"primaryKey;type:varchar(20)"`
        SessionID string `gorm:"type:varchar(20);index"`

        // Operation details
        Language  string `gorm:"type:varchar(50);not null"`
        Operation string `gorm:"type:varchar(20);not null"` // query, replace, delete, etc

        // Target information
        TargetType  string         `gorm:"type:varchar(50)"`  // function, struct, class
        TargetName  string         `gorm:"type:varchar(255)"` // name pattern
        TargetQuery datatypes.JSON `gorm:"type:jsonb"`        // full query object

        // Content
        Original string `gorm:"type:text"`
        Modified string `gorm:"type:text"`
        Content  string `gorm:"type:text"` // For insert operations
        Diff     string `gorm:"type:text"`

        // Checksums for validation
        BaseDigest  string `gorm:"type:varchar(64)"` // SHA256 of original
        AfterDigest string `gorm:"type:varchar(64)"` // SHA256 of modified

        // Confidence scoring
        ConfidenceScore   float64        `gorm:"type:decimal(3,2)"`
        ConfidenceLevel   string         `gorm:"type:varchar(10)"`
        ConfidenceFactors datatypes.JSON `gorm:"type:jsonb"`

        // Scope AST for advanced operations
        ScopeAST datatypes.JSON `gorm:"type:jsonb"`

        // Status tracking
        Status    string    `gorm:"type:varchar(20);default:'pending'"`
        CreatedAt time.Time `gorm:"autoCreateTime"`
        ExpiresAt time.Time `gorm:"index"`
        AppliedAt *time.Time

        // Relationships
        Apply *Apply `gorm:"foreignKey:StageID"`
}

// Apply represents a committed transformation
type Apply struct {
        ID      string `gorm:"primaryKey;type:varchar(20)"`
        StageID string `gorm:"type:varchar(20);uniqueIndex"`

        // Checksums for validation
        BaseDigest  string `gorm:"type:varchar(64)"` // SHA256 of original
        AfterDigest string `gorm:"type:varchar(64)"` // SHA256 of modified

        // Metadata
        AutoApplied bool      `gorm:"default:false"`
        AppliedBy   string    `gorm:"type:varchar(100)"` // User or "auto"
        AppliedAt   time.Time `gorm:"autoCreateTime"`

        // Revert tracking
        Reverted   bool   `gorm:"default:false"`
        RevertedBy string `gorm:"type:varchar(100)"`
        RevertedAt *time.Time

        // Relationship
        Stage Stage `gorm:"foreignKey:StageID"`
}

// Session tracks a complete Morfx transformation session
type Session struct {
        ID        string    `gorm:"primaryKey;type:varchar(20)"`
        StartedAt time.Time `gorm:"autoCreateTime"`
        EndedAt   *time.Time

        // Statistics
        StagesCount  int `gorm:"default:0"`
        AppliesCount int `gorm:"default:0"`

        // Client info
        ClientInfo datatypes.JSON `gorm:"type:jsonb"`
}

// TableName customizations for cleaner names
func (Stage) TableName() string   <span class="cov10" title="10">{ return "stages" }</span>
func (Apply) TableName() string   <span class="cov10" title="10">{ return "applies" }</span>
func (Session) TableName() string <span class="cov10" title="10">{ return "sessions" }</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package base

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "sync"
        "sync/atomic"
        "time"

        sitter "github.com/smacker/go-tree-sitter"
)

// ASTCache is a lock-free cache for parsed ASTs (shared across all providers)
type ASTCache struct {
        cache       sync.Map // Lock-free concurrent map
        hits        atomic.Int64
        misses      atomic.Int64
        evictions   atomic.Int64
        maxAge      time.Duration
        cleanupOnce sync.Once // Ensures only one cleanup goroutine runs
}

// CachedAST holds parsed tree with metadata
type CachedAST struct {
        tree      *sitter.Tree
        source    []byte
        hash      string
        timestamp time.Time
        hitCount  atomic.Int32
}

// GlobalCache is the singleton cache instance shared across all providers
var GlobalCache = &amp;ASTCache{
        maxAge: 5 * time.Minute,
}

// GetOrParse returns cached AST or parses new one
func (c *ASTCache) GetOrParse(parser *sitter.Parser, source []byte) (*sitter.Tree, bool) <span class="cov10" title="436">{
        // Calculate hash
        hash := c.hash(source)

        // Try cache first (lock-free read)
        if cached, ok := c.cache.Load(hash); ok </span><span class="cov9" title="414">{
                c.hits.Add(1)
                ast := cached.(*CachedAST)
                ast.hitCount.Add(1)

                // Check if expired
                if time.Since(ast.timestamp) &gt; c.maxAge </span><span class="cov0" title="0">{
                        c.cache.Delete(hash)
                        c.evictions.Add(1)
                        ast.tree.Close()
                }</span> else<span class="cov9" title="414"> {
                        return ast.tree.Copy(), true
                }</span>
        }

        <span class="cov5" title="22">c.misses.Add(1)

        // Parse new tree using ParseCtx
        tree, err := parser.ParseCtx(context.TODO(), nil, source)
        if err != nil || tree == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Store in cache (lock-free write)
        <span class="cov5" title="22">cachedAST := &amp;CachedAST{
                tree:      tree.Copy(),
                source:    source,
                hash:      hash,
                timestamp: time.Now(),
        }

        if _, loaded := c.cache.LoadOrStore(hash, cachedAST); loaded </span><span class="cov0" title="0">{
                // Another goroutine populated the cache first. Release our stored copy
                // and continue returning the freshly parsed tree to the caller.
                cachedAST.tree.Close()
                return tree, false
        }</span>

        // Start single cleanup goroutine on first miss
        <span class="cov5" title="22">c.cleanupOnce.Do(func() </span><span class="cov1" title="1">{
                go c.cleanupOldEntries()
        }</span>)

        <span class="cov5" title="22">return tree, false</span>
}

// hash generates SHA256 for source
func (c *ASTCache) hash(source []byte) string <span class="cov10" title="436">{
        hash := sha256.Sum256(source)
        return hex.EncodeToString(hash[:])
}</span>

// cleanupOldEntries removes expired entries
func (c *ASTCache) cleanupOldEntries() <span class="cov1" title="1">{
        c.cache.Range(func(key, value any) bool </span><span class="cov1" title="1">{
                ast := value.(*CachedAST)
                if time.Since(ast.timestamp) &gt; c.maxAge </span><span class="cov0" title="0">{
                        c.cache.Delete(key)
                        ast.tree.Close()
                        c.evictions.Add(1)
                }</span>
                <span class="cov1" title="1">return true</span>
        })
}

// Stats returns cache statistics
func (c *ASTCache) Stats() map[string]int64 <span class="cov2" title="2">{
        return map[string]int64{
                "hits":      c.hits.Load(),
                "misses":    c.misses.Load(),
                "evictions": c.evictions.Load(),
                "hit_rate":  c.hits.Load() * 100 / (c.hits.Load() + c.misses.Load() + 1),
        }
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package base

import (
        "fmt"
        "path"
        "slices"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/pmezard/go-difflib/difflib"
        sitter "github.com/smacker/go-tree-sitter"

        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/providers"
)

// LanguageConfig defines language-specific behavior that must be implemented
type LanguageConfig interface {
        // Metadata
        Language() string
        Extensions() []string
        GetLanguage() *sitter.Language

        // Language-specific AST mapping
        MapQueryTypeToNodeTypes(queryType string) []string
        ExtractNodeName(node *sitter.Node, source string) string
        IsExported(name string) bool // For confidence calculation

        // For discovery/specification
        SupportedQueryTypes() []string
}

// Provider provides common functionality for all language providers
type Provider struct {
        config LanguageConfig
        cache  *ASTCache
        pool   *sync.Pool
        stats  providerStats
}

type providerStats struct {
        borrowCount atomic.Int64
        returnCount atomic.Int64
        active      atomic.Int64
}

// New creates a base provider with language-specific config
func New(config LanguageConfig) *Provider <span class="cov4" title="26">{
        lang := config.GetLanguage()
        if lang == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load %s language for tree-sitter", config.Language()))</span>
        }

        <span class="cov4" title="26">pool := &amp;sync.Pool{
                New: func() any </span><span class="cov5" title="138">{
                        parser := sitter.NewParser()
                        parser.SetLanguage(lang)
                        return parser
                }</span>,
        }

        <span class="cov4" title="26">return &amp;Provider{
                config: config,
                cache:  GlobalCache,
                pool:   pool,
        }</span>
}

// Language returns language identifier
func (p *Provider) Language() string <span class="cov1" title="1">{
        return p.config.Language()
}</span>

// Extensions returns supported file extensions
func (p *Provider) Extensions() []string <span class="cov1" title="1">{
        return p.config.Extensions()
}</span>

// SupportedQueryTypes lists human-friendly query types/aliases
func (p *Provider) SupportedQueryTypes() []string <span class="cov0" title="0">{
        return p.config.SupportedQueryTypes()
}</span>

// borrowParser retrieves a parser instance from the pool.
func (p *Provider) borrowParser() *sitter.Parser <span class="cov6" title="428">{
        parser := p.pool.Get().(*sitter.Parser)
        p.stats.borrowCount.Add(1)
        p.stats.active.Add(1)
        return parser
}</span>

// releaseParser returns a parser instance to the pool.
func (p *Provider) releaseParser(parser *sitter.Parser) <span class="cov6" title="428">{
        if parser != nil </span><span class="cov6" title="428">{
                p.stats.returnCount.Add(1)
                p.stats.active.Add(-1)
                p.pool.Put(parser)
        }</span>
}

// Stats returns the current parser pool metrics for this provider.
func (p *Provider) Stats() providers.Stats <span class="cov1" title="1">{
        return providers.Stats{
                BorrowCount: p.stats.borrowCount.Load(),
                ReturnCount: p.stats.returnCount.Load(),
                Active:      p.stats.active.Load(),
        }
}</span>

// Query finds code elements matching the query
func (p *Provider) Query(source string, query core.AgentQuery) core.QueryResult <span class="cov6" title="412">{
        parser := p.borrowParser()
        defer p.releaseParser(parser)

        tree, hit := p.cache.GetOrParse(parser, []byte(source))
        if tree == nil </span><span class="cov0" title="0">{
                if hit </span><span class="cov0" title="0">{
                        return core.QueryResult{Error: fmt.Errorf("failed to copy cached tree")}
                }</span>
                <span class="cov0" title="0">return core.QueryResult{Error: fmt.Errorf("failed to parse source")}</span>
        }
        <span class="cov6" title="412">defer tree.Close()

        // Check for syntax errors first
        var errors []string
        p.findErrors(tree.RootNode(), source, &amp;errors)
        if len(errors) &gt; 0 </span><span class="cov1" title="1">{
                return core.QueryResult{Error: fmt.Errorf("syntax errors in source: %v", errors)}
        }</span>

        <span class="cov6" title="411">var matches []core.Match
        p.walkTree(tree.RootNode(), source, query, &amp;matches)

        return core.QueryResult{
                Matches: matches,
                Total:   len(matches),
        }</span>
}

// walkTree recursively walks AST looking for matches
func (p *Provider) walkTree(node *sitter.Node, source string, query core.AgentQuery, matches *[]core.Match) <span class="cov9" title="14195">{
        if match := p.checkNode(node, source, query); match != nil </span><span class="cov7" title="1210">{
                *matches = append(*matches, *match)
        }</span>

        <span class="cov9" title="14195">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov9" title="13784">{
                child := node.Child(i)
                p.walkTree(child, source, query, matches)
        }</span>
}

// checkNode checks if a node matches the query using language-specific mapping
func (p *Provider) checkNode(node *sitter.Node, source string, query core.AgentQuery) *core.Match <span class="cov9" title="14195">{
        nodeType := node.Type()

        // Get valid node types for this query from language config
        validTypes := p.config.MapQueryTypeToNodeTypes(query.Type)
        if !slices.Contains(validTypes, nodeType) </span><span class="cov9" title="12982">{
                return nil
        }</span>

        // Extract name using language-specific logic
        <span class="cov7" title="1213">name := p.config.ExtractNodeName(node, source)
        if name == "" </span><span class="cov0" title="0">{
                name = "anonymous"
        }</span>

        // Check name pattern
        <span class="cov7" title="1213">if !p.matchesPattern(name, query.Name) </span><span class="cov2" title="3">{
                return nil
        }</span>

        <span class="cov7" title="1210">return &amp;core.Match{
                Type: query.Type,
                Name: name,
                Location: core.Location{
                        Line:      int(node.StartPoint().Row) + 1,
                        Column:    int(node.StartPoint().Column) + 1,
                        EndLine:   int(node.EndPoint().Row) + 1,
                        EndColumn: int(node.EndPoint().Column) + 1,
                },
                Content: source[node.StartByte():node.EndByte()],
        }</span>
}

// Transform applies a transformation operation
func (p *Provider) Transform(source string, op core.TransformOp) core.TransformResult <span class="cov3" title="13">{
        parser := p.borrowParser()
        defer p.releaseParser(parser)

        tree, hit := p.cache.GetOrParse(parser, []byte(source))
        if tree == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("failed to parse source")
                if hit </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to copy cached tree")
                }</span>
                <span class="cov0" title="0">return core.TransformResult{Error: err}</span>
        }
        <span class="cov3" title="13">defer tree.Close()

        // Find targets
        matches := p.findTargets(tree.RootNode(), source, op.Target)
        if len(matches) == 0 </span><span class="cov1" title="2">{
                return core.TransformResult{
                        Error: fmt.Errorf("no matches found for target"),
                }
        }</span>

        // Extract nodes for transformation operations
        <span class="cov3" title="11">nodes := make([]*sitter.Node, len(matches))
        for i, match := range matches </span><span class="cov3" title="16">{
                nodes[i] = match.Node
        }</span>

        // Calculate confidence
        <span class="cov3" title="11">confidence := p.calculateConfidence(op, nodes, source)
        var (
                modified string
                err      error
        )

        switch op.Method </span>{
        case "replace":<span class="cov2" title="5">
                modified, err = p.doReplace(source, nodes, op.Replacement)</span>
        case "delete":<span class="cov1" title="2">
                modified, err = p.doDelete(source, nodes)</span>
        case "insert_before":<span class="cov1" title="1">
                modified, err = p.doInsertBefore(source, nodes, op.Content)</span>
        case "insert_after":<span class="cov1" title="1">
                modified, err = p.doInsertAfter(source, nodes, op.Content)</span>
        case "append":<span class="cov1" title="1">
                modified, err = p.doAppendToTarget(source, nodes, op.Content)</span>
        default:<span class="cov1" title="1">
                return core.TransformResult{
                        Error: fmt.Errorf("unknown transform method: %s", op.Method),
                }</span>
        }

        <span class="cov3" title="10">if err != nil </span><span class="cov0" title="0">{
                return core.TransformResult{Error: err}
        }</span>

        // Generate diff
        <span class="cov3" title="10">diff := p.generateDiff(source, modified)

        return core.TransformResult{
                Modified:   modified,
                Diff:       diff,
                Confidence: confidence,
                MatchCount: len(matches), // Now shows actual match count including expansions
        }</span>
}

// Validate checks syntax
func (p *Provider) Validate(source string) providers.ValidationResult <span class="cov2" title="3">{
        parser := p.borrowParser()
        defer p.releaseParser(parser)

        tree := parser.Parse(nil, []byte(source))
        if tree == nil </span><span class="cov0" title="0">{
                return providers.ValidationResult{
                        Valid:  false,
                        Errors: []string{"Failed to parse source"},
                }
        }</span>
        <span class="cov2" title="3">defer tree.Close()

        var errors []string
        p.findErrors(tree.RootNode(), source, &amp;errors)

        return providers.ValidationResult{
                Valid:  len(errors) == 0,
                Errors: errors,
        }</span>
}

// matchesPattern checks if name matches pattern (with wildcards)
func (p *Provider) matchesPattern(name, pattern string) bool <span class="cov7" title="1231">{
        if pattern == "" || pattern == "*" </span><span class="cov7" title="1202">{
                return true
        }</span>

        <span class="cov4" title="29">matched, err := path.Match(pattern, name)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="29">return matched</span>
}

// findTargets finds all matches for the query with proper expansion
func (p *Provider) findTargets(root *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov3" title="13">{
        var matches []core.CodeMatch

        var walk func(*sitter.Node)
        walk = func(node *sitter.Node) </span><span class="cov6" title="338">{
                if p.nodeMatches(node, source, query) </span><span class="cov3" title="16">{
                        // Expand node into multiple matches if needed
                        expanded := p.expandMatches(node, source, query)
                        matches = append(matches, expanded...)
                }</span>
                <span class="cov6" title="338">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov6" title="325">{
                        walk(node.Child(i))
                }</span>
        }

        <span class="cov3" title="13">walk(root)
        return matches</span>
}

// expandMatches converts a node into one or more matches
func (p *Provider) expandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov3" title="16">{
        // Check if provider has custom expansion logic
        if expander, ok := p.config.(interface {
                ExpandMatches(*sitter.Node, string, core.AgentQuery) []core.CodeMatch
        }); ok </span><span class="cov0" title="0">{
                return expander.ExpandMatches(node, source, query)
        }</span>

        // Default: single match
        <span class="cov3" title="16">name := p.config.ExtractNodeName(node, source)
        return []core.CodeMatch{{
                Node:      node,
                Name:      name,
                Type:      query.Type,
                NodeType:  node.Type(),
                StartByte: node.StartByte(),
                EndByte:   node.EndByte(),
                Line:      node.StartPoint().Row,
                Column:    node.StartPoint().Column,
        }}</span>
}

// nodeMatches checks if a node matches the query with provider-specific validation
func (p *Provider) nodeMatches(node *sitter.Node, source string, query core.AgentQuery) bool <span class="cov6" title="338">{
        nodeTypes := p.config.MapQueryTypeToNodeTypes(query.Type)
        typeMatches := slices.Contains(nodeTypes, node.Type())

        if !typeMatches </span><span class="cov6" title="320">{
                return false
        }</span>

        // Provider-specific validation (e.g., Go struct vs interface in type_spec)
        <span class="cov3" title="18">if validator, ok := p.config.(interface {
                ValidateTypeSpec(*sitter.Node, string, string) bool
        }); ok </span><span class="cov0" title="0">{
                if !validator.ValidateTypeSpec(node, source, query.Type) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov3" title="18">if query.Name != "" </span><span class="cov3" title="18">{
                name := p.config.ExtractNodeName(node, source)
                if !p.matchesPattern(name, query.Name) </span><span class="cov1" title="2">{
                        return false
                }</span>
        }

        <span class="cov3" title="16">return true</span>
}

// sortTargetsDescending sorts nodes by start byte in descending order (reverse)
func sortTargetsDescending(targets []*sitter.Node) []*sitter.Node <span class="cov3" title="9">{
        sorted := make([]*sitter.Node, len(targets))
        copy(sorted, targets)
        slices.SortFunc(sorted, func(a, b *sitter.Node) int </span><span class="cov2" title="5">{
                return int(b.StartByte() - a.StartByte()) // Reverse order
        }</span>)
        <span class="cov3" title="9">return sorted</span>
}

// doReplace performs replacement transformation
func (p *Provider) doReplace(source string, targets []*sitter.Node, replacement string) (string, error) <span class="cov2" title="7">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return source, fmt.Errorf("no targets to replace")
        }</span>

        // Sort targets by position (reverse order to maintain positions)
        <span class="cov2" title="7">sortedTargets := sortTargetsDescending(targets)

        // Replace each target (from end to start to preserve positions)
        result := source
        for _, target := range sortedTargets </span><span class="cov3" title="12">{
                startPos := int(target.StartByte())
                endPos := int(target.EndByte())

                // Safety bounds check
                if startPos &gt; len(result) || endPos &gt; len(result) || startPos &lt; 0 || endPos &lt; 0 </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov3" title="11">before := result[:startPos]
                after := result[endPos:]
                result = before + replacement + after</span>
        }

        <span class="cov2" title="7">return result, nil</span>
}

// doDelete performs deletion transformation
func (p *Provider) doDelete(source string, targets []*sitter.Node) (string, error) <span class="cov1" title="2">{
        return p.doReplace(source, targets, "")
}</span>

// doInsertBefore performs insertion before target
func (p *Provider) doInsertBefore(source string, targets []*sitter.Node, content string) (string, error) <span class="cov1" title="1">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return source, fmt.Errorf("no targets for insertion")
        }</span>

        // Sort targets reverse order
        <span class="cov1" title="1">sortedTargets := sortTargetsDescending(targets)

        // Insert before each target (from end to start to preserve positions)
        result := source
        for _, target := range sortedTargets </span><span class="cov1" title="1">{
                startPos := int(target.StartByte())

                // Safety bounds check
                if startPos &gt; len(result) || startPos &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">before := result[:startPos]
                after := result[startPos:]

                // Preserve indentation
                indent := p.getIndentation(source, target)
                contentWithIndent := indent + content + "\n"

                result = before + contentWithIndent + after</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

// doInsertAfter performs insertion after target
func (p *Provider) doInsertAfter(source string, targets []*sitter.Node, content string) (string, error) <span class="cov1" title="1">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return source, fmt.Errorf("no targets for insertion")
        }</span>

        // Sort targets reverse order
        <span class="cov1" title="1">sortedTargets := sortTargetsDescending(targets)

        // Insert after each target (from end to start to preserve positions)
        result := source
        for _, target := range sortedTargets </span><span class="cov1" title="1">{
                endPos := int(target.EndByte())

                // Safety bounds check
                if endPos &gt; len(result) || endPos &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">before := result[:endPos]
                after := result[endPos:]

                // Preserve indentation
                indent := p.getIndentation(source, target)
                contentWithIndent := "\n" + indent + content

                result = before + contentWithIndent + after</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

// doAppendToTarget appends content to the end of target scope
func (p *Provider) doAppendToTarget(source string, targets []*sitter.Node, content string) (string, error) <span class="cov1" title="1">{
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return source, fmt.Errorf("no targets for append")
        }</span>

        // For append, we only use first target
        <span class="cov1" title="1">target := targets[0]

        // This is language-agnostic - append after target
        insertPos := target.EndByte()

        before := source[:insertPos]
        after := source[insertPos:]

        // Add proper formatting
        insertion := "\n\n" + content

        return before + insertion + after, nil</span>
}

// getIndentation extracts indentation for a node
func (p *Provider) getIndentation(source string, node *sitter.Node) string <span class="cov1" title="2">{
        line := node.StartPoint().Row
        lineStart := 0
        currentLine := uint32(0)

        // Find start of the line
        for i, ch := range source </span><span class="cov4" title="32">{
                if currentLine == line </span><span class="cov1" title="2">{
                        lineStart = i
                        break</span>
                }
                <span class="cov4" title="30">if ch == '\n' </span><span class="cov2" title="6">{
                        currentLine++
                }</span>
        }

        // Extract indentation
        <span class="cov1" title="2">indent := ""
        for i := lineStart; i &lt; len(source); i++ </span><span class="cov1" title="2">{
                if source[i] == ' ' || source[i] == '\t' </span><span class="cov0" title="0">{
                        indent += string(source[i])
                }</span> else<span class="cov1" title="2"> {
                        break</span>
                }
        }

        <span class="cov1" title="2">return indent</span>
}

// calculateConfidence calculates transformation confidence
func (p *Provider) calculateConfidence(
        op core.TransformOp,
        targets []*sitter.Node,
        source string,
) core.ConfidenceScore <span class="cov3" title="11">{
        score := 1.0
        factors := []core.ConfidenceFactor{}

        // Factor 1: Number of targets
        if len(targets) == 1 </span><span class="cov3" title="10">{
                score += 0.1
                factors = append(factors, core.ConfidenceFactor{
                        Name:   "single_target",
                        Impact: 0.1,
                        Reason: "Only one target found, unambiguous",
                })
        }</span> else<span class="cov1" title="1"> if len(targets) &gt; 5 </span><span class="cov1" title="1">{
                score -= 0.3
                factors = append(factors, core.ConfidenceFactor{
                        Name:   "multiple_targets",
                        Impact: -0.3,
                        Reason: fmt.Sprintf("Operation affects %d locations", len(targets)),
                })
        }</span>

        // Factor 2: Operation type
        <span class="cov3" title="11">switch op.Method </span>{
        case "delete":<span class="cov1" title="2">
                score -= 0.2
                factors = append(factors, core.ConfidenceFactor{
                        Name:   "delete_operation",
                        Impact: -0.2,
                        Reason: "Delete operations are destructive",
                })
                // Check if deleting exported function
                if len(targets) &gt; 0 </span><span class="cov1" title="2">{
                        name := p.config.ExtractNodeName(targets[0], source)
                        if p.config.IsExported(name) </span><span class="cov1" title="2">{
                                score -= 0.3
                                factors = append(factors, core.ConfidenceFactor{
                                        Name:   "delete_exported_api",
                                        Impact: -0.3,
                                        Reason: "Deleting exported API is dangerous",
                                })
                        }</span>
                }
        case "replace":<span class="cov2" title="5">
                // Check if replacing exported function using language-specific logic
                if len(targets) &gt; 0 </span><span class="cov2" title="5">{
                        name := p.config.ExtractNodeName(targets[0], source)
                        if p.config.IsExported(name) </span><span class="cov2" title="5">{
                                score -= 0.2
                                factors = append(factors, core.ConfidenceFactor{
                                        Name:   "exported_api",
                                        Impact: -0.2,
                                        Reason: "Modifying exported API",
                                })
                        }</span>
                }
        }

        // Factor 3: Pattern specificity
        <span class="cov3" title="11">if strings.Contains(op.Target.Name, "*") </span><span class="cov1" title="1">{
                score -= 0.15
                factors = append(factors, core.ConfidenceFactor{
                        Name:   "wildcard_pattern",
                        Impact: -0.15,
                        Reason: "Wildcard patterns may match unintended targets",
                })
        }</span>

        // Normalize score
        <span class="cov3" title="11">if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span> else<span class="cov3" title="11"> if score &gt; 1 </span><span class="cov2" title="4">{
                score = 1
        }</span>

        // Determine level
        <span class="cov3" title="11">level := "high"
        if score &lt; 0.8 </span><span class="cov2" title="3">{
                level = "medium"
        }</span>
        <span class="cov3" title="11">if score &lt; 0.5 </span><span class="cov1" title="1">{
                level = "low"
        }</span>

        <span class="cov3" title="11">return core.ConfidenceScore{
                Score:   score,
                Level:   level,
                Factors: factors,
        }</span>
}

// generateDiff creates a unified diff
func (p *Provider) generateDiff(original, modified string) string <span class="cov3" title="10">{
        if original == modified </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov3" title="9">diff := difflib.UnifiedDiff{
                A:        strings.Split(original, "\n"),
                B:        strings.Split(modified, "\n"),
                FromFile: "original",
                ToFile:   "modified",
                Context:  3,
        }

        text, err := difflib.GetUnifiedDiffString(diff)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("--- original\n+++ modified\n@@ changes @@\n%d bytes -&gt; %d bytes",
                        len(original), len(modified))
        }</span>

        <span class="cov3" title="9">return text</span>
}

// findErrors looks for syntax errors in AST
func (p *Provider) findErrors(node *sitter.Node, source string, errors *[]string) <span class="cov10" title="14269">{
        if node.Type() == "ERROR" </span><span class="cov1" title="1">{
                *errors = append(*errors, fmt.Sprintf(
                        "Syntax error at line %d, column %d",
                        node.StartPoint().Row+1,
                        node.StartPoint().Column+1,
                ))
        }</span>

        <span class="cov10" title="14269">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov9" title="13854">{
                p.findErrors(node.Child(i), source, errors)
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package catalog

import (
        "sort"
        "strings"
        "sync"
)

// LanguageInfo captures metadata about a language provider.
type LanguageInfo struct {
        ID         string
        Extensions []string
}

var (
        mu     sync.RWMutex
        byLang = make(map[string]LanguageInfo)
        byExt  = make(map[string]LanguageInfo)
)

// Register stores language metadata for extension lookups. Subsequent
// registrations for the same language overwrite prior data to keep the catalog
// in sync with the latest provider definition.
func Register(info LanguageInfo) <span class="cov1" title="1">{
        if info.ID == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">normalized := uniqueExtensions(info.Extensions)
        info.Extensions = normalized

        mu.Lock()
        defer mu.Unlock()

        byLang[strings.ToLower(info.ID)] = info
        for _, ext := range normalized </span><span class="cov10" title="3">{
                byExt[ext] = info
        }</span>
}

// LookupByExtension returns the language info associated with a file extension.
func LookupByExtension(ext string) (LanguageInfo, bool) <span class="cov10" title="3">{
        mu.RLock()
        defer mu.RUnlock()
        info, ok := byExt[strings.ToLower(ext)]
        return info, ok
}</span>

// Languages returns all registered language infos sorted by language ID.
func Languages() []LanguageInfo <span class="cov1" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        infos := make([]LanguageInfo, 0, len(byLang))
        for _, info := range byLang </span><span class="cov1" title="1">{
                infos = append(infos, info)
        }</span>

        <span class="cov1" title="1">sort.Slice(infos, func(i, j int) bool </span><span class="cov0" title="0">{
                return infos[i].ID &lt; infos[j].ID
        }</span>)
        <span class="cov1" title="1">return infos</span>
}

func uniqueExtensions(exts []string) []string <span class="cov1" title="1">{
        seen := make(map[string]struct{})
        result := make([]string, 0, len(exts))
        for _, ext := range exts </span><span class="cov10" title="3">{
                normalized := strings.ToLower(strings.TrimSpace(ext))
                if normalized == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="3">if !strings.HasPrefix(normalized, ".") </span><span class="cov1" title="1">{
                        normalized = "." + normalized
                }</span>
                <span class="cov10" title="3">if _, ok := seen[normalized]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="3">seen[normalized] = struct{}{}
                result = append(result, normalized)</span>
        }
        <span class="cov1" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package providers

import (
        "github.com/termfx/morfx/core"
        "github.com/termfx/morfx/providers/catalog"
)

// Provider interface for language-specific implementations
type Provider interface {
        // Metadata
        Language() string
        Extensions() []string
        SupportedQueryTypes() []string

        // Core operations
        Query(source string, query core.AgentQuery) core.QueryResult
        Transform(source string, op core.TransformOp) core.TransformResult
        Validate(source string) ValidationResult

        // Observability
        Stats() Stats
}

// ValidationResult from syntax check
type ValidationResult struct {
        Valid  bool     `json:"valid"`
        Errors []string `json:"errors,omitempty"`
}

// Registry manages all providers
type Registry struct {
        providers map[string]Provider
}

// NewRegistry creates provider registry
func NewRegistry() *Registry <span class="cov8" title="5">{
        return &amp;Registry{
                providers: make(map[string]Provider),
        }
}</span>

// Register adds a provider
func (r *Registry) Register(provider Provider) <span class="cov10" title="7">{
        r.providers[provider.Language()] = provider
        catalog.Register(catalog.LanguageInfo{
                ID:         provider.Language(),
                Extensions: provider.Extensions(),
        })
}</span>

// Get retrieves provider by language
func (r *Registry) Get(language string) (Provider, bool) <span class="cov10" title="7">{
        p, exists := r.providers[language]
        return p, exists
}</span>

// List returns all providers
func (r *Registry) List() []Provider <span class="cov0" title="0">{
        result := make([]Provider, 0, len(r.providers))
        for _, p := range r.providers </span><span class="cov0" title="0">{
                result = append(result, p)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Languages returns all registered language identifiers
func (r *Registry) Languages() []string <span class="cov0" title="0">{
        langs := make([]string, 0, len(r.providers))
        for k := range r.providers </span><span class="cov0" title="0">{
                langs = append(langs, k)
        }</span>
        <span class="cov0" title="0">return langs</span>
}

// Stats captures parser-pool level metrics exposed by providers.
type Stats struct {
        BorrowCount int64 `json:"borrow_count"`
        ReturnCount int64 `json:"return_count"`
        Active      int64 `json:"active"`
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package golang

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/golang"

        "github.com/termfx/morfx/core"
)

// Config implements LanguageConfig for Go
type Config struct{}

// Language identifier
func (c *Config) Language() string <span class="cov1" title="2">{
        return "go"
}</span>

// Extensions supported
func (c *Config) Extensions() []string <span class="cov2" title="3">{
        return []string{".go", ".mod"}
}</span>

// GetLanguage returns tree-sitter language for Go
func (c *Config) GetLanguage() *sitter.Language <span class="cov5" title="21">{
        return golang.GetLanguage()
}</span>

// MapQueryTypeToNodeTypes maps query types to Go AST node types
func (c *Config) MapQueryTypeToNodeTypes(queryType string) []string <span class="cov10" title="577">{
        if nodes, ok := c.aliasMap()[queryType]; ok </span><span class="cov9" title="576">{
                return nodes
        }</span>
        <span class="cov1" title="1">return []string{queryType}</span>
}

func (c *Config) aliasMap() map[string][]string <span class="cov10" title="577">{
        return map[string][]string{
                "function":  {"function_declaration", "method_declaration"},
                "func":      {"function_declaration", "method_declaration"},
                "fn":        {"function_declaration", "method_declaration"},
                "struct":    {"type_spec"},
                "interface": {"type_spec"},
                "iface":     {"type_spec"},
                "variable":  {"var_declaration", "short_var_declaration"},
                "var":       {"var_declaration", "short_var_declaration"},
                "constant":  {"const_declaration"},
                "const":     {"const_declaration"},
                "import":    {"import_declaration"},
                "type":      {"type_declaration", "type_spec"},
                "method":    {"method_declaration"},
                "field":     {"field_declaration"},
                "comment":   {"comment"},
                "comments":  {"comment"},
        }
}</span>

// SupportedQueryTypes returns colloquial query types/aliases for Go
func (c *Config) SupportedQueryTypes() []string <span class="cov0" title="0">{
        m := c.aliasMap()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// ExtractNodeName extracts name from Go AST nodes
func (c *Config) ExtractNodeName(node *sitter.Node, source string) string <span class="cov5" title="18">{
        // Try standard name field first
        if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov4" title="14">{
                return source[nameNode.StartByte():nameNode.EndByte()]
        }</span>

        // Special handling for specific node types
        <span class="cov2" title="4">switch node.Type() </span>{
        case "type_spec":<span class="cov0" title="0">
                // Check if it's actually a struct or interface
                typeNode := node.ChildByFieldName("type")
                if typeNode != nil &amp;&amp; (typeNode.Type() == "struct_type" || typeNode.Type() == "interface_type") </span><span class="cov0" title="0">{
                        if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                return source[nameNode.StartByte():nameNode.EndByte()]
                        }</span>
                }
        case "import_declaration":<span class="cov1" title="1">
                // Get import path
                if pathNode := node.ChildByFieldName("path"); pathNode != nil </span><span class="cov0" title="0">{
                        path := source[pathNode.StartByte():pathNode.EndByte()]
                        return strings.Trim(path, `"`)
                }</span>
        case "var_declaration", "const_declaration", "short_var_declaration":<span class="cov2" title="3">
                // Variables can have multiple names - get first identifier for now
                // TODO: Provider should create separate matches for each variable
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov3" title="7">{
                        child := node.Child(i)
                        if child.Type() == "identifier" </span><span class="cov0" title="0">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "comment":<span class="cov0" title="0">
                return c.extractCommentContent(source[node.StartByte():node.EndByte()])</span>
        }

        // Fallback: try to find first identifier child
        <span class="cov2" title="4">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="9">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov0" title="0">{
                        return source[child.StartByte():child.EndByte()]
                }</span>
        }

        <span class="cov2" title="4">return ""</span>
}

func (c *Config) extractCommentContent(raw string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(raw)
        trimmed = strings.TrimPrefix(trimmed, "///")
        trimmed = strings.TrimPrefix(trimmed, "//")
        trimmed = strings.TrimPrefix(trimmed, "#")
        trimmed = strings.TrimPrefix(trimmed, "/*")
        trimmed = strings.TrimPrefix(trimmed, "/**")
        trimmed = strings.TrimSuffix(trimmed, "*/")
        trimmed = strings.TrimSpace(trimmed)
        if idx := strings.Index(trimmed, "\n"); idx &gt;= 0 </span><span class="cov0" title="0">{
                trimmed = trimmed[:idx]
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(strings.TrimPrefix(trimmed, "*"))</span>
}

// IsExported checks if identifier is exported (starts with capital letter in Go)
func (c *Config) IsExported(name string) bool <span class="cov4" title="10">{
        if len(name) == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="9">return name[0] &gt;= 'A' &amp;&amp; name[0] &lt;= 'Z'</span>
}

// ValidateTypeSpec checks if type_spec matches the specific query type
func (c *Config) ValidateTypeSpec(node *sitter.Node, source, queryType string) bool <span class="cov3" title="5">{
        if node.Type() != "type_spec" </span><span class="cov1" title="1">{
                return true // Not a type_spec, use default validation
        }</span>

        // Find the type definition part
        <span class="cov2" title="4">typeNode := node.ChildByFieldName("type")
        if typeNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="4">switch queryType </span>{
        case "struct":<span class="cov1" title="2">
                return typeNode.Type() == "struct_type"</span>
        case "interface":<span class="cov1" title="2">
                return typeNode.Type() == "interface_type"</span>
        default:<span class="cov0" title="0">
                return true</span> // For other queries like "type", accept any type_spec
        }
}

// ExpandMatches handles multi-variable declarations in Go
func (c *Config) ExpandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov2" title="4">{
        switch node.Type() </span>{
        case "var_declaration", "const_declaration":<span class="cov1" title="1">
                return c.expandVarDeclaration(node, source, query)</span>
        case "short_var_declaration":<span class="cov1" title="1">
                return c.expandShortVarDeclaration(node, source, query)</span>
        case "import_declaration":<span class="cov0" title="0">
                return c.expandImportDeclaration(node, source, query)</span>
        default:<span class="cov1" title="2">
                // Default single match
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        }
}

func (c *Config) expandVarDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="2">{
        var matches []core.CodeMatch

        // Find var_spec nodes within var_declaration
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov2" title="4">{
                child := node.Child(i)
                if child.Type() == "var_spec" || child.Type() == "const_spec" </span><span class="cov1" title="2">{
                        matches = append(matches, c.expandVarSpec(child, source, query)...)
                }</span>
        }

        <span class="cov1" title="2">return matches</span>
}

func (c *Config) expandVarSpec(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov2" title="3">{
        var matches []core.CodeMatch

        // var_spec contains identifiers directly (not in identifier_list)
        // Structure: var_spec -&gt; identifier, ',', identifier, type_identifier
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="14">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov3" title="7">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov2" title="3">return matches</span>
}

func (c *Config) expandShortVarDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="2">{
        var matches []core.CodeMatch

        // short_var_declaration -&gt; expression_list -&gt; identifiers
        // Structure: short_var_declaration -&gt; expression_list, ':=', expression_list
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov1" title="2">{
                child := node.Child(i)
                if child.Type() == "expression_list" </span><span class="cov1" title="2">{
                        // First expression_list contains the identifiers
                        for j := 0; j &lt; int(child.ChildCount()); j++ </span><span class="cov3" title="6">{
                                identifier := child.Child(j)
                                if identifier.Type() == "identifier" </span><span class="cov2" title="4">{
                                        name := source[identifier.StartByte():identifier.EndByte()]
                                        matches = append(matches, core.CodeMatch{
                                                Node:      identifier,
                                                Name:      name,
                                                Type:      query.Type,
                                                NodeType:  "identifier",
                                                StartByte: identifier.StartByte(),
                                                EndByte:   identifier.EndByte(),
                                                Line:      identifier.StartPoint().Row,
                                                Column:    identifier.StartPoint().Column,
                                        })
                                }</span>
                        }
                        // Only process first expression_list (left side of :=)
                        <span class="cov1" title="2">break</span>
                }
        }

        <span class="cov1" title="2">return matches</span>
}

func (c *Config) expandImportDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() != "import_spec" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var name string
                if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                        name = source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
                <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                        if pathNode := child.ChildByFieldName("path"); pathNode != nil </span><span class="cov0" title="0">{
                                // Trim quotes
                                raw := source[pathNode.StartByte():pathNode.EndByte()]
                                if len(raw) &gt;= 2 &amp;&amp; (raw[0] == '"' || raw[0] == '\'') </span><span class="cov0" title="0">{
                                        name = strings.Trim(raw, "\"'")
                                }</span> else<span class="cov0" title="0"> {
                                        name = raw
                                }</span>
                        }
                }
                <span class="cov0" title="0">matches = append(matches, core.CodeMatch{
                        Node:      child,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  child.Type(),
                        StartByte: child.StartByte(),
                        EndByte:   child.EndByte(),
                        Line:      child.StartPoint().Row,
                        Column:    child.StartPoint().Column,
                })</span>
        }

        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                // Fallback single match
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}
        }</span>

        <span class="cov0" title="0">return matches</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package golang

import (
        "github.com/termfx/morfx/providers/base"
        "github.com/termfx/morfx/providers/catalog"
)

// This package provides Go language support for morfx using the base provider.
// All the heavy lifting is done by the base provider with Go-specific configuration.

func init() <span class="cov1" title="1">{
        catalog.Register(catalog.LanguageInfo{
                ID:         "go",
                Extensions: (&amp;Config{}).Extensions(),
        })
}</span>

// New creates a Go provider using base functionality with Go-specific AST mapping
func New() *base.Provider <span class="cov10" title="12">{
        config := &amp;Config{}
        return base.New(config)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package javascript

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/javascript"

        "github.com/termfx/morfx/core"
)

// Config implements LanguageConfig for JavaScript
type Config struct{}

// Language identifier
func (c *Config) Language() string <span class="cov1" title="2">{
        return "javascript"
}</span>

// Extensions supported
func (c *Config) Extensions() []string <span class="cov1" title="2">{
        return []string{".js", ".jsx", ".mjs", ".cjs"}
}</span>

// GetLanguage returns tree-sitter language for JavaScript
func (c *Config) GetLanguage() *sitter.Language <span class="cov4" title="10">{
        return javascript.GetLanguage()
}</span>

// MapQueryTypeToNodeTypes maps query types to JavaScript AST node types
func (c *Config) MapQueryTypeToNodeTypes(queryType string) []string <span class="cov10" title="678">{
        if nodes, ok := c.aliasMap()[queryType]; ok </span><span class="cov10" title="678">{
                return nodes
        }</span>
        <span class="cov0" title="0">return []string{queryType}</span>
}

func (c *Config) aliasMap() map[string][]string <span class="cov10" title="678">{
        return map[string][]string{
                "function":    {"function_declaration", "function_expression", "arrow_function", "method_definition"},
                "func":        {"function_declaration", "function_expression", "arrow_function", "method_definition"},
                "fn":          {"function_declaration", "function_expression", "arrow_function", "method_definition"},
                "method":      {"method_definition"},
                "constructor": {"method_definition"},
                "ctor":        {"method_definition"},
                "class":       {"class_declaration", "class_expression"},
                "property":    {"field_definition"},
                "prop":        {"field_definition"},
                "field":       {"field_definition"},
                "variable":    {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "var":         {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "const":       {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "let":         {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "lambda":      {"arrow_function"},
                "arrow":       {"arrow_function"},
                "array":       {"array", "array_pattern"},
                "object":      {"object", "object_pattern"},
                "import":      {"import_statement"},
                "export":      {"export_statement"},
                "interface":   {"interface_declaration"},
                "type":        {"type_alias_declaration"},
                "decorator":   {"decorator"},
                "comment":     {"comment"},
                "comments":    {"comment"},
        }
}</span>

// SupportedQueryTypes returns colloquial query types/aliases for JavaScript
func (c *Config) SupportedQueryTypes() []string <span class="cov0" title="0">{
        m := c.aliasMap()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// ExtractNodeName extracts name from JavaScript AST nodes
func (c *Config) ExtractNodeName(node *sitter.Node, source string) string <span class="cov5" title="29">{
        switch node.Type() </span>{
        case "function_declaration":<span class="cov3" title="6">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov3" title="6">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "class_declaration", "class_expression":<span class="cov2" title="4">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov2" title="4">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "method_definition":<span class="cov2" title="3">
                if keyNode := node.ChildByFieldName("key"); keyNode != nil </span><span class="cov0" title="0">{
                        return source[keyNode.StartByte():keyNode.EndByte()]
                }</span>
        case "field_definition":<span class="cov0" title="0">
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                        child := node.Child(i)
                        if child.Type() == "property_identifier" </span><span class="cov0" title="0">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "variable_declarator":<span class="cov3" title="7">
                if idNode := node.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                        return source[idNode.StartByte():idNode.EndByte()]
                }</span>
        case "lexical_declaration":<span class="cov3" title="6">
                // Find first variable declarator
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="18">{
                        child := node.Child(i)
                        if child.Type() == "variable_declarator" </span><span class="cov3" title="6">{
                                if idNode := child.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                                        return source[idNode.StartByte():idNode.EndByte()]
                                }</span>
                        }
                }
        case "import_statement", "export_statement":<span class="cov0" title="0">
                // Get import/export source
                if sourceNode := node.ChildByFieldName("source"); sourceNode != nil </span><span class="cov0" title="0">{
                        path := source[sourceNode.StartByte():sourceNode.EndByte()]
                        return strings.Trim(path, `"'`)
                }</span>
        case "arrow_function", "function_expression":<span class="cov1" title="2">
                // Try to infer name from assignment or context
                return c.getArrowFunctionName(node, source)</span>
        case "comment":<span class="cov0" title="0">
                return c.commentSummary(source[node.StartByte():node.EndByte()])</span>
        }

        // Fallback: try to find first identifier child
        <span class="cov4" title="17">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov6" title="40">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov3" title="7">{
                        return source[child.StartByte():child.EndByte()]
                }</span>
        }

        <span class="cov4" title="10">return ""</span>
}

func (c *Config) commentSummary(raw string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(raw)
        trimmed = strings.TrimPrefix(trimmed, "///")
        trimmed = strings.TrimPrefix(trimmed, "//")
        trimmed = strings.TrimPrefix(trimmed, "/*")
        trimmed = strings.TrimPrefix(trimmed, "/**")
        trimmed = strings.TrimSuffix(trimmed, "*/")
        trimmed = strings.TrimPrefix(trimmed, "#")
        trimmed = strings.TrimSpace(trimmed)
        if idx := strings.Index(trimmed, "\n"); idx &gt;= 0 </span><span class="cov0" title="0">{
                trimmed = trimmed[:idx]
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(strings.TrimPrefix(trimmed, "*"))</span>
}

// IsExported checks if identifier is exported (in JS, typically uppercase or starts with capital)
func (c *Config) IsExported(name string) bool <span class="cov1" title="1">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // In JavaScript, we consider functions/classes starting with capital as "exported/public"
        // or check for common export patterns
        <span class="cov1" title="1">return name[0] &gt;= 'A' &amp;&amp; name[0] &lt;= 'Z'</span>
}

// ExpandMatches handles destructuring and multi-variable declarations in JavaScript
func (c *Config) ExpandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="1">{
        switch node.Type() </span>{
        case "variable_declaration", "lexical_declaration":<span class="cov0" title="0">
                return c.expandVariableDeclaration(node, source, query)</span>
        case "variable_declarator":<span class="cov0" title="0">
                return c.expandVariableDeclarator(node, source, query)</span>
        case "arrow_function":<span class="cov0" title="0">
                // Fix arrow function names
                name := c.getArrowFunctionName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        case "import_statement":<span class="cov0" title="0">
                return c.expandImportStatement(node, source, query)</span>
        case "export_statement":<span class="cov0" title="0">
                return c.expandExportStatement(node, source, query)</span>
        default:<span class="cov1" title="1">
                // Default single match
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        }
}

func (c *Config) expandVariableDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "variable_declarator" </span><span class="cov0" title="0">{
                        matches = append(matches, c.expandVariableDeclarator(child, source, query)...)
                }</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandVariableDeclarator(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        idNode := node.ChildByFieldName("id")
        if idNode == nil </span><span class="cov0" title="0">{
                return matches
        }</span>

        <span class="cov0" title="0">switch idNode.Type() </span>{
        case "identifier":<span class="cov0" title="0">
                name := source[idNode.StartByte():idNode.EndByte()]
                matches = append(matches, core.CodeMatch{
                        Node:      idNode,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  "identifier",
                        StartByte: idNode.StartByte(),
                        EndByte:   idNode.EndByte(),
                        Line:      idNode.StartPoint().Row,
                        Column:    idNode.StartPoint().Column,
                })</span>
        case "array_pattern":<span class="cov0" title="0">
                matches = append(matches, c.expandArrayPattern(idNode, source, query)...)</span>
        case "object_pattern":<span class="cov0" title="0">
                matches = append(matches, c.expandObjectPattern(idNode, source, query)...)</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandImportStatement(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        // Try to capture each imported binding or namespace
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                switch child.Type() </span>{
                case "import_specifier":<span class="cov0" title="0">
                        // import { a as b } from 'x'
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                case "namespace_import":<span class="cov0" title="0">
                        // import * as ns from 'x'
                        if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandExportStatement(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        // Handle named exports: export { a as b }
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "export_specifier" </span><span class="cov0" title="0">{
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandArrayPattern(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov0" title="0">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandObjectPattern(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                switch child.Type() </span>{
                case "shorthand_property_identifier":<span class="cov0" title="0">
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })</span>
                case "pair":<span class="cov0" title="0">
                        if valueNode := child.ChildByFieldName("value"); valueNode != nil &amp;&amp; valueNode.Type() == "identifier" </span><span class="cov0" title="0">{
                                name := source[valueNode.StartByte():valueNode.EndByte()]
                                matches = append(matches, core.CodeMatch{
                                        Node:      valueNode,
                                        Name:      name,
                                        Type:      query.Type,
                                        NodeType:  "identifier",
                                        StartByte: valueNode.StartByte(),
                                        EndByte:   valueNode.EndByte(),
                                        Line:      valueNode.StartPoint().Row,
                                        Column:    valueNode.StartPoint().Column,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) getArrowFunctionName(node *sitter.Node, source string) string <span class="cov2" title="3">{
        parent := node.Parent()
        if parent != nil &amp;&amp; parent.Type() == "variable_declarator" </span><span class="cov2" title="3">{
                if idNode := parent.ChildByFieldName("id"); idNode != nil &amp;&amp; idNode.Type() == "identifier" </span><span class="cov0" title="0">{
                        return source[idNode.StartByte():idNode.EndByte()]
                }</span>
        }

        <span class="cov2" title="3">if parent != nil &amp;&amp; parent.Type() == "assignment_expression" </span><span class="cov0" title="0">{
                if leftNode := parent.ChildByFieldName("left"); leftNode != nil </span><span class="cov0" title="0">{
                        if leftNode.Type() == "member_expression" </span><span class="cov0" title="0">{
                                if propNode := leftNode.ChildByFieldName("property"); propNode != nil </span><span class="cov0" title="0">{
                                        return source[propNode.StartByte():propNode.EndByte()]
                                }</span>
                        } else<span class="cov0" title="0"> if leftNode.Type() == "identifier" </span><span class="cov0" title="0">{
                                return source[leftNode.StartByte():leftNode.EndByte()]
                        }</span>
                }
        }

        <span class="cov2" title="3">return "anonymous"</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package javascript

import (
        "github.com/termfx/morfx/providers/base"
        "github.com/termfx/morfx/providers/catalog"
)

// This package provides JavaScript language support for morfx using the base provider.
// All the heavy lifting is done by the base provider with JavaScript-specific configuration.

func init() <span class="cov1" title="1">{
        catalog.Register(catalog.LanguageInfo{
                ID:         "javascript",
                Extensions: (&amp;Config{}).Extensions(),
        })
}</span>

// New creates a JavaScript provider using base functionality with JS-specific AST mapping
func New() *base.Provider <span class="cov10" title="8">{
        config := &amp;Config{}
        return base.New(config)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package php

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/php"

        "github.com/termfx/morfx/core"
)

// Config implements LanguageConfig for PHP
type Config struct{}

// Language identifier
func (c *Config) Language() string <span class="cov1" title="2">{
        return "php"
}</span>

// Extensions supported
func (c *Config) Extensions() []string <span class="cov1" title="2">{
        return []string{".php", ".phtml", ".php4", ".php5", ".phps"}
}</span>

// GetLanguage returns tree-sitter language for PHP
func (c *Config) GetLanguage() *sitter.Language <span class="cov4" title="19">{
        return php.GetLanguage()
}</span>

// SupportedQueryTypes returns colloquial query types/aliases for PHP
func (c *Config) SupportedQueryTypes() []string <span class="cov0" title="0">{
        m := c.aliasMap()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// MapQueryTypeToNodeTypes maps query types to PHP AST node types
func (c *Config) MapQueryTypeToNodeTypes(queryType string) []string <span class="cov10" title="5941">{
        if nodes, ok := c.aliasMap()[queryType]; ok </span><span class="cov10" title="5941">{
                return nodes
        }</span>
        <span class="cov0" title="0">return []string{queryType}</span>
}

func (c *Config) aliasMap() map[string][]string <span class="cov10" title="5941">{
        return map[string][]string{
                "function":      {"function_definition", "method_declaration", "anonymous_function_creation_expression", "arrow_function"},
                "func":          {"function_definition", "method_declaration", "anonymous_function_creation_expression", "arrow_function"},
                "fn":            {"function_definition", "method_declaration", "anonymous_function_creation_expression", "arrow_function"},
                "closure":       {"anonymous_function_creation_expression"},
                "method":        {"method_declaration"},
                "constructor":   {"method_declaration"},
                "ctor":          {"method_declaration"},
                "class":         {"class_declaration"},
                "interface":     {"interface_declaration"},
                "trait":         {"trait_declaration"},
                "variable":      {"assignment_expression", "simple_parameter", "property_declaration", "variable_name"},
                "var":           {"assignment_expression", "simple_parameter", "property_declaration", "variable_name"},
                "property":      {"property_declaration"},
                "field":         {"property_declaration"},
                "constant":      {"const_declaration", "class_constant_declaration"},
                "const":         {"const_declaration", "class_constant_declaration"},
                "namespace":     {"namespace_definition"},
                "use":           {"namespace_use_declaration"},
                "import":        {"namespace_use_declaration"},
                "include":       {"include_expression"},
                "include_once":  {"include_once_expression"},
                "require":       {"require_expression"},
                "require_once":  {"require_once_expression"},
                "enum":          {"enum_declaration"},
                "array":         {"array_creation_expression"},
                "array_element": {"array_element_initializer"},
                "array_item":    {"array_element_initializer"},
                "element":       {"array_element_initializer"},
                "dict":          {"array_creation_expression"},
                "hash":          {"array_creation_expression"},
                "map":           {"array_creation_expression"},
                "object":        {"array_creation_expression"},
                "list":          {"list_literal"},
                "destructure":   {"list_literal"},
                "comment":       {"comment"},
                "comments":      {"comment"},
        }
}</span>

// ExtractNodeName extracts name from PHP AST nodes
func (c *Config) ExtractNodeName(node *sitter.Node, source string) string <span class="cov6" title="193">{
        switch node.Type() </span>{
        case "function_definition", "class_declaration", "interface_declaration", "trait_declaration":<span class="cov4" title="20">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov4" title="20">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "method_declaration":<span class="cov5" title="76">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov5" title="76">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "arrow_function", "anonymous_function_creation_expression":<span class="cov1" title="1">
                // If assigned to a variable, use the variable name
                if parent := node.Parent(); parent != nil &amp;&amp; parent.Type() == "assignment_expression" </span><span class="cov0" title="0">{
                        if left := parent.ChildByFieldName("left"); left != nil </span><span class="cov0" title="0">{
                                if left.Type() == "variable_name" </span><span class="cov0" title="0">{
                                        name := source[left.StartByte():left.EndByte()]
                                        return strings.TrimPrefix(name, "$")
                                }</span>
                        }
                }
                <span class="cov1" title="1">return "anonymous"</span>
        case "property_declaration":<span class="cov3" title="7">
                // Find first property name
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="27">{
                        child := node.Child(i)
                        if child.Type() == "variable_name" </span><span class="cov0" title="0">{
                                name := source[child.StartByte():child.EndByte()]
                                return strings.TrimPrefix(name, "$") // Remove $ prefix
                        }</span>
                }
        case "variable_name":<span class="cov5" title="51">
                name := source[node.StartByte():node.EndByte()]
                return strings.TrimPrefix(name, "$")</span> // Remove $ prefix
        case "assignment_expression":<span class="cov3" title="10">
                // Extract variable name from left side
                if left := node.ChildByFieldName("left"); left != nil </span><span class="cov3" title="10">{
                        if left.Type() == "variable_name" </span><span class="cov3" title="7">{
                                name := source[left.StartByte():left.EndByte()]
                                return strings.TrimPrefix(name, "$")
                        }</span>
                }
        case "namespace_definition":<span class="cov1" title="1">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov1" title="1">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "namespace_use_declaration":<span class="cov2" title="3">
                // For single-clause uses, attempt to extract the namespace or alias
                // Multi-clause/group uses are expanded in ExpandMatches
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov3" title="11">{
                        child := node.Child(i)
                        if child.Type() == "qualified_name" </span><span class="cov0" title="0">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                        <span class="cov3" title="11">if child.Type() == "namespace_use_clause" </span><span class="cov1" title="2">{
                                if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                        return source[alias.StartByte():alias.EndByte()]
                                }</span>
                                <span class="cov1" title="2">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                        return source[nameNode.StartByte():nameNode.EndByte()]
                                }</span>
                        }
                }
        case "const_declaration", "class_constant_declaration":<span class="cov1" title="2">
                // Try to find the declared constant name
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
                <span class="cov1" title="2">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov2" title="6">{
                        child := node.Child(i)
                        if child.Type() == "name" </span><span class="cov0" title="0">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                        // Some grammars wrap const entries; try to find nested name fields
                        <span class="cov2" title="6">if inner := child.ChildByFieldName("name"); inner != nil </span><span class="cov0" title="0">{
                                return source[inner.StartByte():inner.EndByte()]
                        }</span>
                }
        case "array_element_initializer":<span class="cov0" title="0">
                // Try to use the key or value to derive a name-like label
                if key := node.ChildByFieldName("key"); key != nil </span><span class="cov0" title="0">{
                        return strings.TrimSpace(source[key.StartByte():key.EndByte()])
                }</span>
                <span class="cov0" title="0">if val := node.ChildByFieldName("value"); val != nil </span><span class="cov0" title="0">{
                        return strings.TrimSpace(source[val.StartByte():val.EndByte()])
                }</span>
        case "comment":<span class="cov0" title="0">
                return c.commentSummary(source[node.StartByte():node.EndByte()])</span>
        }

        // Fallback: try to find first identifier or name field
        <span class="cov4" title="37">if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov4" title="22">{
                return source[nameNode.StartByte():nameNode.EndByte()]
        }</span>

        <span class="cov3" title="15">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov5" title="53">{
                child := node.Child(i)
                if child.Type() == "name" </span><span class="cov0" title="0">{
                        return source[child.StartByte():child.EndByte()]
                }</span>
        }

        <span class="cov3" title="15">return ""</span>
}

func (c *Config) commentSummary(raw string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(raw)
        // Strip common PHP comment prefixes
        trimmed = strings.TrimPrefix(trimmed, "///")
        trimmed = strings.TrimPrefix(trimmed, "//")
        trimmed = strings.TrimPrefix(trimmed, "#")
        trimmed = strings.TrimPrefix(trimmed, "/*")
        trimmed = strings.TrimPrefix(trimmed, "/**")
        trimmed = strings.TrimSuffix(trimmed, "*/")
        trimmed = strings.TrimSpace(trimmed)
        if idx := strings.Index(trimmed, "\n"); idx &gt;= 0 </span><span class="cov0" title="0">{
                trimmed = trimmed[:idx]
        }</span>
        <span class="cov0" title="0">trimmed = strings.TrimSpace(strings.TrimPrefix(trimmed, "*"))
        return trimmed</span>
}

// IsExported checks if identifier is exported (in PHP, typically public methods/properties)
func (c *Config) IsExported(name string) bool <span class="cov2" title="6">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // In PHP, consider non-underscore prefixed names as public/exported
        // Private/protected typically start with underscore
        <span class="cov2" title="6">return !strings.HasPrefix(name, "_")</span>
}

// ValidateVisibility checks PHP visibility modifiers for better export detection
func (c *Config) ValidateVisibility(node *sitter.Node, source string) bool <span class="cov1" title="1">{
        parent := node.Parent()
        for parent != nil </span><span class="cov1" title="2">{
                if parent.Type() == "property_declaration" || parent.Type() == "method_declaration" </span><span class="cov1" title="1">{
                        // Check for explicit visibility modifiers
                        for i := 0; i &lt; int(parent.ChildCount()); i++ </span><span class="cov1" title="1">{
                                child := parent.Child(i)
                                childText := source[child.StartByte():child.EndByte()]
                                if childText == "private" || childText == "protected" </span><span class="cov0" title="0">{
                                        return false // Explicitly not exported
                                }</span>
                                <span class="cov1" title="1">if childText == "public" </span><span class="cov1" title="1">{
                                        return true // Explicitly exported
                                }</span>
                        }
                }
                <span class="cov1" title="1">parent = parent.Parent()</span>
        }
        // Fallback to underscore rule
        <span class="cov0" title="0">name := c.ExtractNodeName(node, source)
        return !strings.HasPrefix(name, "_")</span>
}

// ExpandMatches handles multiple property declarations in PHP
func (c *Config) ExpandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov3" title="16">{
        makeMatch := func(target *sitter.Node, name string) []core.CodeMatch </span><span class="cov3" title="16">{
                return []core.CodeMatch{{
                        Node:      target,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  target.Type(),
                        StartByte: target.StartByte(),
                        EndByte:   target.EndByte(),
                        Line:      target.StartPoint().Row,
                        Column:    target.StartPoint().Column,
                }}
        }</span>

        <span class="cov3" title="16">switch node.Type() </span>{
        case "property_declaration":<span class="cov0" title="0">
                return c.expandPropertyDeclaration(node, source, query)</span>
        case "const_declaration", "class_constant_declaration":<span class="cov0" title="0">
                return c.expandConstDeclaration(node, source, query)</span>
        case "namespace_use_declaration":<span class="cov0" title="0">
                return c.expandNamespaceUse(node, source, query)</span>
        case "assignment_expression":<span class="cov0" title="0">
                if left := node.ChildByFieldName("left"); left != nil </span><span class="cov0" title="0">{
                        if left.Type() == "variable_name" </span><span class="cov0" title="0">{
                                name := strings.TrimPrefix(source[left.StartByte():left.EndByte()], "$")
                                return makeMatch(node, name)
                        }</span>
                        <span class="cov0" title="0">if left.Type() == "list_literal" </span><span class="cov0" title="0">{
                                return c.expandListLiteral(left, source, query)
                        }</span>
                }
                <span class="cov0" title="0">name := c.ExtractNodeName(node, source)
                return makeMatch(node, name)</span>
        default:<span class="cov3" title="16">
                name := c.ExtractNodeName(node, source)
                return makeMatch(node, name)</span>
        }
}

func (c *Config) expandPropertyDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "variable_name" &amp;&amp; strings.HasPrefix(source[child.StartByte():child.EndByte()], "$") </span><span class="cov0" title="0">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "variable_name",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandListLiteral(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "variable_name" </span><span class="cov0" title="0">{
                        name := strings.TrimPrefix(source[child.StartByte():child.EndByte()], "$")
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "variable_name",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandConstDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        // Constants can be declared as: const A = 1, B = 2;
        // Collect each "name" token in the declaration
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "name" </span><span class="cov0" title="0">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "name",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span> else<span class="cov0" title="0"> if inner := child.ChildByFieldName("name"); inner != nil </span><span class="cov0" title="0">{
                        name := source[inner.StartByte():inner.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      inner,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "name",
                                StartByte: inner.StartByte(),
                                EndByte:   inner.EndByte(),
                                Line:      inner.StartPoint().Row,
                                Column:    inner.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandNamespaceUse(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        // Handle grouped and multiple clauses: use A\B, C\D as Alias;
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                switch child.Type() </span>{
                case "namespace_use_clause":<span class="cov0" title="0">
                        // Prefer alias, otherwise name
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{
                                        Node:      alias,
                                        Name:      name,
                                        Type:      query.Type,
                                        NodeType:  "alias",
                                        StartByte: alias.StartByte(),
                                        EndByte:   alias.EndByte(),
                                        Line:      alias.StartPoint().Row,
                                        Column:    alias.StartPoint().Column,
                                })
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{
                                        Node:      nameNode,
                                        Name:      name,
                                        Type:      query.Type,
                                        NodeType:  nameNode.Type(),
                                        StartByte: nameNode.StartByte(),
                                        EndByte:   nameNode.EndByte(),
                                        Line:      nameNode.StartPoint().Row,
                                        Column:    nameNode.StartPoint().Column,
                                })
                                continue</span>
                        }
                case "qualified_name":<span class="cov0" title="0">
                        // Simple single-clause use
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  child.Type(),
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })</span>
                }
        }

        // Fallback: single match for the whole declaration
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}
        }</span>

        <span class="cov0" title="0">return matches</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package php

import (
        "github.com/termfx/morfx/providers/base"
        "github.com/termfx/morfx/providers/catalog"
)

// This package provides PHP language support for morfx using the base provider.
// All the heavy lifting is done by the base provider with PHP-specific configuration.

func init() <span class="cov1" title="1">{
        catalog.Register(catalog.LanguageInfo{
                ID:         "php",
                Extensions: (&amp;Config{}).Extensions(),
        })
}</span>

// New creates a PHP provider using base functionality with PHP-specific AST mapping
func New() *base.Provider <span class="cov10" title="17">{
        config := &amp;Config{}
        return base.New(config)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package python

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/python"

        "github.com/termfx/morfx/core"
)

// Config implements LanguageConfig for Python
type Config struct{}

// Language identifier
func (c *Config) Language() string <span class="cov1" title="2">{
        return "python"
}</span>

// Extensions supported
func (c *Config) Extensions() []string <span class="cov1" title="2">{
        return []string{".py", ".pyw", ".pyi"}
}</span>

// GetLanguage returns tree-sitter language for Python
func (c *Config) GetLanguage() *sitter.Language <span class="cov3" title="21">{
        return python.GetLanguage()
}</span>

// MapQueryTypeToNodeTypes maps query types to Python AST node types
func (c *Config) MapQueryTypeToNodeTypes(queryType string) []string <span class="cov10" title="20483">{
        if nodes, ok := c.aliasMap()[queryType]; ok </span><span class="cov10" title="20483">{
                return nodes
        }</span>
        <span class="cov0" title="0">return []string{queryType}</span>
}

func (c *Config) aliasMap() map[string][]string <span class="cov10" title="20483">{
        return map[string][]string{
                "function":   {"function_definition", "async_function_definition"},
                "func":       {"function_definition", "async_function_definition"},
                "fn":         {"function_definition", "async_function_definition"},
                "method":     {"function_definition", "async_function_definition"},
                "def":        {"function_definition", "async_function_definition"},
                "class":      {"class_definition"},
                "cls":        {"class_definition"},
                "type":       {"type_alias_statement"},
                "alias":      {"type_alias_statement"},
                "type_alias": {"type_alias_statement"},
                "variable":   {"assignment", "augmented_assignment", "global_statement", "nonlocal_statement"},
                "var":        {"assignment", "augmented_assignment", "global_statement", "nonlocal_statement"},
                "import":     {"import_statement", "import_from_statement"},
                "from":       {"import_from_statement"},
                "decorator":  {"decorator"},
                "lambda":     {"lambda"},
                "comment":    {"comment"},
                "comments":   {"comment"},
        }
}</span>

// SupportedQueryTypes returns colloquial query types/aliases for Python
func (c *Config) SupportedQueryTypes() []string <span class="cov0" title="0">{
        m := c.aliasMap()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// ExtractNodeName extracts name from Python AST nodes
func (c *Config) ExtractNodeName(node *sitter.Node, source string) string <span class="cov5" title="225">{
        switch node.Type() </span>{
        case "function_definition", "async_function_definition", "class_definition":<span class="cov5" title="164">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov5" title="164">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "assignment", "augmented_assignment":<span class="cov3" title="17">
                // Find left side of assignment
                if leftNode := node.ChildByFieldName("left"); leftNode != nil </span><span class="cov3" title="17">{
                        if leftNode.Type() == "identifier" </span><span class="cov3" title="13">{
                                return source[leftNode.StartByte():leftNode.EndByte()]
                        }</span>
                }
        case "lambda":<span class="cov0" title="0">
                return "anonymous"</span>
        case "import_statement":<span class="cov2" title="9">
                // Get first imported module
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov3" title="18">{
                        child := node.Child(i)
                        if child.Type() == "dotted_name" || child.Type() == "identifier" </span><span class="cov2" title="8">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "import_from_statement":<span class="cov3" title="13">
                // Get module being imported from
                if moduleNode := node.ChildByFieldName("module_name"); moduleNode != nil </span><span class="cov3" title="13">{
                        return source[moduleNode.StartByte():moduleNode.EndByte()]
                }</span>
        case "type_alias_statement":<span class="cov0" title="0">
                if left := node.ChildByFieldName("left"); left != nil </span><span class="cov0" title="0">{
                        return source[left.StartByte():left.EndByte()]
                }</span>
        case "decorator":<span class="cov3" title="20">
                // Get decorator name
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="40">{
                        child := node.Child(i)
                        if child.Type() == "identifier" || child.Type() == "attribute" </span><span class="cov3" title="12">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "comment":<span class="cov0" title="0">
                return c.commentSummary(source[node.StartByte():node.EndByte()])</span>
        }

        // Fallback: try to find first identifier child
        <span class="cov3" title="15">if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov1" title="1">{
                return source[nameNode.StartByte():nameNode.EndByte()]
        }</span>

        <span class="cov3" title="14">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="32">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov2" title="4">{
                        return source[child.StartByte():child.EndByte()]
                }</span>
        }

        <span class="cov3" title="10">return ""</span>
}

func (c *Config) commentSummary(raw string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(raw)
        trimmed = strings.TrimPrefix(trimmed, "#")
        trimmed = strings.TrimPrefix(trimmed, "//")
        trimmed = strings.TrimPrefix(trimmed, "/*")
        trimmed = strings.TrimPrefix(trimmed, "/**")
        trimmed = strings.TrimSuffix(trimmed, "*/")
        trimmed = strings.TrimSpace(trimmed)
        if idx := strings.Index(trimmed, "\n"); idx &gt;= 0 </span><span class="cov0" title="0">{
                trimmed = trimmed[:idx]
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(strings.TrimPrefix(trimmed, "*"))</span>
}

// ValidateAssignment ensures assignments are actual variable definitions, not attribute assignments
func (c *Config) ValidateAssignment(node *sitter.Node, source, queryType string) bool <span class="cov1" title="1">{
        if (node.Type() != "assignment" &amp;&amp; node.Type() != "augmented_assignment") || queryType != "variable" </span><span class="cov1" title="1">{
                return true // Not assignment or not variable query
        }</span>

        <span class="cov0" title="0">leftNode := node.ChildByFieldName("left")
        if leftNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Only accept simple identifiers and tuple/list unpacking for variable queries
        <span class="cov0" title="0">switch leftNode.Type() </span>{
        case "identifier":<span class="cov0" title="0">
                return true</span> // Simple variable assignment: x = 1
        case "tuple", "list", "pattern_list":<span class="cov0" title="0">
                return true</span> // Tuple unpacking: a, b = 1, 2
        case "attribute":<span class="cov0" title="0">
                return false</span> // Attribute assignment: self.x = 1
        case "subscript":<span class="cov0" title="0">
                return false</span> // Array assignment: arr[0] = 1
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsExported checks if identifier is exported (in Python, typically non-underscore prefixed)
func (c *Config) IsExported(name string) bool <span class="cov2" title="5">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // In Python, single underscore prefix indicates "internal use"
        // Double underscore indicates "private" (name mangling)
        <span class="cov2" title="5">return !strings.HasPrefix(name, "_")</span>
}

// ExpandMatches handles tuple unpacking and multiple assignments in Python
func (c *Config) ExpandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov3" title="14">{
        switch node.Type() </span>{
        case "assignment":<span class="cov0" title="0">
                return c.expandAssignment(node, source, query)</span>
        case "augmented_assignment":<span class="cov0" title="0">
                return c.expandAssignment(node, source, query)</span>
        case "import_statement":<span class="cov0" title="0">
                return c.expandImport(node, source, query)</span>
        case "import_from_statement":<span class="cov0" title="0">
                return c.expandImportFrom(node, source, query)</span>
        default:<span class="cov3" title="14">
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        }
}

func (c *Config) expandAssignment(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="1">{
        var matches []core.CodeMatch

        leftNode := node.ChildByFieldName("left")
        if leftNode == nil </span><span class="cov0" title="0">{
                return matches
        }</span>

        <span class="cov1" title="1">switch leftNode.Type() </span>{
        case "identifier":<span class="cov0" title="0">
                name := source[leftNode.StartByte():leftNode.EndByte()]
                matches = append(matches, core.CodeMatch{
                        Node:      leftNode,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  "identifier",
                        StartByte: leftNode.StartByte(),
                        EndByte:   leftNode.EndByte(),
                        Line:      leftNode.StartPoint().Row,
                        Column:    leftNode.StartPoint().Column,
                })</span>
        case "tuple", "list":<span class="cov0" title="0">
                matches = append(matches, c.expandTupleOrList(leftNode, source, query)...)</span>
        case "pattern_list":<span class="cov1" title="1">
                matches = append(matches, c.expandPatternList(leftNode, source, query)...)</span>
        }

        <span class="cov1" title="1">return matches</span>
}

func (c *Config) expandTupleOrList(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="1">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov2" title="7">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov1" title="3">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov1" title="1">return matches</span>
}

func (c *Config) expandPatternList(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="2">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov2" title="8">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov2" title="5">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov1" title="2">return matches</span>
}

func (c *Config) expandImport(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        // import a as b, c
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "aliased_import" </span><span class="cov0" title="0">{
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
                <span class="cov0" title="0">if child.Type() == "dotted_name" || child.Type() == "identifier" </span><span class="cov0" title="0">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                }</span>
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandImportFrom(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        // from x import a as b, c
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "aliased_import" </span><span class="cov0" title="0">{
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
                <span class="cov0" title="0">if child.Type() == "identifier" </span><span class="cov0" title="0">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                }</span>
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package python

import (
        "github.com/termfx/morfx/providers/base"
        "github.com/termfx/morfx/providers/catalog"
)

// This package provides Python language support for morfx using the base provider.
// All the heavy lifting is done by the base provider with Python-specific configuration.

func init() <span class="cov1" title="1">{
        catalog.Register(catalog.LanguageInfo{
                ID:         "python",
                Extensions: (&amp;Config{}).Extensions(),
        })
}</span>

// New creates a Python provider using base functionality with Python-specific AST mapping
func New() *base.Provider <span class="cov10" title="17">{
        config := &amp;Config{}
        return base.New(config)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package typescript

import (
        "strings"

        sitter "github.com/smacker/go-tree-sitter"
        "github.com/smacker/go-tree-sitter/typescript/typescript"

        "github.com/termfx/morfx/core"
)

// Config implements LanguageConfig for TypeScript
type Config struct{}

// Language identifier
func (c *Config) Language() string <span class="cov1" title="2">{
        return "typescript"
}</span>

// Extensions supported
func (c *Config) Extensions() []string <span class="cov1" title="2">{
        return []string{".ts", ".tsx", ".d.ts"}
}</span>

// GetLanguage returns tree-sitter language for TypeScript
func (c *Config) GetLanguage() *sitter.Language <span class="cov3" title="21">{
        return typescript.GetLanguage()
}</span>

// MapQueryTypeToNodeTypes maps query types to TypeScript AST node types
func (c *Config) MapQueryTypeToNodeTypes(queryType string) []string <span class="cov10" title="14055">{
        if nodes, ok := c.aliasMap()[queryType]; ok </span><span class="cov10" title="14055">{
                return nodes
        }</span>
        <span class="cov0" title="0">return []string{queryType}</span>
}

func (c *Config) aliasMap() map[string][]string <span class="cov10" title="14055">{
        return map[string][]string{
                "function":    {"function_declaration", "function_expression", "arrow_function", "method_definition", "method_signature", "public_field_definition"},
                "func":        {"function_declaration", "function_expression", "arrow_function", "method_definition", "method_signature", "public_field_definition"},
                "fn":          {"function_declaration", "function_expression", "arrow_function", "method_definition", "method_signature", "public_field_definition"},
                "class":       {"class_declaration", "class_expression"},
                "interface":   {"interface_declaration"},
                "iface":       {"interface_declaration"},
                "type":        {"type_alias_declaration"},
                "enum":        {"enum_declaration"},
                "enum_member": {"enum_member"},
                "member":      {"enum_member"},
                "method":      {"method_definition", "method_signature"},
                "getter":      {"method_definition", "method_signature"},
                "setter":      {"method_definition", "method_signature"},
                "accessor":    {"method_definition", "method_signature"},
                "constructor": {"method_definition"},
                "ctor":        {"method_definition"},
                "variable":    {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "var":         {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "const":       {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "let":         {"variable_declaration", "lexical_declaration", "variable_declarator"},
                "lambda":      {"arrow_function"},
                "arrow":       {"arrow_function"},
                "array":       {"array", "array_pattern"},
                "object":      {"object", "object_pattern"},
                "import":      {"import_statement"},
                "export":      {"export_statement"},
                "module":      {"module_declaration"},
                "namespace":   {"namespace_declaration"},
                "property":    {"public_field_definition", "private_field_definition", "field_definition", "property_signature"},
                "prop":        {"public_field_definition", "private_field_definition", "field_definition", "property_signature"},
                "field":       {"public_field_definition", "private_field_definition", "field_definition", "property_signature"},
                "signature":   {"method_signature", "function_signature", "construct_signature", "index_signature", "call_signature"},
                "decorator":   {"decorator"},
                "comment":     {"comment"},
                "comments":    {"comment"},
        }
}</span>

// SupportedQueryTypes returns colloquial query types/aliases for TypeScript
func (c *Config) SupportedQueryTypes() []string <span class="cov0" title="0">{
        m := c.aliasMap()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// ExtractNodeName extracts name from TypeScript AST nodes
func (c *Config) ExtractNodeName(node *sitter.Node, source string) string <span class="cov5" title="155">{
        switch node.Type() </span>{
        case "function_declaration", "class_declaration", "class_expression",
                "interface_declaration", "type_alias_declaration", "enum_declaration",
                "module_declaration", "namespace_declaration":<span class="cov4" title="32">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov4" title="32">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "method_definition", "method_signature":<span class="cov4" title="69">
                // Try 'key' field first (common in many languages)
                if keyNode := node.ChildByFieldName("key"); keyNode != nil </span><span class="cov0" title="0">{
                        return source[keyNode.StartByte():keyNode.EndByte()]
                }</span>
                // Try property_identifier as direct child (TypeScript specific)
                <span class="cov4" title="69">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov5" title="126">{
                        child := node.Child(i)
                        if child.Type() == "property_identifier" </span><span class="cov4" title="67">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "public_field_definition", "private_field_definition", "field_definition":<span class="cov2" title="5">
                // Class field definition: fieldName = value
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov3" title="10">{
                        child := node.Child(i)
                        if child.Type() == "property_identifier" </span><span class="cov2" title="5">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "property_signature":<span class="cov0" title="0">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                        child := node.Child(i)
                        if child.Type() == "property_identifier" </span><span class="cov0" title="0">{
                                return source[child.StartByte():child.EndByte()]
                        }</span>
                }
        case "enum_member":<span class="cov0" title="0">
                if nameNode := node.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                        return source[nameNode.StartByte():nameNode.EndByte()]
                }</span>
        case "variable_declarator":<span class="cov3" title="17">
                if idNode := node.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                        return source[idNode.StartByte():idNode.EndByte()]
                }</span>
        case "lexical_declaration":<span class="cov3" title="16">
                // Find first variable declarator
                for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov4" title="48">{
                        child := node.Child(i)
                        if child.Type() == "variable_declarator" </span><span class="cov3" title="16">{
                                if idNode := child.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                                        return source[idNode.StartByte():idNode.EndByte()]
                                }</span>
                        }
                }
        case "import_statement", "export_statement":<span class="cov2" title="6">
                // Get import/export source
                if sourceNode := node.ChildByFieldName("source"); sourceNode != nil </span><span class="cov2" title="6">{
                        path := source[sourceNode.StartByte():sourceNode.EndByte()]
                        return strings.Trim(path, `"'`)
                }</span>
        case "arrow_function", "function_expression":<span class="cov3" title="9">
                // For arrow functions, check if they're assigned to a variable
                parent := node.Parent()
                if parent != nil &amp;&amp; parent.Type() == "variable_declarator" </span><span class="cov2" title="8">{
                        if idNode := parent.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                                return source[idNode.StartByte():idNode.EndByte()]
                        }</span>
                }
                // Check if it's a property value in an object
                <span class="cov3" title="9">if parent != nil &amp;&amp; parent.Type() == "pair" </span><span class="cov0" title="0">{
                        if keyNode := parent.ChildByFieldName("key"); keyNode != nil </span><span class="cov0" title="0">{
                                return source[keyNode.StartByte():keyNode.EndByte()]
                        }</span>
                }
                // Check if it's a method in a class (property assignment)
                <span class="cov3" title="9">if parent != nil &amp;&amp; parent.Type() == "method_definition" </span><span class="cov0" title="0">{
                        if keyNode := parent.ChildByFieldName("key"); keyNode != nil </span><span class="cov0" title="0">{
                                return source[keyNode.StartByte():keyNode.EndByte()]
                        }</span>
                }
                // Check if it's a class field with arrow function (findAll = async () =&gt; {})
                <span class="cov3" title="9">if parent != nil &amp;&amp; parent.Type() == "assignment_expression" </span><span class="cov0" title="0">{
                        if leftNode := parent.ChildByFieldName("left"); leftNode != nil </span><span class="cov0" title="0">{
                                if leftNode.Type() == "member_expression" </span><span class="cov0" title="0">{
                                        if propertyNode := leftNode.ChildByFieldName("property"); propertyNode != nil </span><span class="cov0" title="0">{
                                                return source[propertyNode.StartByte():propertyNode.EndByte()]
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return source[leftNode.StartByte():leftNode.EndByte()]
                                }</span>
                        }
                }
                // Check if it's a public_field_definition (class field: findAll = () =&gt; {})
                <span class="cov3" title="9">if parent != nil &amp;&amp; parent.Type() == "public_field_definition" </span><span class="cov1" title="1">{
                        // Get the first child which should be the property_identifier
                        for i := 0; i &lt; int(parent.ChildCount()); i++ </span><span class="cov1" title="1">{
                                child := parent.Child(i)
                                if child.Type() == "property_identifier" </span><span class="cov1" title="1">{
                                        return source[child.StartByte():child.EndByte()]
                                }</span>
                        }
                }
                <span class="cov2" title="8">return "anonymous"</span>
        case "comment":<span class="cov0" title="0">
                return c.commentSummary(source[node.StartByte():node.EndByte()])</span>
        }

        // Fallback: try to find first identifier child
        <span class="cov4" title="36">for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov5" title="74">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov3" title="17">{
                        return source[child.StartByte():child.EndByte()]
                }</span>
        }

        <span class="cov3" title="19">return ""</span>
}

func (c *Config) commentSummary(raw string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(raw)
        trimmed = strings.TrimPrefix(trimmed, "///")
        trimmed = strings.TrimPrefix(trimmed, "//")
        trimmed = strings.TrimPrefix(trimmed, "/*")
        trimmed = strings.TrimPrefix(trimmed, "/**")
        trimmed = strings.TrimSuffix(trimmed, "*/")
        trimmed = strings.TrimPrefix(trimmed, "#")
        trimmed = strings.TrimSpace(trimmed)
        if idx := strings.Index(trimmed, "\n"); idx &gt;= 0 </span><span class="cov0" title="0">{
                trimmed = trimmed[:idx]
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(strings.TrimPrefix(trimmed, "*"))</span>
}

// IsExported checks if identifier is exported (TS uses various export patterns)
func (c *Config) IsExported(name string) bool <span class="cov2" title="4">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // In TypeScript, consider PascalCase as exported/public APIs
        <span class="cov2" title="4">return name[0] &gt;= 'A' &amp;&amp; name[0] &lt;= 'Z'</span>
}

// ExpandMatches handles destructuring and multi-variable declarations in TypeScript
func (c *Config) ExpandMatches(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov2" title="8">{
        switch node.Type() </span>{
        case "variable_declaration", "lexical_declaration":<span class="cov0" title="0">
                return c.expandVariableDeclaration(node, source, query)</span>
        case "variable_declarator":<span class="cov0" title="0">
                return c.expandVariableDeclarator(node, source, query)</span>
        case "arrow_function":<span class="cov0" title="0">
                name := c.getArrowFunctionName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        case "import_statement":<span class="cov0" title="0">
                return c.expandImportStatement(node, source, query)</span>
        case "export_statement":<span class="cov0" title="0">
                return c.expandExportStatement(node, source, query)</span>
        default:<span class="cov2" title="8">
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{
                        Node:      node,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  node.Type(),
                        StartByte: node.StartByte(),
                        EndByte:   node.EndByte(),
                        Line:      node.StartPoint().Row,
                        Column:    node.StartPoint().Column,
                }}</span>
        }
}

func (c *Config) expandVariableDeclaration(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "variable_declarator" </span><span class="cov0" title="0">{
                        matches = append(matches, c.expandVariableDeclarator(child, source, query)...)
                }</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandVariableDeclarator(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        idNode := node.ChildByFieldName("id")
        if idNode == nil </span><span class="cov0" title="0">{
                return matches
        }</span>

        <span class="cov0" title="0">switch idNode.Type() </span>{
        case "identifier":<span class="cov0" title="0">
                name := source[idNode.StartByte():idNode.EndByte()]
                matches = append(matches, core.CodeMatch{
                        Node:      idNode,
                        Name:      name,
                        Type:      query.Type,
                        NodeType:  "identifier",
                        StartByte: idNode.StartByte(),
                        EndByte:   idNode.EndByte(),
                        Line:      idNode.StartPoint().Row,
                        Column:    idNode.StartPoint().Column,
                })</span>
        case "array_pattern":<span class="cov0" title="0">
                matches = append(matches, c.expandArrayPattern(idNode, source, query)...)</span>
        case "object_pattern":<span class="cov0" title="0">
                matches = append(matches, c.expandObjectPattern(idNode, source, query)...)</span>
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandArrayPattern(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov1" title="1">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov2" title="7">{
                child := node.Child(i)
                if child.Type() == "identifier" </span><span class="cov2" title="3">{
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })
                }</span>
        }

        <span class="cov1" title="1">return matches</span>
}

func (c *Config) expandObjectPattern(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch

        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                switch child.Type() </span>{
                case "shorthand_property_identifier":<span class="cov0" title="0">
                        name := source[child.StartByte():child.EndByte()]
                        matches = append(matches, core.CodeMatch{
                                Node:      child,
                                Name:      name,
                                Type:      query.Type,
                                NodeType:  "identifier",
                                StartByte: child.StartByte(),
                                EndByte:   child.EndByte(),
                                Line:      child.StartPoint().Row,
                                Column:    child.StartPoint().Column,
                        })</span>
                case "pair":<span class="cov0" title="0">
                        if valueNode := child.ChildByFieldName("value"); valueNode != nil &amp;&amp; valueNode.Type() == "identifier" </span><span class="cov0" title="0">{
                                name := source[valueNode.StartByte():valueNode.EndByte()]
                                matches = append(matches, core.CodeMatch{
                                        Node:      valueNode,
                                        Name:      name,
                                        Type:      query.Type,
                                        NodeType:  "identifier",
                                        StartByte: valueNode.StartByte(),
                                        EndByte:   valueNode.EndByte(),
                                        Line:      valueNode.StartPoint().Row,
                                        Column:    valueNode.StartPoint().Column,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return matches</span>
}

func (c *Config) getArrowFunctionName(node *sitter.Node, source string) string <span class="cov0" title="0">{
        parent := node.Parent()
        if parent != nil &amp;&amp; parent.Type() == "variable_declarator" </span><span class="cov0" title="0">{
                if idNode := parent.ChildByFieldName("id"); idNode != nil </span><span class="cov0" title="0">{
                        return source[idNode.StartByte():idNode.EndByte()]
                }</span>
        }
        <span class="cov0" title="0">return "anonymous"</span>
}

func (c *Config) expandImportStatement(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                switch child.Type() </span>{
                case "import_specifier":<span class="cov0" title="0">
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                case "namespace_import":<span class="cov0" title="0">
                        if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}

func (c *Config) expandExportStatement(node *sitter.Node, source string, query core.AgentQuery) []core.CodeMatch <span class="cov0" title="0">{
        var matches []core.CodeMatch
        for i := 0; i &lt; int(node.ChildCount()); i++ </span><span class="cov0" title="0">{
                child := node.Child(i)
                if child.Type() == "export_specifier" </span><span class="cov0" title="0">{
                        if alias := child.ChildByFieldName("alias"); alias != nil </span><span class="cov0" title="0">{
                                name := source[alias.StartByte():alias.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                        <span class="cov0" title="0">if nameNode := child.ChildByFieldName("name"); nameNode != nil </span><span class="cov0" title="0">{
                                name := source[nameNode.StartByte():nameNode.EndByte()]
                                matches = append(matches, core.CodeMatch{Node: child, Name: name, Type: query.Type, NodeType: child.Type(), StartByte: child.StartByte(), EndByte: child.EndByte(), Line: child.StartPoint().Row, Column: child.StartPoint().Column})
                                continue</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(matches) == 0 </span><span class="cov0" title="0">{
                name := c.ExtractNodeName(node, source)
                return []core.CodeMatch{{Node: node, Name: name, Type: query.Type, NodeType: node.Type(), StartByte: node.StartByte(), EndByte: node.EndByte(), Line: node.StartPoint().Row, Column: node.StartPoint().Column}}
        }</span>
        <span class="cov0" title="0">return matches</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package typescript

import (
        "github.com/termfx/morfx/providers/base"
        "github.com/termfx/morfx/providers/catalog"
)

// This package provides TypeScript language support for morfx using the base provider.
// All the heavy lifting is done by the base provider with TypeScript-specific configuration.

func init() <span class="cov1" title="1">{
        catalog.Register(catalog.LanguageInfo{
                ID:         "typescript",
                Extensions: (&amp;Config{}).Extensions(),
        })
}</span>

// New creates a TypeScript provider using base functionality with TS-specific AST mapping
func New() *base.Provider <span class="cov10" title="18">{
        config := &amp;Config{}
        return base.New(config)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
